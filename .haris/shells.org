#+TITLE: Shell Config
#+PROPERTY: header-args :tangle (haris/tangle-home ".config/fish/config.fish") :mkdirp yes :results silent :noweb yes

This is a config for the shells I use:

- *dash* as the system shell (because it's faster)
- *fish* as my interactive shell
- *bash* for some scripts because it's more convenient than dash and more POSIX compliant
  than fish
Using org-tangle, I output the configs to the files they need to be in:

- =~/.profile= is sourced by login, making everything in it available to all shells.
- =~/.bashrc= is sourced by *bash* and *fish* (using the *bass* extension).
- The files =~/.alias= and =~/.alias-gui= contain aliases that I want available in
  all shells.

Additionally, =~/.alias-tmp= and  =~/.alias-gui-tmp= are not tangled from this file.
Instead I create them manually when needed to hold temporary aliases for the
purposes of experimentation. They are not under VCS.

* Fish
Note: I keep fish aliases in [[#alias-fish][Aliases]].
#+begin_src fish
  set fish_greeting ''
  [ -z "$EMACS_VTERM_PATH" ] && fish_vi_key_bindings || fish_default_key_bindings

  # Disable path shortening
  set fish_prompt_pwd_dir_length 0

  # I'm setting HOME to prevent errors when running inside tuterm
  HOME="/home/$USER" bass source ~/.bashrc        # Load bash's config
  source "$__fish_config_dir"/tmp.fish          # Temporary aliases
  source "$__fish_config_dir"/private.fish      # Private aliases

  set -gx MANPAGER 'viman'                      # Set default pager to vim
  set -gx MANWIDTH 80
  set -gx EDITOR 'nvim'
  set -gx VISUAL 'gvim'

  function fish_user_key_bindings               # Start bindings
#+end_src
** Quasi-vim-like key bindings
#+begin_src fish
  bind -M default \el forward-char
  bind -M insert \el forward-char
  bind -M default \eh backward-char
  bind -M insert \eh backward-char
  bind -M default \cp up-or-search
  bind -M insert \cp up-or-search
  bind -M default \cn down-or-search
  bind -M insert \cn down-or-search
#+end_src
** Fish behavior control bindings
#+begin_src fish
  bind -M default \er src_fish
  bind -M insert \er src_fish
#+end_src
** Other bindings
#+begin_src fish
  # Copy the current contents of the command line
  bind -M default \ec 'commandline -b | xsel -b'
  bind -M insert  \ec 'commandline -b | xsel -b'

  # Run the current command in bash
  bind -M default \eb __haris_run_in_bash
  bind -M insert  \eb __haris_run_in_bash

  # Prepend o in front of current command
  bind -M default \eo '__haris_prepend_cmdline o'
  bind -M insert  \eo '__haris_prepend_cmdline o'

  # Prepend man in front of current command
  bind -M default \em '__haris_show_man'
  bind -M insert  \em '__haris_show_man'

  # Append --help to the end of the command line and submit
  bind -M default \eH '__haris_print_help_or_toggle'
  bind -M insert \eH '__haris_print_help_or_toggle'

  bind -M default \et term
  bind -M insert  \et term

  bind -M default \eg 'dragon (command ls | fzf --multi) >/dev/null 2>&1'
  bind -M insert  \eg 'dragon (command ls | fzf --multi) >/dev/null 2>&1'

  bind -M default \ee 'VISUAL="$EDITOR" edit_command_buffer'
  bind -M insert  \ee 'VISUAL="$EDITOR" edit_command_buffer'

  bind -M insert  \ea 'commandline -i "(adhoc)"'
  bind -M default \ea 'commandline -i "(adhoc)"'

  bind -M insert  \eA 'commandline -i "(adhoc - | string collect)"'
  bind -M default \eA 'commandline -i "(adhoc - | string collect)"'

  bind -M insert  \eG 'magit'
  bind -M default \eG 'magit'
  end                                          # End fish_user_key_bindings
#+end_src
*** Helper functions
#+begin_src fish
  function __haris_run_in_bash
      set -l cmd (commandline -b)
      echo
      eval bash -c "'source ~/.bashrc; $cmd'"
      commandline -f repaint
      commandline -r ''
  end

  function __haris_prepend_cmdline
      commandline --cursor 0
      commandline --insert "$argv "
      commandline --function end-of-line
  end

  function __haris_show_man
      man (commandline --current-process --tokenize | grep -v '^sudo$' | head -1)
  end

  function __haris_print_help_or_toggle
      if [ (commandline -o | tail -1) = "--help" ]
          commandline -r (commandline | string replace -r -- '\s*--help$' '')
          return
      end
      commandline --append " --help"
      commandline -f execute
  end


  function __haris_cmdline_editor
      commandline > /tmp/haris_cmdline.fish
      "$EDITOR" /tmp/haris_cmdline.fish
      commandline --replace (cat /tmp/haris_cmdline.fish)
  end
#+end_src
** Custom colors
#+begin_src fish
  set -U fish_color_command           brblue
  set -U fish_color_quote             brgreen
  set -U fish_color_param             brcyan
  set -U fish_color_autosuggestion    brblack
  set -U fish_color_cancel         -r red
  set -U fish_color_error             red
  set -U fish_color_comment           green
  set -U fish_color_operator          normal
  set -U fish_color_redirection       brmagenta
  set -U fish_pager_color_progress    brgreen
  set -U fish_pager_color_description green
  set -U fish_color_end               yellow
#+end_src
** Plugins
#+begin_src fish
  # pj plugin
  set -gx PROJECT_PATHS ~/proj ~/proj/drytoe

  # z.lua
  set _ZL_CMD z
  lua /usr/share/z.lua/z.lua --init fish | source
  set -gx _ZL_CD cd

  # tem
  tem fish-init

  # fzf bindings
  fzf_configure_bindings
#+end_src
*** Dependencies
#+begin_src shell :tangle (haris/tangle-deps "fish.sh")
  paru -S fish fisher
  touch ~/.config/fish/{private,tmp}.fish
  fish -c 'fisher install edc/bass \
                          oh-my-fish/plugin-pj \
                          PatrickF1/fzf.fish \
                          evanlucas/fish-kubectl-completions'
  sudo pacman -S fd bat # Dependencies for fzf.fish
#+end_src
** Functions
#+begin_src fish
  # Create a new dir and cd
  function ndir;  mkdir -p "$argv"; cd "$argv"; end

  # Print first argument
  function 1; echo $argv[1]; end

  # Run a command and disown
  function o; $argv & disown >/dev/null 2>/dev/null; end

  # Run z through fzf
  function a
      z -l $argv | read -z choices
      set -l count (echo "$choices" | sed '/^$/d' | wc -l)
      set dest (echo "$choices" | sed '/^$/d' | tac | fzf --select-1)

      cd (echo "$dest" | sed -E -e '/^$/d' -e 's/^\S+\s+//')
  end

  # Open a GUI app and disown
  function open; for file in $argv; o xdg-open "$file"; end; end

  # Wrapper around imount script so I can cd to the mount directory
  function imount
      command imount $argv
      cd (cat /tmp/imount_directory)
  end

  # Vim help
  function vh; vim -c ":h $argv | only"; end

  # Save the path of the argument to the clipboard
  function copypath; realpath $argv | xsel -b; end

  # When you ls, save the argument so you can quickly cd to that folder.
  # It's not fool-proof, but it works in most situations and it's safe.
  function ls
      if [ -z "$EMACS_VTERM_PATH" ]
          # In emacs vterm, lsd outputs additional whitespace which is annoying
          lsd --color=auto $argv
      else
          command ls --color=auto $argv
      end
      set -g __last_ls_arg "$argv"
  end

  # cd the last directory you have ls-ed
  function cdls
      [ -n "$__last_ls_arg" ] && cd "$__last_ls_arg"
  end
  # vim the last file you have ls-ed
  function vils
      [ -n "$__last_ls_arg" ] && vim "$__last_ls_arg"
  end

  function chbg
      set path /usr/share/backgrounds/"$argv[1]"
      feh --bg-fill "$path"
      rm ~/.wallpaper
      ln -s "$path" ~/.wallpaper
  end

  function cdcf;   set file (cf "$argv");   test -f "$file" && cd (dirname        "$file"); end
  function catcf;  set file (cf "$argv");   test -f "$file" && cat                "$file" ; end
  function vicf;   set file (cf "$argv");   test -f "$file" && vim                "$file" ; end
  function ecf;    set file (cf "$argv");   test -f "$file" && myemacs-float "$file" ; end

  function cdcmd;  set file (fcmd "$argv"); test -f "$file" && cd (dirname "$file"); end
  function catcmd; set file (fcmd "$argv"); test -f "$file" && cat         "$file" ; end
  function ecmd;   set file (fcmd "$argv"); test -f "$file" && myemacs     "$file" ; end
  function rmcmd;  set file (fcmd "$argv"); rm "$file";                              end
  function vicmd
      set file (fcmd "$argv");
      if [ -f "$file" ]
          vim "$file"
      else
          read -n 1 -P "Create new script? [y/N]: " choice
          if [ "$choice" = 'y' ]
              set file ~/.haris-bin/"$argv[1]"
              tem put sh -o "$file"
              chx "$file"
              cp --link "$file" ~/.local/bin/
              vim +'$' "$file"
          else
              echo 'Aborting...'
              return 1
          end
      end
  end

  function sconf
      set -l gitdir ~/.secret
      set -l worktree_option --work-tree="$HOME"
      if [ -e ".secret" ]
          set gitdir (pwd)/.secret
          if [ ~ != (pwd) ]
              set -le worktree_option
          end
      end

      git --git-dir="$gitdir" $worktree_option $argv
  end

  # Customize fish to notify me when a command finishes in a background terminal
  # window.
  function fish_right_prompt
      set -l _status "$status"

      # Check if terminal window is hidden
      if xdotool search --all --onlyvisible "" 2>/dev/null | ! grep -q "$WINDOWID"
          set -l exit_message
          if [ "$_status" = 0 ]
              set exit_message "exited successfully"
          else
              set exit_message "exited with $_status"
          end
          notify-send (echo "Command "(history | head -1)"" "$exit_message")
      end
  end
#+end_src
*** =^=
#+begin_src fish
  function ^ -d "cd to the first directory in the hierarchy by specified name" -a name
      pushd "$PWD"
      while [ "$PWD" != "/" ]
          if [ (basename "$PWD") = "$name" ]
              set -l dir "$PWD"
              popd
              cd "$dir"
              return
          end
          cd ..
      end
      popd
      return 1
  end
#+end_src
**** Completions
#+begin_src fish
  complete -c ^ -a '(pwd | tr "/" "\n")' -f
#+end_src
** Completions
Function(s) that will be used by many completions.
Completions for the functions defined in [[Functions]].
#+begin_src fish
  # Return success if the command line contains no positional arguments
  function no_positional_args
      set -l -- args    (commandline -po)         # cmdline broken up into list
      set -l -- cmdline (commandline -p)          # single string
      set -l -- n       (count $args)             # number of cmdline tokens
      for i in (seq 2 $n)
          set -l arg $args[$i]
          [ -z "$arg" ] && continue               # can be caused by '--' argument

          # If the the last token is a positional argument and there is no
          # trailing space, we ignore it
          [ "$i" = "$n" ] && [ (string sub -s -1 "$cmdline") != ' ' ] && break

          if string match -rvq '^-' -- "$arg"     # doesn't start with -
              return 1
          end
      end
      # contains a '--' argument
      string match -r -- '\s--\s' "$cmdline" && return 1
      return 0
  end

  complete --command chbg --no-files --arguments="(pushd /usr/share/backgrounds/; command ls -1; popd)"
  complete --command cmd-with-notify -f -a '(complete -C(commandline -cp | sed "s:\S\+::"))'
  complete -c snip -f -a \
      "(pushd ~/.vim/snips; command ls | sed 's_\(.*\)\.snippets_\1_g'; popd)"

  # *cf and *cmd style commands
  for cmd in {,cd,vi,cat,e}cf
      complete --command $cmd --no-files -a '(lscf)'
  end
  for cmd in {f,cd,vi,cat,e, rm}cmd
      complete -c $cmd -f \
          -a '(command ls -1 $PATH 2>/dev/null | grep -v "/")'
  end
#+end_src
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/adhoc.fish")
  complete -c adhoc -f \
      -a "(complete -C'adsfadadflasdjflasdflnasdflasdu /tmp/adhoc-files/' | string replace /tmp/adhoc-files/ \"\")"
#+end_src
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/pass.fish")
  source /usr/share/fish/vendor_completions.d/pass.fish
  complete -c pass -a 'add' -n "no_positional_args"
  complete -c pass -a '(complete -C "pass show ")' -f -n '__fish_seen_subcommand_from add'
#+end_src
#+begin_src shell :tangle (haris/tangle-home ".config/fish/completions/otp.fish")
    complete -c otp -a '(fd "otp-secret.gpg" ~/.password-store -x echo {//} | sed "s:^.*/\.password-store/\?::")' -f
#+end_src
** Private
#+name: fish-private
#+begin_src fish
  complete -c synchro -fa 'secrets gpg mail projects personal'
#+end_src
* Bash
Note: =~/.bashrc= is sourced by fish as well.
#+begin_src bash :tangle (concat "/tmp/tangle-" (user-login-name) "/.bashrc")
  PS1='\[\e[1;36m\]\u\[\e[1;31m\]@\[\e[1;34m\]\h \[\e[1;32m\]\W \[\e[1;31m\]\$ \[\e[0;32m\]\[\e[0m\]'

  source ~/.alias
  source ~/.alias-tmp
  source ~/.alias-gui
  source ~/.alias-gui-tmp

  # Shell options
  shopt -s extglob
  shopt -s autocd
  shopt -s globstar
  unset HISTFILE

  {
  bind '"\C-p":previous-history'
  bind '"\C-k":previous-history'
  bind '"\C-n":next-history'
  bind '"\C-j":next-history'
  } 2>/dev/null

  export SHELL='/usr/bin/fish'
  export MPD_HOST="localhost"
  export MPD_PORT="6601"
#+end_src
* Aliases
There are some aliases that I want to have available in all shells. I break
them up into two groups: aliases for CLI (~~/.alias~) and aliases GUI programs
(~~/.alias-gui~). I make this distinction because my custom ~dmenu_run~ script
takes all the aliases from the latter and I can run them as normal programs.
Both files have a variant suffixed by ~-tmp~ in which I keep temporary aliases
and I do not keep them under version control.

It makes no sense to launch CLI programs from dmenu. Still, I make aliases
from ~~/.alias~ available in ~dmenu_run~. When I enter them in dmenu, it launches
a terminal and runs the aliased command.
** CLI
#+begin_src shell :tangle (concat "/tmp/tangle-" (user-login-name) "/.alias")
  alias x='startx'
  alias conf='git --git-dir=$HOME/.cfg/ --work-tree=$HOME'
  alias sconf='git --git-dir=$HOME/.secret/ --work-tree=$HOME'
  alias vifm='SHELL=fish ~/.config/vifm/scripts/vifmrun'
  alias vim='nvim'
  alias vi='command vim'
  alias snips='cd ~/.vim/snips'
  alias vidir='VISUAL=nvim command vidir'
  alias wkpd='wikicurses'
  alias cppman='PAGER=viman command cppman'
  alias aurvote='ssh aur@aur.archlinux.org vote'
  alias ...='cd ../..'
  alias l1='ls -1'
  alias src='cd ~/src'
  alias tmp='cd /tmp'
  alias stage='mkdir -p /tmp/stage-"$USER"; cd /tmp/stage-"$USER"'
  alias bin='cd ~/.local/bin'
  alias usb='cd ~/mnt/usb'

  export me='veracioux.herokuapp.com'
  export api="$me/api"
#+end_src
** GUI
#+begin_src shell :tangle (concat "/tmp/tangle-" (user-login-name) "/.alias-gui")
  alias calc='speedcrunch'
  alias screenkey='screenkey --bg-color "#99a3ff" --font-color "#1e1e1e"'
  alias VirtualBox="QT_QPA_PLATFORMTHEME=qt command VirtualBox"
  alias ff="firefox"
#+end_src
** Fish
:PROPERTIES:
:CUSTOM_ID: alias-fish
:END:
*** Aliases
#+begin_src fish
  alias src_fish  'source ~/.config/fish/config.fish'
  alias term      'term & disown'
  alias alpine    'docker run -it --rm --name alpine alpine'
  alias debian    'docker run -it --name debian debian:bookworm-slim'

  function dragon; dragon-drag-and-drop $argv & disown; end
  function vrg --wraps rg; vim (rg -l $argv); end
  function erg --wraps rg; myemacs -c (rg -l $argv); end
#+end_src
*** Abbreviations
#+begin_src fish
  # Safety precautions
  abbr -g rm 'rm -i'
  abbr -g mv 'mv -i'

  # Error correction
  abbr -g claer 'clear'
  abbr -g pas   'pass'

  # Pacman commands
  abbr -g p     'pacman'
  abbr -g pq    'pacman -Q'
  abbr -g pqq   'pacman -Qq'
  abbr -g pqi   'pacman -Qi'
  abbr -g pql   'pacman -Ql'
  abbr -g pqm   'pacman -Qm'
  abbr -g pqe   'pacman -Qe'
  abbr -g pqo   'pacman -Qo'
  abbr -g pqs   'pacman -Qs'
  abbr -g psi   'pacman -Si'
  abbr -g pss   'pacman -Ss'
  abbr -g pqdtq 'pacman -Qdtq'
  abbr -g sp    'sudo pacman'
  abbr -g sps   'sudo pacman -S'
  abbr -g spr   'sudo pacman -R'
  abbr -g sprq  'sudo pacman -R (pacman -Qdtq)'

  # Systemd
  abbr -g ctl       'sudo systemctl'
  abbr -g start     'sudo systemctl start'
  abbr -g stop      'sudo systemctl stop'
  abbr -g en        'sudo systemctl enable'
  abbr -g dis       'sudo systemctl disable'
  abbr -g sts       'systemctl status'
  abbr -g drel      'sudo systemctl daemon-reload'
  abbr -g rel       'sudo systemctl reload'
  abbr -g res       'sudo systemctl restart'
  abbr -g sus       'systemctl suspend'
  abbr -g j         'journalctl -f -u'
  #   --user versions
  abbr -g ctlu      'systemctl --user'
  abbr -g startu    'systemctl start --user'
  abbr -g stopu     'systemctl stop --user'
  abbr -g enu       'systemctl enable --user'
  abbr -g disu      'systemctl disable --user'
  abbr -g stsu      'systemctl status --user'
  abbr -g drelu     'systemctl daemon-reload --user'
  abbr -g relu      'systemctl reload --user'
  abbr -g resu      'systemctl restart  --user'
  abbr -g ju        'journalctl --user -f -u'

  # Docker
  abbr -g d    'docker'
  abbr -g db   'docker build'
  abbr -g dr   'docker run'
  abbr -g drit 'docker run -it'
  abbr -g deit 'docker exec -it'
  abbr -g drm  'docker rm -f'
  abbr -g dcl  'docker container list'
  abbr -g dc   'docker-compose'
  abbr -g dcub 'docker-compose up --build'
  abbr -g dce  'docker-compose exec'
  abbr -g dcd  'docker-compose down'

  # VirtualBox
  abbr -g vb   'vboxmanage'

  abbr -g g     'git'
  abbr -g v     'vim'
  abbr -g e     'myemacs'
  abbr -g E     'myemacs -c'
  abbr -g s     'sudo'
  abbr -g paru  'cmd-with-notify paru'
  abbr -g py    'python'
  abbr -g ipy   'ipython'
  abbr -g copy  'xsel -b'
  abbr -g paste 'xsel -b -o'
  abbr -g oct   'octave'
  abbr -g octb  'OCTAVE_BASIC=true command octave'
  abbr -g va    'vagrant'
  abbr -g u     'fusermount -u'
  abbr -g um    'sudo umount'

  abbr -g yt 'ytfzf -t -s'
  abbr -g t  'tem'
  abbr -g v  'vim (fzf)'
  abbr -g fm 'vifm'
  abbr -g fb 'facebook-cli'
  abbr -g c  'conf'
  abbr -g fl 'flameshot'

  abbr -g tb    'nc termbin.com 9999'
  abbr -g asc   'asciinema'
  abbr -g mic   'amixer set Capture toggle'
  abbr -g priv  'fish --private'
  abbr -g hk    'heroku'
  abbr -g mhc   'man http-codes'
  abbr -g rgh   'rg --hidden'

  # Pass
  abbr -g pn 'pass insert'
  abbr -g pg 'pass generate --clip'
  abbr -g pe 'pass edit'
  abbr -g pc 'pass show --clip'

  # Google cloud
  abbr -g gce 'gcloud compute'

  # Tmux
  abbr -g x   'tmux'
#+end_src
*** Variables
#+begin_src fish
  set aur 'aur@aur.archlinux.org'
#+end_src
* .profile
#+begin_src shell :tangle (concat "/tmp/tangle-" (user-login-name) "/.profile")
  export MAKEFLAGS='-j6'
  export GPG_TTY=$(tty)
  [ "$(uname)" = "Linux" ] && export QT_QPA_PLATFORMTHEME=gtk2
  export PYTHONSTARTUP=~/.startup.py
  export RUSTC_WRAPPER=sccache
  export MOZ_USE_XINPUT2=1

  export PATH=~/.local/bin:$PATH:~/.pyenv/versions/3.8.3/bin:~/mnt/vm/.tem/path:/opt/android-sdk/emulator

  mkdir -p /tmp/stage-"$USER"

  [ -f ~/.alias ]           && . ~/.alias
  [ -f ~/.alias-tmp ]       && . ~/.alias-tmp
  [ -f ~/.alias-gui ]       && . ~/.alias-gui
  [ -f ~/.alias-gui-tmp ]   && . ~/.alias-gui-tmp
  [ -f ~/.profile-private ] && . ~/.profile-private
#+end_src
* Dependencies
#+begin_src shell :tangle (concat "/tmp/dependencies-" (user-login-name) "/shells.sh")
  sudo pacman -S dash fish
#+end_src
