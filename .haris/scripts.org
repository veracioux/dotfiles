#+TITLE: Scripts
#+PROPERTY: header-args :comments headline :mkdirp yes :tangle-mode (identity #o744)

This is where my custom scripts live. That includes shell scripts, dmenu scripts,
and potentially programming language-specific scripts. One of the things I
strive for is to have the same script available in different formats. For
example, I have a dmenu script for creating a QR code, which allows me to scan
or generate a QR code with a few keystrokes. But sometimes I want to call this
script from a terminal, so I also have a =qr= command available in =~/.local/bin=.
Likewise, I have ideas to port some scripts to tridactyl (a firefox extension)
as well. Since those different versions of the same script differ only by UX, it
is useful to have all the versions defined in the same place - here.

Note: For code reusability, I use some [[* Helper code][helper code blocks]] defined at the bottom
of this document. These code blocks are utilized via =org-sbe= or via noweb references.

* Wrappers around existing commands
** =rm=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/rm")
  #!/usr/bin/env sh

  for arg in "$@"; do
      [ ! -e "$arg" ] && continue
      arg="$(realpath "$arg")"
      if echo "$arg" \
              | grep -q '^/home' && echo "$arg" \
                  | grep -qv '^/home/[^/]\+/[^/]\+'
      then
          echo "WTF: Trying to delete a home directory???"
          exit 1
      fi
  done
  /usr/bin/rm "$@"
#+end_src

** =pass=
This is a wrapper around GNU =pass=.
#+begin_src shell :tangle (haris/tangle-home ".local/bin/pass")
  #!/usr/bin/env bash

  shopt -s expand_aliases

  alias pass=/usr/bin/pass

  # Add a password read directly from stdin (without prompting to interactively
  # enter it)
  if [ "$1" = "add" ]; then
      dest=~/.password-store/"$2"
      destdir="$(dirname "$dest")"
      mkdir -p "$destdir"
      cat | gpg -e -o- -r "$(cat ~/.password-store/.gpg-id)" > "$dest".gpg
  else
      pass "$@"
  fi
#+end_src
** =dmenu=
#+NAME: dmenu
#+begin_src shell :tangle (haris/tangle-home ".local/bin/dmenu")
  #!/usr/bin/env sh

  /usr/bin/dmenu -f -i -h 25 -nb '#1e1e1e' -nf '#dddddd' -sb '#99a3ff' -sf '#1e1e1e' $@
#+end_src
** =ipython=
#+begin_src bash :tangle (haris/tangle-home ".local/bin/ipython")
  #!/usr/bin/env bash

  /usr/bin/ipython "$@" -i -- "$PYTHONSTARTUP"
#+end_src
** =gvim=
#+begin_src bash :tangle (haris/tangle-home ".local/bin/gvim")
  #!/usr/bin/env bash

  # Fake gvim which will just launch a terminal with neovim in it

  for arg in "$@"; do
      # Hacky solution that will open files in real gvim when opened by xdg-open
      if [ "$arg" = "-f" ]; then /usr/bin/gvim "$@"; exit; fi
  done

  # nvim is launched through the shell because otherwise it behaves weirdly
  # All arguments are surrounded with ''
  FISH_CMD="$(printf "%q " nvim "$@")"

  if [ ! -t 0 ]; then
      # Input is from a PIPE
      pipe_input="$(mktemp -t XXXXXXXXXXXXXXXX)"
      cat > "$pipe_input"
      FISH_CMD="cat $pipe_input | $FISH_CMD"
  fi

  alacritty --class Float,Alacritty -e fish -C "$FISH_CMD"

  if [ ! -t 0 ]; then
      # Input is from a PIPE
      rm -f "$pipe_input"
  fi
#+end_src
** =redshift=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/reshift")
  #!/usr/bin/env sh

  /usr/bin/redshift -l 43.84:18.35
#+end_src
** =firefox=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/firefox")
  #!/usr/bin/env sh

  /usr/bin/firefox $(printarg --new-tab "$@" | uniq)
#+end_src
** =picom=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/picom")
  #!/usr/bin/env sh

  /usr/bin/picom --experimental-backends
#+end_src
** =myemacs=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/myemacs")
  #!/usr/bin/env sh

  # Run emacsclient in the terminal, unless the -c option is given, which will
  # open the GUI.
  # - Also enables proper color support.
  # - Any additional arguments you provide are passed to emacsclient

  export TERM='xterm-256color'
  extra_args=''
  if printarg "$@" | grep -q -- '-c'; then
      extra_args='-n'
  else
      extra_args='-t'
  fi
  if ! printarg "$@" | grep -qE '^(-s|--socket-name)'; then
      extra_args="$extra_args --socket-name emacs"
  fi

  emacsclient --alternate-editor /usr/bin/emacs $extra_args "$@"
#+end_src
** =notify-send=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/notify-send")
  #!/usr/bin/env sh

  export DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus

  /usr/bin/notify-send "$@"
#+end_src
** =sudo=
#+NAME: sudo
#+begin_src shell :tangle (haris/tangle-home ".local/bin/sudo") :noweb yes
  #!/usr/bin/env bash

  # Sudo but with a hook that sends a notification when the prompt is shown

  tmpfile="$(mktemp -t sudo_askpass.XXXXXXXXXXXXXX)"
  cat > "$tmpfile" <<EOF
  <<sudo-askpass>>
  EOF

  chmod a+x "$tmpfile"
  SUDO_ASKPASS="$tmpfile" /usr/bin/sudo --askpass "$@"

  status="$?"

  rm -f "$tmpfile"

  exit "$status"

#+end_src
#+NAME: sudo-askpass
#+begin_src shell :tangle no
  #!/usr/bin/env bash
  eval "$(export -p)"
  notify-send "SUDO" "Please enter your password"
  echo -n "[sudo] password for $(getent passwd "$USER" | cut -d: -f1): " >&2
  stty -echo
  head -1
  echo >&2
#+end_src
** =alacritty=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/alacritty")
  #!/usr/bin/env sh

  WINIT_X11_SCALE_FACTOR=1.5 /usr/bin/alacritty "$@"
  #WINIT_X11_SCALE_FACTOR=1.5 prime-run /usr/bin/alacritty "$@"
#+end_src
* Utilities
** =abspath=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/abspath")
  #!/usr/bin/env bash

  pushd "$(dirname "$1")" >/dev/null
  echo "$PWD/$(basename "$1")"
  popd >/dev/null
#+end_src
** =chx=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/chx")
  #!/usr/bin/env sh

  chmod u+x "$@"
#+end_src
** =diffgpg=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/diffgpg")
  #!/usr/bin/env bash

  # Compare the contents of two GPG encrypted files

  diff <(gpg --decrypt --output - "$1") <(gpg --decrypt --output - "$2") "${@:3}"
#+end_src
** =fcmd=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/fcmd")
  #!/usr/bin/env bash

  type "$@" 2>/dev/null | awk '{print $3}'
  exit "${PIPESTATUS[0]}"
#+end_src
** =lscf=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/lscf")
  #!/usr/bin/env sh

  cat $(fcmd cf) | sed -n 's/\s*\(.*\)).*/\1/p'
#+end_src
** =n=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/n")
  #!/usr/bin/env sh

  # Print n of the received arguments, where n=$1

  [ "$#" = 0 ] && exit 1

  num="$1"
  shift
  printarg $(printarg "${@}" | head -"$num")
#+end_src
** =printarg=
#+begin_src shell :tangle (haris/tangle-home "local/bin/printarg")
  #!/usr/bin/env sh

  # Print commandline arguments passed to this function each on its own line
  printf "%s\n" "$@"
#+end_src
** =rmws=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/rmws")
  #!/usr/bin/env sh

  # Remove whitespace from a file (or stdin if input is from a pipe) and write the
  # output to stdout (or rewrite the file if the -i option is given)

  [ ! -t 0 ] &&\
      cat | sed 's:\s\+$::' ||\
          sed 's:\s\+$::' "$@"

#+end_src

** =adhoc=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/adhoc")
#!/usr/bin/env bash

# Create an ad-hoc file, edit it in $EDITOR and then print its path. If a '-'
# argument is given, the file contents are printed instead of its path.

destdir="/tmp/adhoc-files"
mkdir -p "$destdir"
cd "$destdir"

if [ "$#" != 0 ] && [ "$1" = "-" ]; then
    print_content=true
    files=("${@:2}")
else
    files=("$@")
fi

# Convert files to realpaths
readarray -t files < <(realpath "${files[@]}" 2>/dev/null)

if [ -z "$files" ]; then
    files=("$(mktemp "$destdir"/XXXXXXXXXXX)")
fi

term --class Float -e fish -c "nvim ${files[*]}"

if [ -n "$print_content" ]; then
    cat "${files[@]}"
else
    realpath "${files[@]}"
fi
#+end_src
** =cmd-with-notify=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/cmd-with-notify")
#!/usr/bin/env sh

if [ "$TERM" = "linux" ]; then
    "$@"
    exit
fi

"$@" && notify-send "Command $(echo $@) exited successfully." || {
    err=$?
    notify-send -u critical "Command $(echo $@) exited with error $err."
}
return $err
#+end_src
** =xrandr-toggle=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/xrandr-toggle")
#!/usr/bin/env sh

n="$(xrandr --listmonitors | head -1 | awk '{print $NF}')"

[ "$n" = 1 ] && {\
    xrandr2 --auto
    MSG='enabled'
} || {\
    xrandr2 --off
    MSG='disabled'
}
[ "$?" = 0 ] && notify-send "second monitor sucessfully $MSG" || notify-send -u "monitor operation unsuccessful"
#+end_src
** =xrandr2=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/xrandr2")
  #!/usr/bin/env sh

  # Wrapper for xrandr command with some options applied based on my current
  # monitor configuration

  xrandr --output HDMI-1-0 "$@" --pos -1920x0
#+end_src
* Applications
These are programs that are meant to be used mostly interactively. As such, they
are designed to be easily integrated into dmenu scripts.
** =cf=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/cf")
  #!/usr/bin/env sh

  # Look up a configuration file by its user-friendly alias.

  # Note: This script is statically parsed by lscf. Keep its structure intact.

  for arg in "$@"; do
      case "$arg" in
          README.org)     echo ~/README.org ;;
          private.org)    echo ~/.haris/private.org ;;
          temporary.org)  echo ~/.haris/temporary.org ;;
          scripts.org)    echo ~/.haris/scripts.org ;;
          alacritty)      echo ~/.config/alacritty/alacritty.yml ;;
          shells.org)     echo ~/.haris/shells.org ;;
          alias-tmp)      echo ~/.alias-tmp ;;
          alias-gui-tmp)  echo ~/.alias-gui-tmp ;;
          fish)           echo ~/.config/fish/config.fish ;;
          fish-private)   echo ~/.config/fish/private.fish ;;
          fish-tmp)       echo ~/.config/fish/tmp.fish ;;
          vim)            echo ~/.vimrc ;;
          vim-theme)      echo ~/.vim/colors/customtheme.vim ;;
          nvim)           echo ~/.config/nvim/init.vim ;;
          vifm)           echo ~/.config/vifm/vifmrc ;;
          vifm-theme)     echo ~/.config/vifm/colors/customtheme.vifm ;;
          git.org)        echo ~/.haris/git.org ;;
          gh)             echo ~/.config/gh/config.yml ;;
          hg)             echo ~/.hgrc ;;
          i3.org)         echo ~/.config/i3/README.org ;;
          picom)          echo ~/.config/picom.conf ;;
          dmenu)          echo ~/.local/bin/dmenu_run ;;
          firefox)        echo ~/.mozilla/firefox/haris/user.js ;;
          librewolf)      echo ~/.librewolf/haris/user.js ;;
          lw-chrome)      echo ~/.librewolf/haris/chrome/userChrome.css ;;
          tridactyl)      echo ~/.config/tridactyl/tridactylrc ;;
          schim)          echo ~/.config/schim/schim.conf ;;
          schim-volatile) echo ~/.config/schim/volatile.conf ;;
          dunst)          echo ~/.config/dunst/dunstrc ;;
          tem)            echo ~/.config/tem/config ;;
          mime)           echo ~/.config/mimeapps.list ;;
          zathura)        echo ~/.config/zathura/zathurarc ;;
          emacs)          echo ~/.haris/emacs.org ;;
          spacemacs)      echo ~/.spacemacs ;;
          cron)           echo ~/.crontab ;;
          octave)         echo ~/.octaverc ;;
          python)         echo ~/.startup.py ;;
          gtk2)           echo ~/.gtkrc-2.0.mine ;;
          gtk3)           echo ~/.config/gtk-3.0/settings.ini ;;
          gtk3-bookmarks) echo ~/.config/gtk-3.0/bookmarks ;;
          tuterm)         echo ~/.config/tuterm/config.sh ;;
          xinit)          echo ~/.xinitrc ;;
          sxhkd)          echo ~/.config/sxhkd/sxhkdrc ;;
          mpv)            echo ~/.config/mpv/mpv.conf ;;
          mpv-input)      echo ~/.config/mpv/input.conf ;;
          flameshot)      echo ~/.config/flameshot/flameshot.ini ;;
          cheat)          echo ~/.config/cheat/conf.yml ;;
          monero)         echo ~/.config/monero-project/monero-core.conf ;;
          xmrig)          echo ~/.config/xmrig.json ;;
      esac
  done
#+end_src
** =elisp=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/elisp")
  #!/usr/bin/env sh

  myemacs --eval "(ielm)" "$@"
#+end_src
** =eoctave=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/elisp")
  #!/usr/bin/env sh

  # Run octave interpreter through emacs

  myemacs --eval "(progn (run-octave) (delete-other-windows))" "$@"
#+end_src
** =epyhon=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/epython")
  #!/usr/bin/env sh

  # Run a python interpreter through emacs

  myemacs --eval "(progn (run-python) (delete-other-windows))" "$@"
#+end_src
** =eterm=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/eterm")
  #!/usr/bin/env sh

  # Run an emacs-hosted terminal via vterm

  myemacs -c --eval '(multi-vterm)' "$@"
#+end_src
** =magit=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/magit")
  #!/usr/bin/env sh

  myemacs -c --frame-parameters='(quote (name . "EmacsFloat"))' \
          --eval "(progn (cd \"$PWD\") (magit-status) (delete-other-windows))" \
          >/dev/null 2>&1 &
#+end_src
** =qr=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/qr")
  #!/usr/bin/env bash

  # Copy, show or open the argument based on its content
  copy_or_show_or_open() {
      notify-send 'QR Code:' "$@"
      echo "$1" | xsel -b
      if echo "$1" | grep -q '^https://'; then
          firefox --new-tab "$@"
      fi
  }

  if [ "$1" = 'in' ]; then
      copy_or_show_or_open "$(timeout 10s zbarcam /dev/video0 -1 | sed 's/^QR-Code://')"
  elif [ "$1" = 'screen' -o "$1" = 's' ]; then
      copy_or_show_or_open "$(zbarimg -q <(flameshot screen --raw) | sed 's/^QR-Code://')"
  else # out
      if [ -t 0 ] || [ "$TERM" = 'linux' ]; then
          input="$(xsel -b -o)"
      else
          input="$(cat)"
      fi
      echo "$input" | qrencode -s 10 -o - | feh -
  fi
#+end_src
** =rb=
# TODO: linux-only
#+begin_src shell :tangle (haris/tangle-home ".local/bin/rb")
#!/usr/bin/env bash
# One-time reboot into selected OS

set -e # Quit if any command fails

index="$(grep "menuentry '\|submenu '" /boot/grub/grub.cfg |\
  grep -v -P '\t' |\
  grep -i -n "$1" |\
  head -1 | awk -F':' '{print $1}')"

if [ -z $index ]; then
  echo "No entry found"
else
  index=$(( $index - 1 ))
  echo "Selected menuentry: $index. Proceed?"
  read response
  if [ "$response" == 'y' ]; then
    sudo grub-reboot $index >/home/haris/src/grublog 2>&1
    reboot
  fi
fi
#+end_src
** =viman=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/viman")
#!/usr/bin/env sh

# Wrapper script for vim which:
#   1. By default opens vim with a configuration for displaying man pages,
#       without loading unnecessary plugins
#   2. If the --floating option is provided, opens a popup window

[ "$1" = '--floating' ] && {
    shift
    cat > /dev/shm/viman
    alacritty --class Float,Alacritty -e fish \
        -C "cat /dev/shm/viman | nvim --cmd 'let g:haris_man = \"true\"' +Man! $*"
    rm -f /dev/shm/viman
} || {
    nvim --cmd 'let g:haris_man = "true"' +Man! "$@"
}
#+end_src
** =vimdiff=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/vimdiff")
#!/usr/bin/env sh

# Like regular vimdiff, but in nvim

nvim -d "$@"
#+end_src
** =vicc=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/vicc")
#!/usr/bin/env sh

# Find and open in vim a header file from the default include path

vim "$(echo "#include <$1>" | cpp -H 2>&1 >/dev/null | head -1 | sed 's/^. //')"
#+end_src
** =vipydoc=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/vipydoc")
#!/usr/bin/env sh

# Open alacritty with pydoc in it
# - All arguments are passed to pydoc
# - Alacritty window class tracks those defined in my i3 config

alacritty --class Float,Alacritty -e fish -C "pydoc $*" &
#+end_src
* Dmenu
** =Run=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/dmenu_run")
#!/usr/bin/env sh

# If an argument is provided, run corresponding custom dmenu script
[ -n "$1" ] && ~/.local/lib/dmenu/"$1"
# Otherwise open a generic dmenu where the user will choose what dmenu script
# or other program to run

run_script() { ~/.local/lib/dmenu/"$1"; }

extract_aliases() {
    grep -v '^\s*#' "$@" | sed "s_.* \(.*\)=\('\|\"\).*\2.*_\1_"
}

pull_desktop_apps() {
    # Print out desktop apps by reading *.desktop files and also cache them
    sed -n -e '/^Exec=/p'                       \
        /usr/share/applications/*.desktop       \
        ~/.local/share/applications/*.desktop   |
        sed 's/Exec=\(\S*\).*/\1/'              |
    while read line; do
        basename $line
    done                                        |
    sort | uniq | tee "$cache_file"
}
get_desktop_apps() {
    cache_file=~/.cache/.desktop-apps.txt
    age="$(date -d "now - $(stat -c '%Y' "$cache_file") seconds" +%s)"
    # Refresh the cache only if the file is older than a specified age (seconds)
    [ ! -f "$cache_file" -o  $age -gt 36000 ] || ! grep -q '^.'    \
        && pull_desktop_apps                        \
        || cat "$cache_file"
    find ~/.local/bin -executable -type f -printf '%f\n'
}
get_aliases() {
    extract_aliases ~/.alias ~/.alias-tmp
}
get_gui_aliases() {
    extract_aliases ~/.alias-gui ~/.alias-gui-tmp
}

aliases="$(get_aliases)"
gui_aliases="$(get_gui_aliases)"

# ┏━━━━━━━━━━━━━━━┓
# ┃ dmenu entries ┃
# ┗━━━━━━━━━━━━━━━┛
get_commands() {
    echo "Open"             # Open an URL or bookmark
    echo "Search"           # Web search
    echo "Clipboard"        # Clipboard using clipmenu
    echo "Snippets"         # Text snippets
    echo "TODO"             # Open TODO file of a project
    echo "Mail"             # View mail in browser
    echo "Windows"          # Choose windows
    echo "Pacman"           # Package management
    echo "Color"            # Pick a color
    echo "Unicode"          # Pick an icon
    echo "Kill Process"     # Kill process
    echo "Fix Wifi"         # Fix Wi-Fi drop issue on some networks
    echo "Config"           # Open documentation selection
    echo "System"           # System actions
    echo "Update cache"     # Update desktop app cache
    echo "Tem"              # Launch tem development environment
    echo "Octave"           # Launch octave in emacs
    echo "Python"           # Launch python interpreter in emacs
    echo "GPG"              # GPG addresses
    echo "OTP"              # Genreate OTP for selected service
    echo "IRC"              # Open emacs client for IRC
    echo "$aliases"
    echo "$gui_aliases"
    get_desktop_apps        # Programs extracted from *.desktop files
}

# ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
# ┃ Actions based on user's choice ┃
# ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
choice="$(get_commands | dmenu $@)"
case "$choice" in
    "")
        exit ;;
    "Open")
        run_script open ;;
    "Search")
        choice="$(echo -n '' | dmenu -p 'Search:')" && firefox -P haris "$choice"
        ;;
    "Clipboard")
        clipmenu ;;
    "Snippets")
        run_script snips ;;
    "TODO")
        run_script todo ;;
    "Mail")
        run_script mail ;;
    "Windows")
        ~/.local/lib/i3/i3-container-commander.py ;;
    "Pacman")
        run_script pacman ;;
    "Color")
        run_script color ;;
    "Unicode")
        run_script unicode ;;
    "Kill Process")
        run_script pkill ;;
    "Fix Wifi")
        fix-wifi ;;
        #nmcli networking off; sleep 6; nmcli networking on ;;
    "Config")
        run_script config ;;
    "System")
        run_script system ;;
    "Update cache")
        rm ~/.cache/.desktop-apps.txt ;;
    "Tem")
        alacritty -e fish -C 'pj tem; clear' ;;
    "Octave")
        eoctave -c ;;
    "Python")
        epython -c ;;
    "GPG")
        run_script gpg ;;
    "OTP")
        run_script otp ;;
    "IRC")
        myemacs --socket-name="irc" -c ;;
    # The rest: aliases and regular commands
    *)
        # If the command is an aliased GUI program, just run it
        for al in $gui_aliases; do
            if [ "$choice" = "$al" ]; then
                fish -C "$choice"    # Fish is the only shell that works here
                exit
            fi
        done
        # If the command is an aliased CLI program, open it in fish
        for al in $aliases; do
            if [ "$choice" = "$al" ]; then
                guirun alacritty --class Float,Alacritty -e fish -C "$choice"
                exit
            fi
        done
        # Fallback, if the entry matches none of the above, just run the command
        fish -C "cmd-with-notify $choice"
        ;;
esac
#+end_src
** =Config=
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/config")
#!/usr/bin/env python3

from subprocess import run, PIPE
import os
import os.path
import sys

# Load regular configuration entries
entries = run('lscf', stdout=PIPE, encoding='utf-8').stdout.replace('-', ' ')
# Load dmenu scripts
dmenu_scripts = os.listdir(os.path.expanduser('~/.local/lib/dmenu/'))

# ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
# ┃ Additional entries and customization ┃
# ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
entries = ' Edit...\n' +                               \
          ' ' + entries.replace('\n', '\n ') +        \
          'dmenu ' + '\n dmenu '.join(dmenu_scripts)

# Run dmenu
choice = run(['dmenu', '-l', '20',  '-p', 'Config:'],
             input=entries, encoding='utf-8', stdout=PIPE).stdout

if not choice:
    sys.exit()

# Strip decoration from the entry
choice = choice[2:-1].replace(' ', '-')

def run_command(cmd):
    run(['alacritty', '--class', 'Float,Alacritty', '-e',
         'fish', '-C', cmd])

# ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
# ┃ Actions based on user's choice ┃
# ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
if choice.startswith('dmenu-'):
    run_command('cd (dirname ' + __file__ + '); vim ' + choice.replace(
        'dmenu-',
        os.path.expanduser('~/.local/lib/dmenu/')
    ))
elif choice == 'Edit...':
    EVAL = '''
        (progn (find-file "~/.haris/scripts.org")
               (goto-char (org-find-property "CUSTOM_ID" "cf")))
    '''
    run(["myemacs-float", "--create-frame", "--eval", EVAL])
else:
    if 'emacs' in choice or choice.endswith('.el') or choice.endswith('.org'):
        run("fish -c 'ecf {}'".format(choice), shell=True)
    else:
        run_command('cdcf {0}; vicf {0}'.format(choice))
sys.exit()
#+end_src
** =Quickmenu=
#+transclude: [[file:~/.haris/private.org::dmenu-quickmenu][dmenu-quickmenu]] 
# Leave this line empty - otherwise transclusion might hoist the next section up
* System maintenance
** =texclean=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/texclean")
  #!/usr/bin/env bash

  # Array of extensions
  extarray=($(sed -e '/^#/d' -e '/^$/d' ~/templates/latex/ignored_files))

  if [ "$1" == '-r' ]; then
      shopt -s globstar
      rm -f ${extarray[*]/#/\*\*\/\*.} # **/*.extension
  else
      rm -f ${extarray[*]/#/\*.} # **/*.extension
  fi

  exit
#+end_src
** =springclean=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/springclean")
  #!/usr/bin/env sh

  docker system prune
  docker volume prune

  rm -rf ~/.local/share/Trash
  rm -rf ~/.local/share/*.xbel*

  # I think this is created by KDE plasma
  rm -rf ~/.local/share/baloo
#+end_src
** =createhome=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/springclean")
  #!/usr/bin/env sh

  # Top level home directory
  dirs=(
      src
      tmp
      repo
  )
  mkdir -p "${dirs[@]}"

  mkdir -p ~/mnt
  cd ~/mnt

  dirs=(
      cloud
      hdd
      phone
      ssd
      usb
      usb-guest
      usbs
      usbd
      usbc
      vm
  )

  mkdir -p "${dirs[@]}"

#+end_src
** =cleanhome=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/cleanhome")
  #!/usr/bin/env sh

  # Clean home of directories like Downloads, Documents, regularly created by who
  # knows.

  rmdir ~/Desktop ~/Downloads ~/Documents ~/Pictures ~/Videos ~/Music \
        ~/Templates ~/Public ~/'VirtualBox VMs' ~/mpv_slicing.log
#+end_src
** =cleantex=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/cleantex")
  #!/usr/bin/env bash

  # A script to clean tex build files

  shopt -s globstar

  rm **/*.aux **/*.log **/*.toc **/*.bbl **/*.fls **/*.idx **/*.ilg **/*.ind \
     ,**/*.nlo **/*.out **/*.synctex.gz **/*.fdb_latexmk 2>&1 | grep -v \
                                                                    'No such file or directory'
#+end_src
** =tangle=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/tangle") :noweb yes
  #!/usr/bin/env bash

  # Tangle all code blocks from the given file
  # Usage: tangle FILENAME

  tmpfile="$(mktemp -t XXXXXXXXXXX)"

  cat > "$tmpfile" <<EOF
    <<tangle-helper>>
  EOF

  cat "$tmpfile"
  echo

  emacs --script "$tmpfile"

  rm -f "$tmpfile"

  # vim: filetype=sh
#+end_src
*** Helper code that tangles
#+NAME: tangle-helper
#+begin_src emacs-lisp :results none
(require 'ob-tangle)
; (with-temp-buffer (progn (insert-file-contents "~/" nil nil nil t)))
(org-babel-tangle-file "$1")
#+end_src
** =tangle-all=
#+begin_src emacs-lisp :tangle (haris/tangle-home ".local/bin/tangle-all")
#!/usr/bin/emacs --script

; Tangle config files written in org format. Output dotfiles are saved to
; /tmp/tangle-$USER and dependency installation scripts are saved to
; /tmp/dependencies-$USER. If this script is not running in a docker container, the
; files will be deleted.

(setq tangle-home (concat "/tmp/tangle-" (user-login-name)))

(shell-command (concat "rm -rf " tangle-home))

(require 'ob-tangle)

(org-babel-tangle-file "~/README.org")
(org-babel-tangle-file "~/.shells.org")
(org-babel-tangle-file "~/.emacs.d/haris-config.org")
(org-babel-tangle-file "~/.config/i3/README.org")

(shell-command (concat "rsync -rvu " tangle-home " ~/"))

; vim: filetype=lisp
#+end_src
** TODO =bootstrap=
- Soon to be obsolete
#+begin_src shell :tangle (haris/tangle-home ".local/bin/bootstrap")
#!/usr/bin/env sh

# Clone my dotfiles repo into $HOME/.cfg, as per my usual strategy

conf() {
    git --work-tree="$HOME" --git-dir="$HOME/.cfg" "$@"
}

conf clone https://github.com/veracioux/dotfiles --bare "$HOME/.cfg"

conf remote set-url origin_ro https://github.com/veracioux/dotfiles
conf remote set-url origin git@github.com:veracioux/dotfiles
conf checkout

touch ~/.alias-tmp
touch ~/.alias-gui-tmp
touch ~/.sxhkd.tmp

touch ~/.config/fish/tmp.fish
#+end_src
* Miscellaneous
** =aurvote=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/aurvote")
  #!/usr/bin/env sh

  ssh aur@aur.archlinux.org vote "$@"
#+end_src
** TODO sxhkd
TODO: move to main README

I have three sets of bindings for =sxhkd=:
- common; publicly available in my dotfiles repo
- private; kept in a private repo and not publicly available
- temporary; ad hoc bindings, not versioned at all

I want to be able to enable/disable each of those individually. That's why I
keep each in a separate config file. And, for each I run a separate process
* Helper code
:PROPERTIES:
:header-args: :results silent
:END:
These scripts are used as snippets or noweb references within this org file.
** =find-alt-cmd(name)=
Returns the second executable with the given name, looked up in execpath.
#+NAME: find-alt-cmd
#+begin_src emacs-lisp :var name="nil" :results silent
  (let ((counter 0) (executable))
    (locate-file name exec-path nil
                 (lambda (path)
                   (if (file-executable-p path)
                       (setq counter (+ counter 1)))
                   (> counter 1))))
#+end_src

# Quick test...
#+CALL: find-alt-cmd(name="emacs")
** OS-specific code
#+NAME: on-macos
#+begin_src emacs-lisp :var text="" :var else=""
  ;; Insert text only on macOS
  (if (eq system-type 'darwin) text else)
#+end_src
#+NAME: on-linux
#+begin_src emacs-lisp :var text="" :var else=""
  ;; Insert text only on Linux
  (if (eq system-type 'darwin) text else)
#+end_src

* Local variables                                                  :noexport:
# Local Variables:
# org-confirm-babel-evaluate: nil
# End:

* Templates
** =TODO=
# #+begin_src shell :tangle (haris/tangle-home ".local/bin/.local/bin/TODO")
#
# #+end_src
