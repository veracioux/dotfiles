#+TITLE: Scripts
#+PROPERTY: header-args :comments headline :mkdirp yes :tangle-mode (identity #o744) :results silent :noweb yes

This is where my custom scripts live. That includes shell scripts, dmenu scripts,
and potentially programming language-specific scripts. One of the things I
strive for is to have the same script available in different formats. For
example, I have a dmenu script for creating a QR code, which allows me to scan
or generate a QR code with a few keystrokes. But sometimes I want to call this
script from a terminal, so I also have a =qr= command available in =~/.local/bin=.
Likewise, I have ideas to port some scripts to tridactyl (a firefox extension)
as well. Since those different versions of the same script differ only by UX, it
is useful to have all the versions defined in the same place - here.

Note: For code reusability, I use some [[* Helper code][helper code blocks]] defined at the bottom
of this document. These code blocks are utilized via =org-sbe= or via noweb references.

* Wrappers around existing commands
** =git=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/git")
  #!/usr/bin/env bash

  git() {
      alternative-command git "$@"
  }

  git_root="$(git root)"
  if [ "$git_root" = ~ ]; then
      if [ "$PWD" = ~ ] || [[ "${PWD#~/}" =~ ^\. ]]; then
          git "$@"
      else
          export GIT_CEILING_DIRECTORIES=~
          git "$@"
      fi
  else
      git "$@"
  fi
#+end_src
** =rm=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/rm")
  #!/usr/bin/env sh

  for arg in "$@"; do
      [ ! -e "$arg" ] && continue
      arg="$(realpath "$arg")"
      if echo "$arg" \
              | grep -q '^/home' && echo "$arg" \
                  | grep -qv '^/home/[^/]\+/[^/]\+'
      then
          echo "WTF: Trying to delete a home directory???"
          exit 1
      fi
  done
  /usr/bin/rm "$@"
#+end_src

** =pass=
This is a wrapper around GNU =pass=.
#+begin_src shell :tangle (haris/tangle-home ".local/bin/pass")
  #!/usr/bin/env bash

  shopt -s expand_aliases

  alias pass=/usr/bin/pass

  # Add a password read directly from stdin (without prompting to interactively
  # enter it)
  if [ "$1" = "add" ]; then
      dest=~/.password-store/"$2"
      destdir="$(dirname "$dest")"
      mkdir -p "$destdir"
      cat | gpg -e -o- -r "$(cat ~/.password-store/.gpg-id)" > "$dest".gpg
  else
      pass "$@"
  fi
#+end_src
** =dmenu=
Note: This depends on my custom build of dmenu with the height patch applied.
The PKGFILE can be found [[https://github.com/veracioux/aur][here]].
#+NAME: dmenu
#+begin_src shell :tangle (haris/tangle-home ".local/bin/dmenu")
  #!/usr/bin/env sh

  alternative-command dmenu -f -i -h 25 \
      -nb '#1e1e1e' -nf '#dddddd' -sb '#99a3ff' -sf '#1e1e1e' \
      -fn 'Ubuntu Mono-12' \
      "$@"
#+end_src
** =ipython=
#+begin_src bash :tangle (haris/tangle-home ".local/bin/ipython")
  #!/usr/bin/env bash

  /usr/bin/ipython "$@" -i -- "$PYTHONSTARTUP"
#+end_src
** =gvim=
#+begin_src bash :tangle (haris/tangle-home ".local/bin/gvim")
  #!/usr/bin/env bash

  # Fake gvim which will just launch a terminal with neovim in it

  for arg in "$@"; do
      # Hacky solution that will open files in real gvim when opened by xdg-open
      if [ "$arg" = "-f" ]; then /usr/bin/gvim "$@"; exit; fi
  done

  # nvim is launched through the shell because otherwise it behaves weirdly
  # All arguments are surrounded with ''
  FISH_CMD="$(printf "%q " nvim "$@")"

  if [ ! -t 0 ]; then
      # Input is from a PIPE
      pipe_input="$(mktemp -t XXXXXXXXXXXXXXXX)"
      cat > "$pipe_input"
      FISH_CMD="cat $pipe_input | $FISH_CMD"
  fi

  alacritty --class Alacritty,Float -e fish -C "$FISH_CMD"

  if [ ! -t 0 ]; then
      # Input is from a PIPE
      rm -f "$pipe_input"
  fi
#+end_src
** =redshift=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/redshift")
  #!/usr/bin/env sh

  /usr/bin/redshift -l 43.84:18.35
#+end_src
** =firefox=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/firefox")
  #!/usr/bin/env sh

  /usr/bin/firefox $(printarg --new-tab "$@" | uniq)
#+end_src
** =myemacs=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/myemacs")
  #!/usr/bin/env sh

  # Run emacsclient in the terminal, unless the -c option is given, which will
  # open the GUI.
  # - Also enables proper color support.
  # - Any additional arguments you provide are passed to emacsclient

  export TERM='xterm-256color'
  extra_args=''
  if printarg "$@" | grep -q -- '-c'; then
      extra_args='-n'
  else
      extra_args='-t'
  fi
  if ! printarg "$@" | grep -qE '^(-s|--socket-name)'; then
      extra_args="$extra_args --socket-name emacs"
  fi

  emacsclient --alternate-editor gvim $extra_args "$@"
#+end_src
** =myemacs-float=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/myemacs-float")
  #!/usr/bin/env sh

  myemacs -c --frame-parameters='(quote (name . "EmacsFloat"))' "$@"
#+end_src
** =notify-send=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/notify-send")
  #!/usr/bin/env sh

  export DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/<<eval-real-uid()>>/bus

  /usr/bin/notify-send "$@"
#+end_src
** =sudo=
#+NAME: sudo
#+begin_src bash :tangle (haris/tangle-home ".local/bin/sudo") :noweb yes
  #!/usr/bin/env bash

  # Sudo but with a hook that sends a notification when the prompt is shown

  if [ -z "$SUDO_ASKPASS" ]; then
      export SUDO_ASKPASS="$(mktemp)"
      chmod u+x "$SUDO_ASKPASS"
      if [ "$TERM" != "dumb" ]; then
          cat > "$SUDO_ASKPASS" <<'EOF'
  <<sudo-askpass-tty>>
  EOF
      else
          cat > "$SUDO_ASKPASS" <<'EOF'
  <<sudo-askpass-notty>>
  EOF
      fi
      trap "rm -f $SUDO_ASKPASS" EXIT
  fi

  /usr/bin/sudo --askpass "$@"
#+end_src
#+NAME: sudo-askpass-tty
#+begin_src shell :tangle no
  #!/usr/bin/env bash
  id="$(notify-send "SUDO" "Please enter your password" --print-id --expire-time 0)"
  echo -n "[sudo] password for $(getent passwd "$USER" | cut -d: -f1): " >&2

  trap "dunstify --close=$id" EXIT

  stty -echo </dev/tty
  head -1 </dev/tty

  echo >&2
#+end_src
#+NAME: sudo-askpass-notty
#+begin_src bash :tangle no
  #!/usr/bin/env bash

  {
      echo SETTITLE sudo password
      echo SETDESC Enter sudo password to run command
      echo SETPROMPT Sudo password:
      echo GETPIN
      echo BYE
  } | pinentry -g 2>&1 | sed -n "/^D/ s/^D //p" | tr -d '\n'
#+end_src
** =alacritty=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/alacritty")
  #!/usr/bin/env sh

  WINIT_X11_SCALE_FACTOR=1.5 /usr/bin/alacritty "$@"
  #WINIT_X11_SCALE_FACTOR=1.5 prime-run /usr/bin/alacritty "$@"
#+end_src
** =alacritty-float=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/alacritty-float")
  #!/usr/bin/env sh

  alacritty --class Alacritty,Float "$@"
#+end_src
** =sway=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/sway")
  #!/usr/bin/env sh
  export XDG_CURRENT_DESKTOP=Sway
  /usr/bin/sway --unsupported-gpu "$@"
#+end_src
** =xlock=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/xlock")
  #!/usr/bin/env sh

  pkill gpg-agent 2>/dev/null
  /usr/bin/xlock
#+end_src
* Utilities
** =abspath=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/abspath")
  #!/usr/bin/env bash

  pushd "$(dirname "$1")" >/dev/null
  echo "$PWD/$(basename "$1")"
  popd >/dev/null
#+end_src
** =chx=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/chx")
  #!/usr/bin/env sh

  chmod u+x "$@"
#+end_src
** =diffgpg=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/diffgpg")
  #!/usr/bin/env bash

  # Compare the contents of two GPG encrypted files

  diff <(gpg --decrypt --output - "$1") <(gpg --decrypt --output - "$2") "${@:3}"
#+end_src
** =fcmd=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/fcmd")
  #!/usr/bin/env bash

  type "$@" 2>/dev/null | awk '{print $3}'
  exit "${PIPESTATUS[0]}"
#+end_src
** =lscf=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/lscf")
  #!/usr/bin/env sh

  cat $(fcmd cf) | sed -n 's/\s*\(.*\)).*/\1/p'
#+end_src
** =n=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/n")
  #!/usr/bin/env sh

  # Print n of the received arguments, where n=$1

  [ "$#" = 0 ] && exit 1

  num="$1"
  shift
  printarg $(printarg "${@}" | head -"$num")
#+end_src
** =printarg=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/printarg")
  #!/usr/bin/env sh

  # Print commandline arguments passed to this function each on its own line
  printf "%s\n" "$@"
#+end_src
** =rmws=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/rmws")
  #!/usr/bin/env sh

  # Remove whitespace from a file (or stdin if input is from a pipe) and write the
  # output to stdout (or rewrite the file if the -i option is given)

  [ ! -t 0 ] &&\
      cat | sed 's:\s\+$::' ||\
          sed 's:\s\+$::' "$@"

#+end_src

** =adhoc=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/adhoc")
#!/usr/bin/env bash

# Create an ad-hoc file, edit it in $EDITOR and then print its path. If a '-'
# argument is given, the file contents are printed instead of its path.

destdir="/tmp/adhoc-files"
mkdir -p "$destdir"
cd "$destdir"

if [ "$#" != 0 ] && [ "$1" = "-" ]; then
    print_content=true
    files=("${@:2}")
else
    files=("$@")
fi

# Convert files to realpaths
readarray -t files < <(realpath "${files[@]}" 2>/dev/null)

if [ -z "$files" ]; then
    files=("$(mktemp "$destdir"/XXXXXXXXXXX)")
fi

term --class Float -e fish -c "nvim ${files[*]}"

if [ -n "$print_content" ]; then
    cat "${files[@]}"
else
    realpath "${files[@]}"
fi
#+end_src
** =cmd-with-notify=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/cmd-with-notify")
#!/usr/bin/env sh

if [ "$TERM" = "linux" ]; then
    "$@"
    exit
fi

"$@" && notify-send "Command $* exited successfully." || {
    err=$?
    notify-send -u critical "Command $* exited with error $err."
}
return $err
#+end_src
** =xpreset=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/xpreset")
  #!/usr/bin/env sh

  [ "$#" != 1 ] && exit 1

  ln -sf .xinitrc-"$1" ~/.xinitrc
#+end_src
*** Fish completions
#+begin_src fish :tangle-mode (identity #o644) :tangle (haris/tangle-home ".config/fish/completions/xpreset.fish")
  complete -c xpreset -f -a "(pushd ~; ls .xinitrc-* | string replace .xinitrc- ''; popd)"
#+end_src
** =xrandr-toggle=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/xrandr-toggle")
#!/usr/bin/env sh

n="$(xrandr --listmonitors | head -1 | awk '{print $NF}')"

[ "$n" = 1 ] && {\
    xrandr2 --auto
    MSG='enabled'
} || {\
    xrandr2 --off
    MSG='disabled'
}
[ "$?" = 0 ] && notify-send "second monitor sucessfully $MSG" || notify-send -u "monitor operation unsuccessful"
#+end_src
** =xrandr2=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/xrandr2")
  #!/usr/bin/env sh

  # Wrapper for xrandr command with some options applied based on my current
  # monitor configuration

  xrandr --output HDMI-1-0 "$@" --pos 1920x1080
#+end_src
** =pipetest=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/pipetest") :noweb yes
  #!/usr/bin/env bash

  # Create three tmux panes:
  # - A SOURCE text file opened in vim
  # - A SCRIPT file opened in vim
  # - An output buffer that shows the results of processing SOURCE with SCRIPT
  #
  # The SOURCE is supplied to the SCRIPT via pipe, i.e. the output buffer shows
  # the results of:
  #
  # SCRIPT < SOURCE
  #
  # The output automatically updates when one of SCRIPT, SOURCE changes.
  #
  # USAGE: pipetest [SOURCE] [SCRIPT]
  #
  # If the optional arguments SCRIPT and SOURCE are given, the SCRIPT and SOURCE
  # buffers will have an initial content equal to the content of those files.

  vim_executable=vim
  if command -v nvim >/dev/null; then
      vim_executable=nvim
  fi
  temp_dir="$(mktemp -d)"

  INITIAL_SOURCE="$1"
  INITIAL_SCRIPT="$2"

  [ -z "$INITIAL_SOURCE" ] && INITIAL_SOURCE=/dev/null
  [ -z "$INITIAL_SCRIPT" ] && INITIAL_SCRIPT=/dev/null

  if [ "$#" -gt 2 ]; then
      echo "Too many arguments" >&2
      exit 1
  fi

  # Create a temporary file with content from stdin
  # Usage: create_file HANDLE <CONTENT
  # HANDLE is the name of the bash variable that will point to the file's path
  create_file() {
      local file
      file="$temp_dir/$1"
      if [ ! -t 0 ]; then
          cat > "$file"
      else
          touch "$file"
      fi

      declare -g "$1"="$file"
  }

  # Same as create_file but also marks it executable by the current user
  create_file_x() {
      create_file "$@"
      chmod u+x "${!1}"
  }

  # Create a fifo so the first and second windows can notify the third window of
  # changes
  fifo="$temp_dir/fifo"
  mkfifo "$fifo"

  # The source file (first buffer) that is being piped to SCRIPT
  create_file SOURCE < "$INITIAL_SOURCE"

  # The script file (second buffer) that will process the file and generate
  # output in the third buffer
  create_file_x SCRIPT < "$INITIAL_SCRIPT"

  #
  # Notifies the output terminal that some of the first two buffers have changed.
  #
  create_file_x on_change <<EOF
  <<pipetest_on_change>>
  EOF

  #
  # Supplementary vimrc file that is loaded by each vim session started from this
  # program.
  #
  create_file vimrc <<EOF
  <<pipetest_vimrc>>
  EOF

  #
  # Vim wrapper that loads our supplementary vimrc file.
  #
  create_file_x custom_vim <<EOF
  <<pipetest_custom_vim>>
  EOF

  #
  # Output script - script that is run in the third buffer that shows the output
  # of the user SCRIPT when applied to the SOURCE file.
  #
  create_file_x output_script <<EOF
  <<pipetest_output_script>>
  EOF

  #
  # Main script that launches tmux and everything.
  #
  create_file_x main_script <<EOF
  <<pipetest_main_script>>
  EOF

  tmux new "$main_script"

  #
  # Print the resulting script
  #
  cat "$SCRIPT"

  #
  # Remove created temporary directory
  #
  rm -rf "$temp_dir"
#+end_src
*** Helper scripts
These scripts are embedded into the =pipetest= script as heredocs, but we define
them as code blocks here for better readability.
**** =on_change=
#+NAME: pipetest_on_change
#+begin_src shell
  #!/usr/bin/env sh

  echo > "$fifo"
#+end_src
**** =vimrc=
#+NAME: pipetest_vimrc
#+begin_src text
  " On write run the on_change script
  autocmd BufWritePost * silent !$on_change
  autocmd ExitPre $SOURCE,$SCRIPT silent !tmux kill-session
#+end_src
**** =custom_vim=
#+NAME: pipetest_custom_vim
#+begin_src shell
  #!/usr/bin/env sh

  "$vim_executable" -c "source $vimrc" "\$@"
#+end_src
**** =output_script=
#+NAME: pipetest_output_script
#+begin_src shell
  #!/usr/bin/env sh

  echo "This is the output."
  echo "It will automatically refresh when either of the files change."
  echo "Press Ctrl+C here or quit any of the two vim instances to exit."

  trap "tmux kill-session" INT TERM EXIT

  while :; do
      #stty -echo
      read _ < "$fifo"
      [ "$?" != "0" ] && break
      clear
      "$SCRIPT" <"$SOURCE"
  done
#+end_src
**** =main_script=
#+NAME: pipetest_main_script
#+begin_src shell
  #!/usr/bin/env sh

  tmux split-window -h "$custom_vim" "$SCRIPT"
  tmux split-window -h sh -c 'cd "$(pwd)"; "$output_script"'
  tmux select-pane -L
  tmux select-layout even-horizontal

  "$custom_vim" "$SOURCE"
#+end_src
*** TODO consider extracting this script into its own project
** =auto-browser=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/auto-browser")
  #!/usr/bin/env bash

  browser='firefox'
  # If a firefox window is currently active, open the link in the active window
  if xprop -id "$(xdotool getactivewindow)" | grep -qi 'firefox'; then
      where='--new-tab'
  else # Otherwise open a new window
      where='--new-window'
  fi

  args="$(printf '%q ' "$@")"
  i3-msg exec "$browser $where $args"
#+end_src
*** Dependencies
#+begin_src shell :tangle (haris/tangle-deps "auto-browser.sh")
  sudo pacman -S xdotool xorg-xprop
#+end_src
** =minemacs=
The bare minimum of emacs that is required to tangle all the dotfiles.
** =alternative-command=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/alternative-command")
  #!/usr/bin/env bash

  cmd="$(which -a "$1" | uniq | sed -n 2p)"

  "$cmd" "${@:2}"
#+end_src
** =curltb=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/curltb")
  #!/usr/bin/env sh

  # Get https://termbin.com/<TERMBIN_BLOB> using curl
  # Usage: curltb TERMBIN_BLOB [CURL_OPTIONS]

  curl https://termbin.com/"$1" "${@:2}"
#+end_src
** =colortest=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/colortest")
  #!/usr/bin/env bash

  # Print out all 256 colors in the terminals

  f=0
  l=256

  if [ -n "$1" ]; then
      l="$1"
  fi

  if [ -n "$2" ]; then
      f="$1"
      l="$2"
  fi

  (x=`tput op` y=`printf %40s`;for i in $(seq "$f" "$l");do o=00$i;echo -e ${o:${#o}-3:3} \
    `tput setaf $i;tput setab $i`${y// /=}$x;done)
#+end_src
** =myemacs-load=
Wrapper to [[*=myemacs=][myemacs]] that will load its first argument instead of opening it. The
remaining args simply passed to myemacs as usual. The main use for this is as a
shebang for elisp scripts.
*NOTE:* It must be implemented in such a convoluted way as a shell script, because
process management in emacs is shit.
#+NAME: myemacs-load
#+begin_src bash :tangle (haris/tangle-home ".local/bin/myemacs-load") :eval no
  #!/usr/bin/env bash

  tmpfile="$(mktemp)"
  cat >"$tmpfile" <<'EOF'
    <<stringify-arg-to-eval-option>>
  EOF

  arg="$(emacs --batch --load "$tmpfile" "$(realpath "$1")" "${@:2}" 2>&1)"
  myemacs --no-wait --eval "$arg"

  rm -f "$tmpfile"
#+end_src
#+NAME: stringify-arg-to-eval-option
#+begin_src elisp :tangle no
  (let* ((file (car argv))
         (code `(progn
                  (defvar argv)
                  (defvar process-environment)
                  (defvar default-directory)
                  (let ((argv (list ,@(cdr argv)))
                        (process-environment (list ,@process-environment))
                        (default-directory ,default-directory))
                    (load ,file)))))
    (prin1 code))
#+end_src
#+CALL: stringify-arg-to-eval-option[:var argv='("a" "b")]()
* Applications
These are programs that are meant to be used mostly interactively. As such, they
are designed to be easily integrated into dmenu scripts.
** =cf=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/cf")
  #!/usr/bin/env sh

  # Look up a configuration file by its user-friendly alias.

  # Note: This script is statically parsed by lscf. Keep its structure intact.

  for arg in "$@"; do
      case "$arg" in
          README.org)     echo ~/.haris/README.org ;;
          private.org)    echo ~/.haris/private/README.org ;;
          temporary.org)  echo ~/.haris/temporary.org ;;
          scripts.org)    echo ~/.haris/scripts.org ;;
          shells.org)     echo ~/.haris/shells.org ;;
          wm.org)         echo ~/.haris/wm.org ;;
          vcs.org)        echo ~/.haris/vcs.org ;;
          vim.org)        echo ~/.haris/vim.org ;;
          browser.org)    echo ~/.haris/browser.org ;;
          gui.org)        echo ~/.haris/gui.org ;;
          misc.org)       echo ~/.haris/misc.org ;;
          terminal.org)   echo ~/.haris/terminal.org ;;
          repl.org)       echo ~/.haris/repl.org ;;
          bootstrap.org)  echo ~/.haris/bootstrap/README.org ;;
          alacritty)      echo ~/.haris/terminal.org ;;
          alias-tmp)      echo ~/.alias-tmp ;;
          alias-gui-tmp)  echo ~/.alias-gui-tmp ;;
          fish)           echo ~/.haris/shells.org ;;
          fish-private)   echo ~/.config/fish/private.fish ;;
          fish-tmp)       echo ~/.config/fish/tmp.fish ;;
          vifm)           echo ~/.haris/terminal.org ;;
          gh)             echo ~/.haris/vcs.org ;;
          hg)             echo ~/.haris/vcs.org ;;
          picom)          echo ~/.haris/wm.org ;;
          dunst)          echo ~/.config/dunst/dunstrc ;;
          tem)            echo ~/.haris/terminal.org ;;
          mime)           echo ~/.haris/README.org ;;
          zathura)        echo ~/.haris/gui.org ;;
          emacs)          echo ~/.haris/emacs.org ;;
          spacemacs)      echo ~/.spacemacs ;;
          cron)           echo ~/.crontab ;;
          octave)         echo ~/.octaverc ;;
          python)         echo ~/.startup.py ;;
          tuterm)         echo ~/.haris/terminal.org ;;
          xinit)          echo ~/.haris/wm.org ;;
          sxhkd)          echo ~/.haris/wm.org ;;
          mpv)            echo ~/.haris/gui.org ;;
          flameshot)      echo ~/.haris/gui.org ;;
          cheat)          echo ~/.haris/terminal.org ;;
          monero)         echo ~/.config/monero-project/monero-core.conf ;;
          xmrig)          echo ~/.config/xmrig.json ;;
          tmux)           echo ~/.tmux.conf ;;
      esac
  done
#+end_src
** =elisp=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/elisp")
  #!/usr/bin/env sh

  # Run an elisp interpreter through emacs
  create_frame="$([ "$TERM" = "dumb" ] && echo --create-frame || echo '')"
  myemacs $create_frame --eval "(ielm)" "$@"
#+end_src
** =eoctave=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/eoctave")
  #!/usr/bin/env sh

  # Run octave interpreter through emacs

  create_frame="$([ "$TERM" = "dumb" ] && echo --create-frame || echo '')"
  myemacs $create_frame --eval "(progn (run-octave) (delete-other-windows))" "$@"
#+end_src
** =epython=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/epython")
  #!/usr/bin/env sh

  # Run a python interpreter through emacs

  create_frame="$([ "$TERM" = "dumb" ] && echo --create-frame || echo '')"
  myemacs $create_frame --eval "(progn (call-interactively 'run-python) (delete-other-windows))" "$@"
#+end_src
** =eterm=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/eterm")
  #!/usr/bin/env sh

  # Run an emacs-hosted terminal via vterm

  myemacs --create-frame --eval '(multi-vterm)' "$@"
#+end_src
** =eman=
#+NAME: eman
#+HEADER: :shebang "#!/usr/bin/env myemacs-load"
#+begin_src elisp :tangle (haris/tangle-home ".local/bin/eman")
  (with-selected-frame (make-frame `((name . "EmacsFloat")
                                     (display . ,(getenv "DISPLAY"))))
    (let ((Man-notify-method 'bully))
      (if argv
          (man (car argv))
        (call-interactively 'man))))
#+end_src
** =erc=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/erc") :noweb yes
  #!/usr/bin/env sh

  # Open emacs and run ERC in it

  create_frame="$([ "$TERM" = "dumb" ] && echo --create-frame || echo '')"
  myemacs --socket-name="irc" $create_frame \
          --eval "(unless erc-server-connected (call-interactively 'erc-tls))"
#+end_src
** =edocker=
#+HEADER: :shebang "#!/usr/bin/env myemacs-load"
#+begin_src elisp :tangle (haris/tangle-home ".local/bin/edocker")
    (with-selected-frame (make-frame `((name . "EmacsFloat")
                                       (display . ,(getenv "DISPLAY"))))
      (spacemacs/switch-to-scratch-buffer)
      (run-with-timer 0.3 nil 'docker))
#+end_src
** =magit=
#+HEADER: :shebang "#!/usr/bin/env myemacs-load"
#+begin_src elisp :tangle (haris/tangle-home ".local/bin/magit")
  (let ((dir default-directory))
    (with-selected-frame (make-frame `((name . "EmacsFloat")
                                       (display . ,(getenv "DISPLAY"))))
      (magit-status dir)))
#+end_src
** =qr=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/qr")
  #!/usr/bin/env bash

  # Copy, show or open the argument based on its content
  copy_or_show_or_open() {
      notify-send 'QR Code:' "$@"
      echo "$1" | xsel -b
      if echo "$1" | grep -q '^https://'; then
          firefox --new-tab "$@"
      fi
  }

  if [ "$1" = 'in' ]; then
      copy_or_show_or_open "$(timeout 20s zbarcam /dev/video0 -1 | sed 's/^QR-Code://')"
  elif [ "$1" = 'screen' -o "$1" = 's' ]; then
      copy_or_show_or_open "$(zbarimg -q <(flameshot screen --raw) | sed 's/^QR-Code://')"
  else # out
      if [ -t 0 ] || [ "$TERM" = 'linux' ]; then
          input="$(xsel -b -o)"
      else
          input="$(cat)"
      fi
      echo "$input" | qrencode -s 10 -o - | feh -
  fi
#+end_src
*** Dependencies
#+begin_src shell :tangle (haris/tangle-deps "qr.sh")
  sudo pacman -S zbar qrencode
#+end_src
** =rb=
# TODO: linux-only
#+begin_src shell :tangle (haris/tangle-home ".local/bin/rb")
#!/usr/bin/env bash
# One-time reboot into selected OS

set -e # Quit if any command fails

index="$(grep "menuentry '\|submenu '" /boot/grub/grub.cfg |\
  grep -v -P '\t' |\
  grep -i -n "$1" |\
  head -1 | awk -F':' '{print $1}')"

if [ -z $index ]; then
  echo "No entry found"
else
  index=$(( $index - 1 ))
  echo "Selected menuentry: $index. Proceed?"
  read response
  if [ "$response" == 'y' ]; then
    sudo grub-reboot $index >/home/haris/src/grublog 2>&1
    reboot
  fi
fi
#+end_src
** =viman=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/viman")
#!/usr/bin/env sh

# Wrapper script for vim which:
#   1. By default opens vim with a configuration for displaying man pages,
#       without loading unnecessary plugins
#   2. If the --floating option is provided, opens a popup window

[ "$1" = '--floating' ] && {
    shift
    cat > /dev/shm/viman
    alacritty --class Alacritty,Float -e fish \
        -C "cat /dev/shm/viman | nvim --cmd 'let g:haris_man = \"true\"' +Man! $*"
    rm -f /dev/shm/viman
} || {
    nvim --cmd 'let g:haris_man = "true"' +Man! "$@"
}
#+end_src
** =vimdiff=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/vimdiff")
#!/usr/bin/env sh

# Like regular vimdiff, but in nvim

nvim -d "$@"
#+end_src
** =vicc=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/vicc")
#!/usr/bin/env sh

# Find and open in vim a header file from the default include path

vim "$(echo "#include <$1>" | cpp -H 2>&1 >/dev/null | head -1 | sed 's/^. //')"
#+end_src
** =vipydoc=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/vipydoc")
#!/usr/bin/env sh

# Open alacritty with pydoc in it
# - All arguments are passed to pydoc
# - Alacritty window class tracks those defined in my i3 config

alacritty --class Alacritty,Float -e fish -C "pydoc $*" &
#+end_src
** =rgf=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/rgf")
  #!/usr/bin/env sh

  # Run rg and fzf to search through file contents and jump to a file

  where="$1"
  [ -z "$where" ] && where='.'

  rg --column --line-number --no-heading --color=always --smart-case . | fzf --ansi
#+end_src
** =otp=
#+begin_src python :tangle (haris/tangle-home ".local/bin/otp")
  #!/usr/bin/env python3
  import shlex
  import subprocess

  import dryparse
  from dryparse.objects import Option
  import sys
  from urllib.parse import urlparse, parse_qs

  @dryparse.command
  def otp(name: str, *, new: bool = False, extract: Option("-x", "--extract", bool) = False):
      """Use and manage one-time passwords.

      :param name: name of the OTP
      :param new: store a new OTP instead of printing an existing one
      :param extract: Extract the secret from the URL given as argument
      """
      extract: bool

      def run(*args, **kwargs):
          return subprocess.run(*args, shell=True, encoding="utf-8", **kwargs)

      if new and extract:
          print("--new and --extract can't be used together", file=sys.stderr)
          sys.exit(1)

      if new:
          p = run(f"pass insert {name}/otp-secret")
          sys.exit(p.returncode)
      elif extract:
          query = parse_qs(urlparse(name).query)
          print(query["secret"][-1])
          return


      otp_secret = run(
          f"pass show {name}/otp-secret", stdout=subprocess.PIPE
      ).stdout.strip()

      p = run(f"oathtool --totp --base32 {shlex.quote(otp_secret)}")
      sys.exit(p.returncode)


  otp = dryparse.parse(otp, sys.argv)
  otp()
#+end_src
*** Dependencies
#+begin_src shell :tangle (haris/tangle-deps "otp.sh")
  sudo pip install dryparse
#+end_src
** =imount=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/imount")
  #!/usr/bin/env bash

  # List of all blocks
  listing="$(lsblk --list -o NAME,LABEL)"

  # ... with header removed
  items="$(echo "$listing" | tail -n +2 | sed 's/.*/"&"/' | nl --number-width=1)"
  # number of lines
  lineno="$(echo "$items" | wc -l)"

  # Open file descriptor 3
  exec 3>&1
  # Show dialog and store id of selection
  id=$(eval dialog --default-item $lineno --menu '"Choose a device/partition:"' 60 50 $lineno $items 2>&1 1>&3)
  [ "$?" != 0 ] && exit 1     # Dialog exited with error
  # Select mounting directory
  mount_dir="$(dialog --fselect ~/mnt/ 60 50 2>&1 1>&3)"
  [ "$?" != 0 ] && exit 1     # Dialog exited with error

  # Clear but keep scrollback buffer
  clear -x

  if [ ! -d "$mount_dir" ]; then # Nonexisting mount directory
      read -n 1 -p\
           "The directory $mount_dir does not exist and will be created. Continue?  [y/n]: " \
           choice 1>/dev/null
      [ "$choice" != "y" ] && exit 1
      echo # newline
      mkdir "$mount_dir"
  fi

  # Get path to selected device
  device=/dev/"$(echo "$items" | sed -n ${id}p | sed 's_.*"\(\S*\)\s.*_\1_')"

  read -n 1 -p\
       "$device will be mounted at $mount_dir. Continue? (requires sudo) [y/n]: " \
       choice
  echo # newline

  [ "$choice" != "y" ] && exit 1

  # Mount the device at last
  sudo mount "$device" "$mount_dir" -o umask=002,uid=$(id -u),gid=$(id -g)

  echo -e "$mount_dir" > /tmp/imount_directory
  chmod a+rw /tmp/imount_directory
#+end_src
** =kbind=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/kbind")
  #!/usr/bin/env sh

  # Temporarily bind keys

  pkill sxhkd.tmp
  gvim -c 'set ft=sxhkd' ~/.sxhkd.tmp

  sxhkd.tmp -c ~/.sxhkd.tmp &
#+end_src
* Dmenu
** Main entrypoint (=dmenu_run=)
#+begin_src shell :tangle (haris/tangle-home ".local/bin/dmenu_run")
  #!/usr/bin/env sh

  # If an argument is provided, run corresponding custom dmenu script
  [ -n "$1" ] && ~/.local/lib/dmenu/"$1"
  # Otherwise open a generic dmenu where the user will choose what dmenu script
  # or other program to run

  export TERM=dumb

  run_script() { ~/.local/lib/dmenu/"$1"; }

  extract_aliases() {
      grep -v '^\s*#' "$@" | sed "s_.* \(.*\)=\('\|\"\).*\2.*_\1_"
  }

  pull_desktop_apps() {
      # Print out desktop apps by reading *.desktop files and also cache them
      sed -n -e '/^Exec=/p'                       \
          /usr/share/applications/*.desktop       \
          ~/.local/share/applications/*.desktop   |
          sed 's/Exec=\(\S*\).*/\1/'              |
          while read line; do
              basename $line
          done                                        |
          sort | uniq | tee "$cache_file"
  }
  get_desktop_apps() {
      cache_file=~/.cache/.desktop-apps.txt
      age="$(date -d "now - $(stat -c '%Y' "$cache_file") seconds" +%s)"
      # Refresh the cache only if the file is older than a specified age (seconds)
      [ ! -f "$cache_file" -o  $age -gt 36000 ] || ! grep -q '^.'    \
              && pull_desktop_apps                        \
                  || cat "$cache_file"
      find ~/.local/bin -executable -type f -printf '%f\n'
  }
  get_aliases() {
      extract_aliases ~/.alias ~/.alias-tmp
  }
  get_gui_aliases() {
      extract_aliases ~/.alias-gui ~/.alias-gui-tmp
  }

  aliases="$(get_aliases)"
  gui_aliases="$(get_gui_aliases)"

  # ┏━━━━━━━━━━━━━━━┓
  # ┃ dmenu entries ┃
  # ┗━━━━━━━━━━━━━━━┛
  get_commands() {
      echo "Open"             # Open an URL or bookmark
      echo "Search"           # Web search
      echo "Clipboard"        # Clipboard using clipmenu
      echo "Snippets"         # Text snippets
      echo "TODO"             # Open TODO file of a project
      echo "Mail"             # View mail in browser
      echo "Windows"          # Choose windows
      echo "Pacman"           # Package management
      echo "Color"            # Pick a color
      echo "Unicode"          # Pick an icon
      echo "Kill Process"     # Kill process
      echo "Fix Wifi"         # Fix Wi-Fi drop issue on some networks
      echo "Config"           # Open documentation selection
      echo "System"           # System actions
      echo "Services"         # Control systemd services
      echo "Update cache"     # Update desktop app cache
      echo "Tem"              # Launch tem development environment
      echo "Octave"           # Launch octave in emacs
      echo "Python"           # Launch python interpreter in emacs
      echo "GPG"              # GPG addresses
      echo "OTP"              # Generate OTP for selected service
      echo "IRC"              # Open emacs client for IRC
      echo "Quickmenu"        # Menu to quickly revisit recent activity
      echo "$aliases"
      echo "$gui_aliases"
      get_desktop_apps        # Programs extracted from *.desktop files
  }

  # ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Actions based on user's choice ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  choice="$(get_commands | dmenu $@)"
  case "$choice" in
      "")
          exit ;;
      "Open")
          run_script open ;;
      "Search")
          choice="$(echo -n '' | dmenu -p 'Search:')" && firefox -P haris "$choice"
          ;;
      "Clipboard")
          clipmenu ;;
      "Snippets")
          run_script snips ;;
      "TODO")
          run_script todo ;;
      "Mail")
          run_script mail ;;
      "Windows")
          ~/.local/lib/i3/i3-container-commander.py ;;
      "Pacman")
          run_script pacman ;;
      "Color")
          run_script color ;;
      "Unicode")
          run_script unicode ;;
      "Kill Process")
          run_script pkill ;;
      "Fix Wifi")
          fix-wifi ;;
      #nmcli networking off; sleep 6; nmcli networking on ;;
      "Config")
          run_script config ;;
      "System")
          run_script system ;;
      "Services")
          run_script services ;;
      "Update cache")
          rm ~/.cache/.desktop-apps.txt ;;
      "Tem")
          alacritty -e fish -C 'pj tem; clear' ;;
      "Octave")
          eoctave -c ;;
      "Python")
          epython -c ;;
      "GPG")
          run_script gpg ;;
      "OTP")
          run_script otp ;;
      "IRC")
          myemacs --socket-name="irc" -c ;;
      "Quickmenu")
          run_script quickmenu ;;
      # The rest: aliases and regular commands
      ,*)
          # If the command is an aliased GUI program, just run it
          for al in $gui_aliases; do
              if [ "$choice" = "$al" ]; then
                  fish -C "$choice"    # Fish is the only shell that works here
                  exit
              fi
          done
          # If the command is an aliased CLI program, open it in fish
          for al in $aliases; do
              if [ "$choice" = "$al" ]; then
                  guirun alacritty --class Alacritty,Float -e fish -C "$choice"
                  exit
              fi
          done
          # Fallback, if the entry matches none of the above, just run the command
          fish -C "cmd-with-notify $choice"
          ;;
  esac
#+end_src
** Open
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/open")
  #!/usr/bin/env sh

  # Open a website in Firefox
  # Suggests bookmarks managed by buku, but you can input any URL

  edit=" Edit..."
  sync=" Sync..."

  choice="$(
      {
          echo "$edit"
          echo "$sync"
          unbuffer buku -p --format 30 | grep -v '^$'
      } | dmenu -p 'Open:'
  )"

  [ -z "$choice" ] && exit

  if [ "$choice" = "$edit" ]; then
      # Open this file for editing
      gvim "$0"
  elif [ "$choice" = "$sync" ]; then
      alacritty --class Alacritty,Float -e fish -C "
          echo -e \"--- Importing bookmarks from Firefox ---\nDefault is: n y y \";
          buku --import ~/.mozilla/firefox/haris/bookmarks.html"
  else
      # Try to open it as a bookmark in firefox
      url="$(buku --sreg "^$choice\$" -n 1 --format 10 | grep -v 'waiting for input')"
      [ -z "$url" ] && url="$choice"
      # All google links shall be opened in firefox
      echo "$url" | grep -q 'google' && browser="$(echo "$browser" | sed 's_librewolf_/bin/firefox/')"
      echo "$url"
      auto-browser -P haris "$url"
  fi
#+end_src
** Snippets
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/snips")
  #!/usr/bin/env sh

  # TODO add snippets from tem

  edit=" Edit..."
  edit_snips=" Edit snips..."
  add=" Add..."

  print_options() {
      echo "$edit"
      echo "$add"
      echo "$edit_clip"
  }

  # ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Edit this - these are your entries ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  print_entries() {
      echo "$(cd ~/mail && command ls -1)"            # All my mail addresses
      cat ~/.local/snippets.txt | awk '{print $1}'    # TODO Snippets (temporary)
  }

  options="$(print_options)"
  entries="$(print_entries)"

  choice="$(echo "$options\n$entries" | dmenu )"

  [ -z "$choice" ] && exit

  if [ "$choice" = "$edit" ]; then
      gvim "$0"
  elif [ "$choice" = "$edit_snips" ]; then
      gvim ~/.local/snippets.txt
  elif [ "$choice" = "$add" ]; then
      choice="$(echo '' | dmenu)"
      [ -n "$choice" ] && echo "$choice" >> ~/.local/snippets.txt
  else
      match="$(sed -n "/^$choice\[\s\|$\]/p" ~/.local/snippets.txt | sed 's/\S*\s*//')"
      print_match() { [ -n "$match" ] && echo "$match" || echo "$choice"; }
      print_match | xsel -b
      : # TODO integrate with tem;
  fi
#+end_src
*** TODO Use something more universal
** Todo
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/todo")
  #!/usr/bin/env bash

  edit=" Edit..."
  lookup="$(
    ls ~/proj/*/TODO.org \
       ~/eo/TODO.org \
       ~/proj/drytoe/*/TODO.org \
       ~/data/personal/todos/*/TODO.org
  )"
  echo "$lookup"

  entries="$(echo "$edit"
             echo "$lookup" |
             while read p; do
                 basename "$(dirname "$p")"
             done)"

  choice="$(
      echo "$entries" | dmenu -p TODO:
  )"

  [ "$?" != 0 ] && exit 1

  if [ "$choice" = " Edit..." ]; then
      cd "$(dirname "$0")"; gvim "$0"
  else
      myemacs -c $(echo "$lookup" | grep "$choice/TODO.org")
  fi
#+end_src
** Mail
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/mail")
  #!/usr/bin/env bash

  edit=" Edit..."

  entries="$(echo "$edit"; cd ~/mail && command ls)"

  choice="$(echo "$entries" | dmenu -p mail -l $(echo "$entries" | wc -l))"

  [ -z "$choice" ] && exit

  if [ "$choice" = "$edit" ]; then
      gvim "$0"
  elif [ "${choice//*@/}" = 'gmail.com' ] || [ "${choice//*@/}" = 'etf.unsa.ba' ]; then
      auto-browser -P haris "mail.google.com/mail/?authuser=$choice"
  fi
#+end_src
** Pacman
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/pacman")
  #!/usr/bin/env sh

  install=" Install..."
  about=" About..."
  remove=" Remove..."
  manage=" Manage..."
  update=" Update..."
  keyring=" Keyring..."
  edit=" Edit..."

  print_options() {
      echo "$install"
      echo "$about"
      echo "$update"
      echo "$remove"
      echo "$manage"
      echo "$keyring"
      echo "$edit"
  }

  choice="$(print_options | dmenu -l $(print_options | wc -l))"

  case "$choice" in
      "$install")
          cache_file=~/.cache/.aur-package-list.txt
          age="$(date -d "now - $(stat -c '%Y' "$cache_file") seconds" +%s)"
          # Create cache file if it does not exist or is older than 5 hours
          if [ ! -f "$cache_file" ] || [ $age -gt 18000 ]; then
              curl -s 'https://aur.archlinux.org/packages.gz' \
                  -o - | gunzip -c > "$cache_file"
          fi
          # Pull the list of AUR packages
          list="$(cat "$cache_file")"
          # Prepend official packages to the list
          list="$(pacman -Ssq; echo "$list")"
          choice="$(echo "$list" | dmenu -l 20)"
          [ -z "$choice" ] && exit
          cmd="$(pacman -Ss "^$choice\$" >/dev/null && echo sudo pacman -S || echo paru)"
          alacritty --class Alacritty,Float -e fish -C "cmd-with-notify $cmd $choice" && exit
          ;;
      "$about")
          choice="$(echo "$(pacman -Qq)" | dmenu -p 'About:' -l 20)"
          [ -z "$choice" ] && exit
          alacritty --class Alacritty,Float -e fish -C "cmd-with-notify pacman -Qi $choice" && exit
          ;;
      "$update")
          alacritty --class Alacritty,Float -e fish -C "cmd-with-notify paru -Syu"
          ;;
      "$remove")
          choice="$(pacman -Qq | dmenu -l 20)"
          [ -z "$choice" ] && exit
          alacritty --class Alacritty,Float -e fish -C "cmd-with-notify sudo pacman -R $choice" && exit
          ;;
      "$manage")
          gvim "$(fcmd system-install)"
          ;;
      "$keyring")
          alacritty --class Alacritty,Float -e fish -C "cmd-with-notify sudo pacman -Sy archlinux-keyring && exit"
          ;;
      "$edit")
          gvim "$0"
          ;;
  esac

#+end_src
** Color
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/color")
  #!/usr/bin/env bash

  declare -A colors

  colors[',k black']='         #1e1e1e'
  colors[',r red']='           #ff5555'
  colors[',g green']='         #5ac2a8'
  colors[',y yellow']='        #f2b374'
  colors[',b blue']='          #6980fa'
  colors[',m magenta']='       #d098ff'
  colors[',c cyan']='          #8cceff' # TODO Change to something darker
  colors[',w white']='         #92aab7'
  colors['.k brblack']='      #6b746b'
  colors['.r brred']='        #ff8c8c'
  colors['.g brgreen']='      #98eb98'
  colors['.y bryellow']='     #e0d97b'
  colors['.b brblue']='       #99a3ff'
  colors['.m brmagenta']='    #f298c3'
  colors['.c brcyan']='       #a6d9ff'
  colors['.w brwhite']='      #dddddd'

  get_entries() {
      echo ' Edit...'
      printf '%s\n' "${!colors[@]}" | sort | sed 's_.*_ &_'
  }

  entries=$(get_entries)

  let n=$(echo "$entries" | wc -l)

  choice="$(echo "$entries" | dmenu -l $n -p 'Color:')"

  [ -z "$choice" ] && exit

  if [ "$choice" = ' Edit...' ]; then
      gvim "$0"
      exit
  fi

  # Remove decoration from the choice
  choice_filtered="$(echo $choice | sed 's_[^ ]* *\(.*\)_\1_')"
  # Copy the color, after removing whitespace
  echo -n "${colors["$choice_filtered"]}" | sed 's_[^ ]* *\(.*\)_\1_' | xsel -b
#+end_src
** Unicode
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/unicode")
  #!/usr/bin/env python3

  # Choose a font-awesome icon from dmenu and copy it

  from urllib.request import urlopen
  from subprocess import run, PIPE
  import os.path
  import yaml

  # ┏━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Prepare the icon list ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━┛

  cache_file = os.path.expanduser('~/.cache/font-awesome-icon-list.yml')

  # Read the yml file from cache, or download it from GitHub
  if os.path.exists(cache_file):
      text = open(cache_file).read()
  else:
      url = 'https://raw.githubusercontent.com/FortAwesome/Font-Awesome/6.x/metadata/icons.yml'
      data = urlopen(url).read()
      text = data.decode('utf-8')
      open(cache_file, 'w').write(text)

  # Read the YAML file
  data = yaml.load(text, yaml.Loader)

  # ┏━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Add custom options ┃
  # ┗━━━━━━━━━━━━━━━━━━━━┛
  top_entries =   [
      ' Edit...',
      ' FontAwesome...',
      ' From code...',
      ' Get code...',
  ]

  char_entries = []
  # Create a (decorated) list of entries
  for key in data.keys():
      unicode = int(data[key]['unicode'], base=16)
      char_entries.append(chr(unicode) + ' ' + key)

  def add_custom(char):
      global char_entries
      char_entries.append(char + ' [custom]')

  # ┏━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Add custom characters ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━┛
  add_custom('├ |-')
  add_custom('└ |_')
  add_custom('─ --')
  add_custom('┃┗━┛┏━┓ ||')
  add_custom('š .sh')
  add_custom('ć .ch meko')
  add_custom('č .ch tvrdo')
  add_custom('đ .dj')
  add_custom('ž .zj')

  # Form entry lists as multi-line strings
  char_entries = '\n'.join(char_entries)
  # Add options and character entries together
  top_entries  = '\n'.join(top_entries) + '\n' + char_entries

  # Run dmenu and get user choice
  p = run(['dmenu'], stdout=PIPE, input=top_entries, encoding='utf-8')
  choice = p.stdout[:-1]

  def copy_to_clipboard(text):
      run(['xsel', '-b'], input=text, encoding='utf-8')

  # ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Actions based on user's choice ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  if choice[2:] == 'Edit...': # Open this file for editing
     run(['alacritty', '--class', 'Alacritty,Float', '-e', 'fish', '-C',
           'cd (dirname ' + __file__ + '); vim -c "norm 45z." ' + __file__])
  elif choice[2:] == 'FontAwesome...':
      run(['firefox', 'https://fontawesome.com/search'])
  elif choice[2:] == 'From code...':
      p = run(['dmenu', '-p', 'Code:'], stdout=PIPE, input=char_entries, encoding='utf-8')
      open('/home/haris/src/testlog', 'w').write(choice)
      code = p.stdout[:-1]
      if choice:
          copy_to_clipboard(chr(int(code, base=16)))
  elif choice[2:] == 'Get code...':
      p = run(['dmenu', '-p', 'Character:'], stdout=PIPE, input=char_entries, encoding='utf-8')
      choice = p.stdout[:-1]
      if choice:
          copy_to_clipboard(str(ord(choice[0])))
  elif choice:
      copy_to_clipboard(choice.split(' ')[0])
#+end_src
** Kill Process
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/pkill")
  #!/usr/bin/env sh

  choice="$(ps -A -o comm --no-headers | dmenu)"

  [ -z "$choice" ] && exit

  process="$choice"

  choice="$(echo " No\n Yes, kill $process" | dmenu -p 'Sure?' -l 2)"

  [ "$choice" = " Yes, kill $process" ] && pkill "$process"
#+end_src
** Config
#+begin_src python :tangle (haris/tangle-home ".local/lib/dmenu/config")
  #!/usr/bin/env python3

  from subprocess import run, PIPE
  import os
  import os.path
  import sys

  # Load regular configuration entries
  entries = run('lscf', stdout=PIPE, encoding='utf-8').stdout.replace('-', ' ')
  # Load dmenu scripts
  dmenu_scripts = os.listdir(os.path.expanduser('~/.local/lib/dmenu/'))

  # ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Additional entries and customization ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  entries = ' Edit...\n' +                               \
            ' ' + entries.replace('\n', '\n ') +        \
            'dmenu ' + '\n dmenu '.join(dmenu_scripts)

  # Run dmenu
  choice = run(['dmenu', '-l', '20',  '-p', 'Config:'],
               input=entries, encoding='utf-8', stdout=PIPE).stdout

  if not choice:
      sys.exit()

  # Strip decoration from the entry
  choice = choice[2:-1].replace(' ', '-')

  def run_command(cmd):
      run(['alacritty', '--class', 'Alacritty,Float', '-e',
           'fish', '-C', cmd])

  # ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Actions based on user's choice ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  if choice.startswith('dmenu-'):
      submenu = choice.replace("dmenu-", "")
      submenu = submenu[0].upper() + submenu[1:]
      run(["notify-send", submenu])
      EVAL = fr'''
          (progn (find-file "~/.haris/scripts.org")
                 (call-interactively (swiper "\\*\\* {submenu}")))
      '''
      run(["myemacs-float", "--eval", EVAL])
  elif choice == 'Edit...':
      EVAL = '''
          (progn (find-file "~/.haris/scripts.org")
                 (goto-char (org-find-property "CUSTOM_ID" "cf")))
      '''
      run(["myemacs-float", "--eval", EVAL])
  else:
      run("fish -c 'ecf {}'".format(choice), shell=True)
  sys.exit()
#+end_src
** System
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/system")
  #!/usr/bin/env sh

  choice="$(echo "Shutdown\nSuspend\nReboot..." | dmenu)"

  # No choice, bye-bye
  [ -z "$choice" ] && exit

  if [ "$choice" = "Shutdown" ]; then

      choice="$(echo " No\n Yes, shutdown" | dmenu -p 'Sure?')"
      [ "$choice" = " Yes, shutdown" ] && shutdown now

  elif [ "$choice" = "Suspend" ]; then

      systemctl suspend -i

  elif [ "$choice" = "Reboot..." ]; then

      print_entries() {
          # Extract only lines with menu entries from grub
          grep "menuentry '\|submenu '" /boot/grub/grub.cfg   |\
          # Only top-level menus are considered
          grep -v -P '\t'                                     |\
          # Take only the entry name
          sed "s_\S* '\([^']*\)'.*_\1_"                       |\
          # Add numbers
          nl -w 1 -v 0 -n rn | sed -E 's/\s+/ /g'
      }

      entries="$(print_entries)"
      choice="$(echo "$entries" | dmenu -l $(echo "$entries" | wc -l))"
      [ -z "$choice" ] && exit
      # grub-reboot should be allowed passwordless in sudo (or doas)
      sudo grub-reboot "$(echo "$choice" | cut -c 1)"
      sudo reboot
  fi
#+end_src
** Services
#+begin_src bash :tangle (haris/tangle-home ".local/lib/dmenu/services")
  #!/usr/bin/env bash

  # Unicode glyphs
  started=""
  stopped=""
  arrow=""
  restart=""
  user=""

  list() {
      systemctl "list-$1" \
                --all \
                --full \
                --plain \
                --no-pager \
                --no-legend \
                --type=service 2>&- \
                "${@:2}" \
          | cut -f1 -d' '
  }

  get_prefix() {
      if [ "$1" == "--user" ]; then \
          echo -n "$user "
      else
          echo -n "   " # NOTE: This string contains a THIN SPACE unicode character
      fi
  }

  entries() {
      local opt="$1" running_services stopped_services
      readarray -t running_services < <(list units --state=running $opt)

      # Running services
      paste -d' ' <(
          systemctl show "${running_services[@]}" \
                    $opt \
              | grep ^Restart= \
              | sed -e "s/^Restart=no$/$started $arrow $stopped/" \
                    -e "s/^Restart=.*/$started $arrow $restart/" \
                    -e "s/^/$(get_prefix $opt)/"
      ) \
            <(printf "%s\n" "${running_services[@]}")

      # Stopped services
      {
          for state in exited failed; do
              list units      --state="$state" $opt
          done
      } | sed -e "s/^/$stopped $arrow $started /" \
              -e "s/^/$(get_prefix $opt)/"

      # Other services
      if [ -z "$opt" ]; then
          comm -23 \
               <(list unit-files --state=disabled $opt | sort) \
               <(printf "%s\n" "${running_services[@]}" | sort) \
              | sed "s/^/$(get_prefix $opt)$stopped $arrow $started /"
      fi
  }
  selection="$(
      {
          entries
          entries --user
      } | dmenu -p 'Services:' -l 20
  )"

  if [ -z "$selection" ]; then
      exit 1
  fi

  service="$(echo "$selection" | grep --only-matching '\S\+$')"

  opt=''
  sudo='sudo'
  if grep -q "$user" <<<"$selection"; then
      echo here
      opt="--user"
      sudo=""
  fi

  cmd=''
  if grep -q "$started $arrow $stopped" <<<"$selection"; then
      cmd=stop
  elif grep -q "$stopped $arrow $started" <<<"$selection"; then
      cmd=start
  else
      cmd=restart
  fi

  set -e

  $sudo systemctl "$cmd" $opt "$service"

  # Notify the user
  service_name="${service%.service}"

  case "$cmd" in
      start)
          notify-send "Starting service..." "$service_name" ;;
      restart)
          notify-send "Starting service: " "$service_name" ;;
      stop)
          notify-send "Stopping service: " "$service_name" ;;
  esac
#+end_src
** GPG
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/gpg")
  #!/usr/bin/env bash

  # Get list of all public keys
  keylist=($(gpg --list-public-keys Haris | grep '^\s' | sed 's/^\s*//g'))

  entries="$(
      for key in "${keylist[@]}"; do
          # Get info for key
          keyinfo="$(gpg --list-public-keys | grep "$key" -A1)"
          # Get email of key owner
          email="$(echo "$keyinfo" | grep '<.*>' | sed 's/^.*\]//')"
          echo "$key" "$email"
      done
  )"
  let n="$(echo "$entries" | wc -l)"

  choice="$(echo "$entries" | dmenu -l $n -p 'GPG:')"

  echo "$choice" | awk '{print $1}' | xsel -b
#+end_src
** OTP
#+begin_src shell :tangle (haris/tangle-home ".local/lib/dmenu/otp")
  #!/usr/bin/env bash

  # Select an app and copy its OTP to clipboard

  cd ~

  entries="$(
      fd 'otp-secret.gpg' .password-store -x echo {//} \
          | sed 's:^\.password-store/\?::'
  )"

  choice="$(echo "$entries" | dmenu -l 10 -p 'OTP:')"

  [ -z "$choice" ] && exit 1

  otp "$choice" | xsel -b
  notify-send "OTP" "Saved to clipboard"
#+end_src
** Quickmenu
#+transclude: [[~/.haris/temporary.org::dmenu-quickmenu]]
# Leave this line empty - otherwise transclusion might hoist the next section up
** Dependencies
#+begin_src bash :tangle (haris/tangle-deps "dmenu.sh")
  # Root menu (dmenu_run)
  sudo pacman -S clipmenu
  # Open
  paru -S buku
  sudo pacman -S xdotool xorg-xprop
#+end_src
* System maintenance
** =pacman-update-mirrorlist=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/pacman-update-mirrorlist")
  #!/usr/bin/env sh

  # Update /etc/pacman.d/mirrorlist using reflector
  # (requires sudo)

  reflector --sort rate --save /etc/pacman.d/mirrorlist
#+end_src
** =texclean=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/texclean")
  #!/usr/bin/env bash

  # Array of extensions
  extarray=($(sed -e '/^#/d' -e '/^$/d' ~/templates/latex/ignored_files))

  if [ "$1" == '-r' ]; then
      shopt -s globstar
      rm -f ${extarray[*]/#/\*\*\/\*.} # **/*.extension
  else
      rm -f ${extarray[*]/#/\*.} # **/*.extension
  fi

  exit
#+end_src
** =springclean=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/springclean")
  #!/usr/bin/env sh

  docker system prune
  docker volume prune

  rm -rf ~/.local/share/Trash
  rm -rf ~/.local/share/*.xbel*

  # I think this is created by KDE plasma
  rm -rf ~/.local/share/baloo

  sudo journalctl --vacuum-size=250M
#+end_src
** =createhome=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/createhome")
  #!/usr/bin/env sh

  # Top level home directory
  dirs=(
      src
      tmp
      repo
  )
  mkdir -p "${dirs[@]}"

  mkdir -p ~/mnt
  cd ~/mnt

  dirs=(
      cloud
      hdd
      phone
      ssd
      usb
      usb-guest
      usbs
      usbd
      usbp
      vm
  )

  mkdir -p "${dirs[@]}"

#+end_src
** =cleanhome=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/cleanhome")
  #!/usr/bin/env sh

  # Clean home of directories like Downloads, Documents, regularly created by who
  # knows.

  rmdir ~/Desktop ~/Downloads ~/Documents ~/Pictures ~/Videos ~/Music \
        ~/Templates ~/Public ~/'VirtualBox VMs' ~/mpv_slicing.log
#+end_src
** =cleantex=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/cleantex")
  #!/usr/bin/env bash

  # A script to clean tex build files

  shopt -s globstar

  rm **/*.aux **/*.log **/*.toc **/*.bbl **/*.fls **/*.idx **/*.ilg **/*.ind \
     ,**/*.nlo **/*.out **/*.synctex.gz **/*.fdb_latexmk 2>&1 | grep -v \
                                                                    'No such file or directory'
#+end_src
** =tangle=
#+NAME: tangle
#+begin_src shell :tangle (haris/tangle-home ".local/bin/tangle") :noweb yes
  #!/usr/bin/env sh
  ~/.haris/bootstrap/tangle.sh "$@"
#+end_src
Because this script is needed for bootstrapping my dotfiles on a new system, I
also tangle it to a standalone destination that I also keep under version control.
#+begin_src emacs-lisp :tangle (haris/tangle-home ".haris/bootstrap/tangle.sh")
  #!/usr/bin/env -S emacs --script

  (load-file (concat (file-name-directory load-file-name) "/tangle.el"))
  (setq org-confirm-babel-evaluate nil)

  (org-babel-tangle-file (file-truename (elt argv 0)))
  ; NOTE: Although this file is kept under version control, it is tangled from
  ; ~/.haris/scripts.org, so don't modify it directly
#+end_src
** =tangle-all=
#+NAME: tangle-all
#+begin_src shell :tangle (haris/tangle-home ".local/bin/tangle-all")
  #!/usr/bin/env sh
  ~/.haris/bootstrap/tangle-all.sh "$@"
#+end_src
Because this script is needed for bootstrapping my dotfiles on a new system, I
also tangle it to a standalone destination that I also keep under version control.
#+begin_src emacs-lisp :tangle (haris/tangle-home ".haris/bootstrap/tangle-all.sh")
  #!/usr/bin/env -S emacs --script

  ;; Tangle all my dotfiles. If --dest is used, then the files are tangled to
  ;; their final destinations under $HOME, instead of the directory returned by
  ;; (haris/tangle-home). Dependency installation scripts will be saved to the
  ;; destination returned by (haris/tangle-deps) regardless.

  (setq command-switch-alist '(("--dest" . ignore)))
  (setq dest (member "--dest" command-line-args))

  (setq org-confirm-babel-evaluate nil)

  (load-file (concat (file-name-directory load-file-name) "/tangle.el"))
  (haris/tangle-all dest)

  ;; vim: filetype=lisp
  ;; -*- mode: emacs-lisp -*-
  ;; NOTE: Although this file is kept under version control, it is tangled from
  ;; ~/.haris/scripts.org, so don't modify it directly
#+end_src
* Miscellaneous
** =term=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/term")
  #!/usr/bin/env bash
  alacritty --working-directory "$PWD" "$@"
#+end_src
** TODO =mconf=
Remove after repository restructuring.
#+begin_src shell :tangle (haris/tangle-home ".local/bin/mconf")
  #!/usr/bin/env -S bash --init-file

  # Manage dotfiles using Emacs Magit

  # Because configuring Magit to support bare repositories is a bit complicated,
  # this script temporarily turns $HOME into a non-bare repository [1] and then runs
  # an artificial bash shell. By exiting this shell, you signify that you are done
  # with editing the dotfiles and the script will proceed to clean up the changes
  # made in [1].

  cd ~

  if [ -e ".git" ] && [ ! -h ".git" ]; then
      echo ".git exists and is not a symlink"
      exit 1
  fi


  ln -sf .cfg .git
  git config core.bare false

  magit

  PS1="Editing dotfiles using magit... when done press Ctrl+D for proper cleanup"

  cleanup() {
      git config core.bare true
      rm .git
  }
  trap "cleanup" EXIT

  # Prevent the user from accidently running a command/function
  stty -echo
  # Yes, this will cause a recursion, but it works anyway
  bind -x '"":"kill -SIGINT $$"'
#+end_src
** =aurvote=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/aurvote")
  #!/usr/bin/env sh

  ssh aur@aur.archlinux.org vote "$@"
#+end_src
** =handle-low-bat=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/handle-low-bat")
  #!/usr/bin/env sh

  # Suspend when battery low

  if acpi | grep -q '\s[0-9]%' && acpi | grep -q 'Discharging'; then
      ~/.haris-bin/notify-send 'Low battery' 'Suspending in 5s'
      sleep 5s
      sudo systemctl suspend -i
  fi
#+end_src
** =cronupd=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/cronupd")
  #!/usr/bin/env sh

  # TODO change to ~/.crontab
  cat ~/.haris/private/crontab | crontab -
#+end_src
** =fix-wifi=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/fix-wifi")
  #!/usr/bin/env sh
  sudo rfkill block wifi && sudo rfkill unblock wifi
#+end_src
** =guirun=
#+begin_src bash :tangle (haris/tangle-home ".local/bin/guirun")
  #!/usr/bin/env bash
  # Open a GUI window in the correct workspace
  i3-msg exec "$(printf "%q " "$@")"
#+end_src
** =snip=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/snip")
  #!/usr/bin/env bash
  nvim ~/.vim/snips/"$1".snippets
#+end_src
** sxhkd
TODO: move to main README

I have three sets of bindings for =sxhkd=:
- common; publicly available in my dotfiles repo
- private; kept in a private repo and not publicly available
- temporary; ad hoc bindings, not versioned at all

I want to be able to enable/disable each of those individually. That's why I
keep each in a separate config file. And, for each I run a separate process so I
can conveniently stop/restart each by name.
*** =sxhkd.private=
#+begin_src bash :tangle (haris/tangle-home ".local/bin/sxhkd.private")
  #!/usr/bin/env bash
  exec -a sxhkd.private sxhkd -c ~/.sxhkd.private "$@"
#+end_src
*** =sxhkd.tmp=
#+begin_src bash :tangle (haris/tangle-home ".local/bin/sxhkd.tmp")
  #!/usr/bin/env bash
  exec -a sxhkd.tmp sxhkd -c ~/.sxhkd.tmp "$@"
#+end_src
* Helper code
These scripts are used as snippets or noweb references within this org file.
** =find-alt-cmd(name)=
Returns the second executable with the given name, looked up in execpath.
#+NAME: find-alt-cmd
#+begin_src emacs-lisp :var name="nil" :results silent
  (let ((counter 0) (executable))
    (locate-file name exec-path nil
                 (lambda (path)
                   (if (file-executable-p path)
                       (setq counter (+ counter 1)))
                   (> counter 1))))
#+end_src

# Quick test...
#+CALL: find-alt-cmd(name="emacs")
** OS-specific code
#+NAME: on-macos
#+begin_src emacs-lisp :var text="" :var else=""
  ;; Insert text only on macOS
  (if (eq system-type 'darwin) text else)
#+end_src
#+NAME: on-linux
#+begin_src emacs-lisp :var text="" :var else=""
  ;; Insert text only on Linux
  (if (eq system-type 'darwin) text else)
#+end_src
** =eval-real-uid=
#+NAME: eval-real-uid
#+begin_src emacs-lisp
  (user-real-uid)
#+end_src
* Local variables                                                  :noexport:
# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
