#+TITLE: Scripts
#+PROPERTY: header-args :comments headline :mkdirp yes :tangle-mode (identity #o744)

This is where my custom scripts live. That includes shell scripts, dmenu scripts,
and potentially programming language-specific scripts. One of the things I
strive for is to have the same script available in different formats. For
example, I have a dmenu script for creating a QR code, which allows me to scan
or generate a QR code with a few keystrokes. But sometimes I want to call this
script from a terminal, so I also have a =qr= command available in =~/.local/bin=.
Likewise, I have ideas to port some scripts to tridactyl (a firefox extension)
as well. Since those different versions of the same script differ only by UX, it
is useful to have all the versions defined in the same place - here.

Note: For code reusability, I use some [[* Helper code][helper code blocks]] defined at the bottom
of this document. These code blocks are utilized via =org-sbe= or via noweb references.

* Wrappers around existing commands
** =rm=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/rm")
  #!/usr/bin/env sh

  for arg in "$@"; do
      [ ! -e "$arg" ] && continue
      arg="$(realpath "$arg")"
      if echo "$arg" \
              | grep -q '^/home' && echo "$arg" \
                  | grep -qv '^/home/[^/]\+/[^/]\+'
      then
          echo "WTF: Trying to delete a home directory???"
          exit 1
      fi
  done
  /usr/bin/rm "$@"
#+end_src

** =pass=
This is a wrapper around GNU =pass=.
#+begin_src shell :tangle (haris/tangle-home ".local/bin/pass")
  #!/usr/bin/env bash

  shopt -s expand_aliases

  alias pass=/usr/bin/pass

  # Add a password read directly from stdin (without prompting to interactively
  # enter it)
  if [ "$1" = "add" ]; then
      dest=~/.password-store/"$2"
      destdir="$(dirname "$dest")"
      mkdir -p "$destdir"
      cat | gpg -e -o- -r "$(cat ~/.password-store/.gpg-id)" > "$dest".gpg
  else
      pass "$@"
  fi
#+end_src
** =dmenu=
#+NAME: dmenu
#+begin_src shell :tangle (haris/tangle-home ".local/bin/dmenu")
  #!/usr/bin/env sh

  /usr/bin/dmenu -f -i -h 25 -nb '#1e1e1e' -nf '#dddddd' -sb '#99a3ff' -sf '#1e1e1e' $@
#+end_src
** =ipython=
#+begin_src bash :tangle (haris/tangle-home ".local/bin/ipython")
  #!/usr/bin/env bash

  /usr/bin/ipython "$@" -i -- "$PYTHONSTARTUP"
#+end_src
** =gvim=
#+begin_src bash :tangle (haris/tangle-home ".local/bin/gvim")
  #!/usr/bin/env bash

  # Fake gvim which will just launch a terminal with neovim in it

  for arg in "$@"; do
      # Hacky solution that will open files in real gvim when opened by xdg-open
      if [ "$arg" = "-f" ]; then /usr/bin/gvim "$@"; exit; fi
  done

  # nvim is launched through the shell because otherwise it behaves weirdly
  # All arguments are surrounded with ''
  FISH_CMD="$(printf "%q " nvim "$@")"

  if [ ! -t 0 ]; then
      # Input is from a PIPE
      pipe_input="$(mktemp -t XXXXXXXXXXXXXXXX)"
      cat > "$pipe_input"
      FISH_CMD="cat $pipe_input | $FISH_CMD"
  fi

  alacritty --class Float,Alacritty -e fish -C "$FISH_CMD"

  if [ ! -t 0 ]; then
      # Input is from a PIPE
      rm -f "$pipe_input"
  fi
#+end_src
** =redshift=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/reshift")
  #!/usr/bin/env sh

  /usr/bin/redshift -l 43.84:18.35
#+end_src
** =firefox=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/firefox")
  #!/usr/bin/env sh

  /usr/bin/firefox $(printarg --new-tab "$@" | uniq)
#+end_src
** =picom=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/picom")
  #!/usr/bin/env sh

  /usr/bin/picom --experimental-backends
#+end_src
** =myemacs=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/myemacs")
  #!/usr/bin/env sh

  # Run emacsclient in the terminal, unless the -c option is given, which will
  # open the GUI.
  # - Also enables proper color support.
  # - Any additional arguments you provide are passed to emacsclient

  export TERM='xterm-256color'
  extra_args=''
  if printarg "$@" | grep -q -- '-c'; then
      extra_args='-n'
  else
      extra_args='-t'
  fi
  if ! printarg "$@" | grep -qE '^(-s|--socket-name)'; then
      extra_args="$extra_args --socket-name emacs"
  fi

  emacsclient --alternate-editor /usr/bin/emacs $extra_args "$@"
#+end_src
** =notify-send=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/notify-send")
  #!/usr/bin/env sh

  export DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus

  /usr/bin/notify-send "$@"
#+end_src
** =sudo=
#+NAME: sudo
#+begin_src shell :tangle (haris/tangle-home ".local/bin/sudo") :noweb yes
  #!/usr/bin/env bash

  # Sudo but with a hook that sends a notification when the prompt is shown

  tmpfile="$(mktemp -t sudo_askpass.XXXXXXXXXXXXXX)"
  cat > "$tmpfile" <<EOF
  <<sudo-askpass>>
  EOF

  chmod a+x "$tmpfile"
  SUDO_ASKPASS="$tmpfile" /usr/bin/sudo --askpass "$@"

  status="$?"

  rm -f "$tmpfile"

  exit "$status"

#+end_src
#+NAME: sudo-askpass
#+begin_src shell :tangle (haris/tangle-home "TODO")
  #!/usr/bin/env bash
  eval "$(export -p)"
  notify-send "SUDO" "Please enter your password"
  echo -n "[sudo] password for $(getent passwd "$USER" | cut -d: -f1): " >&2
  stty -echo
  head -1
  echo >&2
#+end_src
* Utilities
** =printarg=
#+begin_src shell :tangle (haris/tangle-home "TODO")
  #!/usr/bin/env sh

  # Print commandline arguments passed to this function each on its own line
  printf "%s\n" "$@"
#+end_src
** =n=
#+begin_src shell :tangle (haris/tangle-home "TODO")
  #!/usr/bin/env sh

  # Print n of the received arguments, where n=$1

  [ "$#" = 0 ] && exit 1

  num="$1"
  shift
  printarg $(printarg "${@}" | head -"$num")
#+end_src
** =diffgpg=
#+begin_src shell :tangle (haris/tangle-home "TODO")
  #!/usr/bin/env bash

  # Compare the contents of two GPG encrypted files

  diff <(gpg --decrypt --output - "$1") <(gpg --decrypt --output - "$2") "${@:3}"
#+end_src
** =chx=
#+begin_src shell :tangle (haris/tangle-home "TODO")
  #!/usr/bin/env sh

  chmod u+x "$@"
#+end_src
** =abspath=
#+begin_src shell :tangle (haris/tangle-home "TODO")
  #!/usr/bin/env bash

  pushd "$(dirname "$1")" >/dev/null
  echo "$PWD/$(basename "$1")"
  popd >/dev/null
#+end_src
** =fcmd=
#+begin_src shell :tangle (haris/tangle-home "TODO")
  #!/usr/bin/env bash

  type "$@" 2>/dev/null | awk '{print $3}'
  exit "${PIPESTATUS[0]}"
#+end_src
** =lscf=
#+begin_src shell :tangle (haris/tangle-home "TODO")
#!/usr/bin/env sh

cat $(fcmd cf) | sed -n 's/\s*\(.*\)).*/\1/p'
#+end_src
** =rmws=
#+begin_src shell :tangle (haris/tangle-home "TODO")
#!/usr/bin/env sh

# Remove whitespace from a file (or stdin if input is from a pipe) and write the
# output to stdout (or rewrite the file if the -i option is given)

[ ! -t 0 ] &&\
    cat | sed 's:\s\+$::' ||\
    sed 's:\s\+$::' "$@"

#+end_src

* Dmenu
#+transclude: [[file:~/.haris/private.org::dmenu-quickmenu][dmenu-quickmenu]] 
* Applications
** =cf=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/cf")
  #!/usr/bin/env sh

  # Look up a configuration file by its user-friendly alias.

  # Note: This script is statically parsed by lscf. Keep its structure intact.

  for arg in "$@"; do
      case "$arg" in
          README.org)     echo ~/README.org ;;
          private.org)    echo ~/.haris/private.org ;;
          temporary.org)  echo ~/.haris/temporary.org ;;
          scripts.org)    echo ~/.haris/scripts.org ;;
          alacritty)      echo ~/.config/alacritty/alacritty.yml ;;
          shells.org)     echo ~/.haris/shells.org ;;
          alias-tmp)      echo ~/.alias-tmp ;;
          alias-gui-tmp)  echo ~/.alias-gui-tmp ;;
          fish)           echo ~/.config/fish/config.fish ;;
          fish-private)   echo ~/.config/fish/private.fish ;;
          fish-tmp)       echo ~/.config/fish/tmp.fish ;;
          vim)            echo ~/.vimrc ;;
          vim-theme)      echo ~/.vim/colors/customtheme.vim ;;
          nvim)           echo ~/.config/nvim/init.vim ;;
          vifm)           echo ~/.config/vifm/vifmrc ;;
          vifm-theme)     echo ~/.config/vifm/colors/customtheme.vifm ;;
          git)            echo ~/.gitconfig ;;
          gh)             echo ~/.config/gh/config.yml ;;
          hg)             echo ~/.hgrc ;;
          i3.org)         echo ~/.config/i3/README.org ;;
          picom)          echo ~/.config/picom.conf ;;
          dmenu)          echo ~/.local/bin/dmenu_run ;;
          firefox)        echo ~/.mozilla/firefox/haris/user.js ;;
          librewolf)      echo ~/.librewolf/haris/user.js ;;
          lw-chrome)      echo ~/.librewolf/haris/chrome/userChrome.css ;;
          tridactyl)      echo ~/.config/tridactyl/tridactylrc ;;
          schim)          echo ~/.config/schim/schim.conf ;;
          schim-volatile) echo ~/.config/schim/volatile.conf ;;
          dunst)          echo ~/.config/dunst/dunstrc ;;
          tem)            echo ~/.config/tem/config ;;
          mime)           echo ~/.config/mimeapps.list ;;
          zathura)        echo ~/.config/zathura/zathurarc ;;
          emacs)          echo ~/.haris/emacs.org ;;
          spacemacs)      echo ~/.spacemacs ;;
          cron)           echo ~/.crontab ;;
          octave)         echo ~/.octaverc ;;
          python)         echo ~/.startup.py ;;
          gtk2)           echo ~/.gtkrc-2.0.mine ;;
          gtk3)           echo ~/.config/gtk-3.0/settings.ini ;;
          gtk3-bookmarks) echo ~/.config/gtk-3.0/bookmarks ;;
          tuterm)         echo ~/.config/tuterm/config.sh ;;
          xinit)          echo ~/.xinitrc ;;
          sxhkd)          echo ~/.config/sxhkd/sxhkdrc ;;
          mpv)            echo ~/.config/mpv/mpv.conf ;;
          mpv-input)      echo ~/.config/mpv/input.conf ;;
          flameshot)      echo ~/.config/flameshot/flameshot.ini ;;
          cheat)          echo ~/.config/cheat/conf.yml ;;
          monero)         echo ~/.config/monero-project/monero-core.conf ;;
          xmrig)          echo ~/.config/xmrig.json ;;
      esac
  done
#+end_src
* Miscellaneous
** =aurvote=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/aurvote")
  #!/usr/bin/env sh

  ssh aur@aur.archlinux.org vote "$@"
#+end_src
** TODO sxhkd
TODO: move to main README

I have three sets of bindings for =sxhkd=:
- common; publicly available in my dotfiles repo
- private; kept in a private repo and not publicly available
- temporary; ad hoc bindings, not versioned at all

I want to be able to enable/disable each of those individually. That's why I
keep each in a separate config file. And, for each I run a separate process
* Helper code
:PROPERTIES:
:header-args: :results silent
:END:
These scripts are used as snippets or noweb references within this org file.
** =find-alt-cmd(name)=
Returns the second executable with the given name, looked up in execpath.
#+NAME: find-alt-cmd
#+begin_src emacs-lisp :var name="nil" :results silent
  (let ((counter 0) (executable))
    (locate-file name exec-path nil
                 (lambda (path)
                   (if (file-executable-p path)
                       (setq counter (+ counter 1)))
                   (> counter 1))))
#+end_src

# Quick test...
#+CALL: find-alt-cmd(name="emacs")
** OS-specific code
#+NAME: on-macos
#+begin_src emacs-lisp :var text="" :var else=""
  ;; Insert text only on macOS
  (if (eq system-type 'darwin) text else)
#+end_src
#+NAME: on-linux
#+begin_src emacs-lisp :var text="" :var else=""
  ;; Insert text only on Linux
  (if (eq system-type 'darwin) text else)
#+end_src

* Local variables                                                  :noexport:
# Local Variables:
# org-confirm-babel-evaluate: nil
# End:

* Templates
** =TODO=
#+begin_src shell :tangle (haris/tangle-home ".local/bin/TODO")

#+end_src
