#+TITLE: Shell Config
#+PROPERTY: header-args :mkdirp yes :results silent :noweb yes
#+PROPERTY: header-args:fish :tangle (haris/tangle-home ".config/fish/config.fish")
#+PROPERTY: header-args:fish+ :shebang "#!/usr/bin/env fish"

- *dash* as the system shell (because it's faster)
- *fish* as my interactive shell
- *bash* for some scripts because it's more convenient than dash and more POSIX compliant
  than fish
Using org-tangle, I output the configs to the files they need to be in:

- =~/.profile= is sourced by login, making everything in it available to all shells.
- =~/.bashrc= is sourced by *bash* and *fish* (using the *bass* extension).
- The files =~/.alias= and =~/.alias-gui= contain aliases that I want available in
  all shells.

Additionally, =~/.alias-tmp= and  =~/.alias-gui-tmp= are not tangled from this file.
Instead I create them manually when needed to hold temporary aliases for the
purposes of experimentation. They are not under VCS.

* Fish
Note: I keep fish aliases in [[#alias-fish][Aliases]].
#+begin_src fish
  set fish_greeting ''
  [ -z "$EMACS_VTERM_PATH" ] && fish_vi_key_bindings || fish_default_key_bindings

  # Disable path shortening
  set fish_prompt_pwd_dir_length 0

  # I'm setting HOME to prevent errors when running inside tuterm
  HOME="/home/$USER" bass source ~/.bashrc        # Load bash's config

  set -gx MANPAGER 'viman'                      # Set default pager to vim
  set -gx MANPATH  ":$__fish_data_dir/man"      # Add fish manpages to MANPATH
  set -gx MANWIDTH 80
  set -gx EDITOR 'nvim'
  set -gx VISUAL 'gvim'

  function fish_user_key_bindings               # Start bindings
#+end_src
** Behavior overrides
*** =fish_prompt=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/fish_prompt.fish")
  function fish_prompt --description 'Write out the prompt'
      set -l last_pipestatus $pipestatus
      set -l normal (set_color normal)

      # Color the prompt differently when we're root
      set -l color_cwd $fish_color_cwd
      set -l prefix
      set -l suffix '$'
      if contains -- $USER root toor
          if set -q fish_color_cwd_root
              set color_cwd $fish_color_cwd_root
          end
          set suffix '#'
      end

      # If we're running via SSH, change the host color.
      set -l color_host $fish_color_host
      if set -q SSH_TTY
          set color_host $fish_color_host_remote
      end

      set -l prompt_status (__fish_print_pipestatus " [" "]" "|" \
          (set_color brred) (set_color --bold brred) $last_pipestatus)

      # Using a timeout here prevents hang on remotely mounted filesystems
      set -l vcs_prompt (timeout 0.2 fish --no-config -c fish_vcs_prompt)
      if [ (echo "$vcs_prompt" | wc -c) -gt 15 ]
         set vcs_prompt ''
      end

      echo -n -s  (set_color --bold brblue)   "$USER" ' '                  \
                  (set_color magenta)         (prompt_pwd)        $normal  \
                  (set_color brmagenta)       "$vcs_prompt"                \
                  (set_color brmagenta)       $prompt_status               \
                  (set_color yellow)          ' ' $suffix ' '
  end
#+end_src
**** =fish_mode_prompt=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/fish_mode_prompt.fish")
  function fish_mode_prompt
      [ -n "$EMACS_VTERM_PATH" ] && return
      switch $fish_bind_mode
          case default
              set_color --bold brred
              echo '[N] '
          case insert
              # Show nothing
          case replace_one
              set_color --bold green
              echo '[r] '
          case replace
              set_color --bold blue
              echo '[R] '
          case visual
              set_color --bold magenta
              echo '[V] '
          case '*'
              set_color --bold red
              echo '?'
      end
      set_color normal
  end

#+end_src
*** =fish_right_prompt=
Sends a graphical notification when a command running in a non-visible
context finishes. This applies to commands that are:
- running in a terminal emulator that is minimized or in a different workspace
- running without a terminal that can be accessed, e.g. launched via dmenu

This applies only to graphical sessions, the linux TTY is unaffected.
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/fish_right_prompt.fish")
  function fish_right_prompt
      [ -n "$DISPLAY" ] || return

      set -l _status "$status"

      # Check if terminal window is hidden
      if xdotool search --all --onlyvisible "" 2>/dev/null | ! grep -q "$WINDOWID"
          set -l exit_message
          if [ "$_status" = 0 ]
              set exit_message "exited successfully"
          else
              set exit_message "exited with $_status"
          end
          notify-send (echo "Command "(history | head -1)"" "$exit_message")
      end
  end
#+end_src
** Bindings
#+begin_src fish
  function bind_both_modes
      bind -M default $argv
      bind -M insert $argv
  end
#+end_src
*** Quasi-vim-like key bindings
#+begin_src fish
  bind_both_modes \el forward-char
  bind_both_modes \eh backward-char
  bind_both_modes \cp up-or-search
  bind_both_modes \cn down-or-search
#+end_src
*** Fish behavior control bindings
#+begin_src fish
  bind_both_modes \er src_fish

  # The linux TTY interprets \cP as \cp, and I use the latter for history navigation
  if [ "$TERM" != "linux" ]
      bind_both_modes \cP \
      '
      echo Starting private mode...;
      set fish_private_mode true;
      commandline -f repaint
      '
  end

  # Ctrl+L to clear screen
  bind_both_modes \cl 'clear; commandline -f repaint'
#+end_src
*** Utility bindings
#+begin_src fish
  # Copy the current contents of the command line
  bind_both_modes \ec 'commandline -b | xsel -b'

  # Run the current command in bash
  bind_both_modes \eb __haris_run_in_bash

  # Prepend o in front of current command
  bind_both_modes \eo '__haris_prepend_cmdline o'

  # Prepend man in front of current command
  bind_both_modes \em '__haris_show_man'

  # Append --help to the end of the command line and submit
  bind_both_modes \eH '__haris_print_help_or_toggle'

  bind_both_modes \et term

  bind_both_modes \eg 'dragon (command ls | fzf --multi) >/dev/null 2>&1'

  bind_both_modes \ee 'VISUAL="$EDITOR" edit_command_buffer'

  bind_both_modes \ea 'commandline -i "(adhoc)"'

  bind_both_modes \eA 'commandline -i "(adhoc - | string collect)"'

  bind_both_modes \eG 'magit'
  end                                          # End fish_user_key_bindings
#+end_src
**** Helper functions
#+begin_src fish
  function __haris_run_in_bash
      set -l cmd (commandline -b)
      echo
      eval bash -c "'source ~/.bashrc; $cmd'"
      commandline -f repaint
      commandline -r ''
  end

  function __haris_prepend_cmdline
      commandline --cursor 0
      commandline --insert "$argv "
      commandline --function end-of-line
  end

  function __haris_show_man
      eman (commandline --current-process --tokenize | grep -v '^sudo$' | head -1)
  end

  function __haris_print_help_or_toggle
      if [ (commandline -o | tail -1) = "--help" ]
          commandline -r (commandline | string replace -r -- '\s*--help$' '')
          return
      end
      commandline --append " --help"
      commandline -f execute
  end


  function __haris_cmdline_editor
      commandline > /tmp/haris_cmdline.fish
      "$EDITOR" /tmp/haris_cmdline.fish
      commandline --replace (cat /tmp/haris_cmdline.fish)
  end
#+end_src
** Custom colors
#+begin_src fish
  set -U fish_color_command           brblue
  set -U fish_color_quote             brgreen
  set -U fish_color_param             brcyan
  set -U fish_color_autosuggestion    brblack
  set -U fish_color_cancel         -r red
  set -U fish_color_error             red
  set -U fish_color_comment           green
  set -U fish_color_operator          normal
  set -U fish_color_redirection       brmagenta
  set -U fish_pager_color_progress    brgreen
  set -U fish_pager_color_description green
  set -U fish_color_end               yellow
#+end_src
** Plugins
#+begin_src fish
  # pj plugin
  set -gx PROJECT_PATHS ~/proj ~/proj/drytoe

  # z.lua
  set _ZL_CMD z
  lua /usr/share/z.lua/z.lua --init fish | source
  set -gx _ZL_CD cd

  # tem
  tem fish-init

  # fzf bindings
  fzf_configure_bindings
#+end_src
*** Dependencies
Fish plugins:
#+begin_src fish :tangle (haris/tangle-home ".config/fish/fish_plugins")
  edc/bass
  oh-my-fish/plugin-pj
  PatrickF1/fzf.fish
  jorgebucaran/nvm.fish
  evanlucas/fish-kubectl-completions
#+end_src
This code block installs all system dependencies and all plugins in fish based
on the plugin list above.
#+begin_src shell :tangle (haris/tangle-deps "fish.sh")
  paru -S fish fisher
  touch ~/.config/fish/{private,tmp}.fish
  fish -c "fisher update"
  sudo pacman -S fd bat # Dependencies for fzf.fish
#+end_src
** Functions
#+begin_src fish
  # Create a new dir and cd
  function ndir;  mkdir -p "$argv"; cd "$argv"; end

  # Print first argument
  function 1; echo $argv[1]; end

  # Run z through fzf
  function a
      z -l $argv | read -z choices
      set -l count (echo "$choices" | sed '/^$/d' | wc -l)
      set dest (echo "$choices" | sed '/^$/d' | tac | fzf --select-1)

      cd (echo "$dest" | sed -E -e '/^$/d' -e 's/^\S+\s+//')
  end

  # Open a GUI app and disown
  function open; for file in $argv; o xdg-open "$file"; end; end

  # Wrapper around imount script so I can cd to the mount directory
  function imount
      command imount $argv
      cd (cat /tmp/imount_directory)
  end

  # Vim help
  function vh; vim -c ":h $argv | only"; end

  # Save the path of the argument to the clipboard
  function copypath; realpath $argv | xsel -b; end

  # When you ls, save the argument so you can quickly cd to that folder.
  # It's not fool-proof, but it works in most situations and it's safe.
  function ls
      if [ -z "$EMACS_VTERM_PATH" ]
          # In emacs vterm, lsd outputs additional whitespace which is annoying
          lsd --color=auto $argv
      else
          command ls --color=auto $argv
      end
      set -g __last_ls_arg "$argv"
  end

  # cd the last directory you have ls-ed
  function cdls
      [ -n "$__last_ls_arg" ] && cd "$__last_ls_arg"
  end
  # vim the last file you have ls-ed
  function vils
      [ -n "$__last_ls_arg" ] && vim "$__last_ls_arg"
  end

  function chbg
      set path /usr/share/backgrounds/"$argv[1]"
      feh --bg-fill "$path"
      rm ~/.wallpaper
      ln -s "$path" ~/.wallpaper
  end

  function cdcf;   set -l file (cf "$argv");   test -f "$file" && cd (dirname        "$file"); end
  function catcf;  set -l file (cf "$argv");   test -f "$file" && cat                "$file" ; end
  function vicf;   set -l file (cf "$argv");   test -e "$file" && vim                "$file" ; end
  function ecf;    set -l file (cf "$argv");   test -e "$file" && myemacs-float "$file" ; end

  function cdcmd;  set -l file (fcmd "$argv"); test -f "$file" && cd (dirname "$file"); end
  function catcmd; set -l file (fcmd "$argv"); test -f "$file" && cat         "$file" ; end
  function ecmd;   set -l file (fcmd "$argv"); test -f "$file" && myemacs     "$file" ; end
  function rmcmd;  set -l file (fcmd "$argv"); rm "$file";                              end
  function vicmd
      set -l file (fcmd "$argv");
      if [ -f "$file" ]
          vim "$file"
      else
          read -n 1 -P "Create new script? [y/N]: " choice
          if [ "$choice" = 'y' ]
              myemacs-float ~/.haris/scripts.org
          else
              echo 'Aborting...'
              return 1
          end
      end
  end

  function sconf
      set -l gitdir ~/.secret
      set -l worktree_option --work-tree="$HOME"
      if [ -e ".secret" ]
          set gitdir (pwd)/.secret
          if [ ~ != (pwd) ]
              set -le worktree_option
          end
      end

      git --git-dir="$gitdir" $worktree_option $argv
  end
#+end_src
*** =o=
#+NAME: o
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/o.fish") :eval no
  # Run a command and disown. Put it into a tmux session. Notify the user when done.
  # Persist a shell for a small time so the user can follow up on the command. If
  # the user doesn't follow up within 20 minutes, the background shell will exit
  # automatically.
  function o
      set -l argv_escaped (string escape -- $argv)
      [ -z "$__haris_tmux_linger_period" ] && set -l __haris_tmux_linger_period 20m
      tmux new -d fish --private -C "
          set __haris_tmux_linger_period $__haris_tmux_linger_period;
          set __cmdline $argv_escaped;"'
          <<o/background-task>>
      '
  end
#+end_src
Test the function by executing this code block:
#+NAME: o/test
#+begin_src fish :tangle no :cmdline --no-config
  set __haris_tmux_linger_period 3s
  <<o>>
  o sh -c 'echo Simulating long command...; sleep 3s; echo Done.; echo The terminal window should close in a few seconds'
  alacritty-float -e tmux attach
#+end_src
**** Background task and follow-up shell
Note: This code block must not contain any apostrophes!
#+NAME: o/background-task
#+HEADER: :shebang "#!/usr/bin/env fish"
#+begin_src fish :tangle no :eval no
  functions -e fish_greeting
  $__cmdline

  set __status "$status"

  set __urgency
  if [ "$__status" != 0 ]; set __urgency "--urgency=critical"; end

  # Send a notification and wait for it to close. The reason we wait for it is
  # because if the user is AFK, then the follow-up shell would exit prematurely.
  # This way, if the user has set up notiication persistence while AFK, we
  # leverage that feature.

  set _notification_id_file (mktemp)
  set _hook (string escape run-shell "sh -c \"dunstify --close=\$(cat $_notification_id_file)\" || true")
  tmux set-hook client-attached "$_hook"

  unbuffer \
      notify-send "Background task done" \
          "$__cmdline exited with code $__status" \
          --wait --print-id $__urgency \
          2>/dev/null >"$_notification_id_file"

  rm -f "$_notification_id_file"

  # Start a timeout for the shell to close if the user does not perform any
  # follow-up commands
  sh -c "sleep $__haris_tmux_linger_period; kill $fish_pid" &
  jobs --last --pid | read _timeout_pid
  disown

  function __haris_on_interaction_stop_timeout --on-event fish_preexec
      kill "$_timeout_pid"
      functions --erase __haris_on_interaction_stop_timeout
  end
#+end_src
**** Completions
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/o.fish")
  complete -c o --wraps command
#+end_src
*** =enved=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/enved.fish")
  function enved --argument envvar --description "Edit an environment variable by name"
      set tmp (mktemp /tmp/envvar-XXXXXXXXX)
      bass echo \$"$envvar" > "$tmp"
      "$EDITOR" "$tmp"
      bass export "$envvar"=(cat "$tmp")
      /usr/bin/rm -f "$tmp"
  end
#+end_src
*** =^=
#+begin_src fish
  function ^ -d "cd to the first directory in the hierarchy by specified name" -a name
      pushd "$PWD"
      while [ "$PWD" != "/" ]
          if [ (basename "$PWD") = "$name" ]
              set -l dir "$PWD"
              popd
              cd "$dir"
              return
          end
          cd ..
      end
      popd
      return 1
  end
#+end_src
**** Completions
#+begin_src fish
  complete -c ^ -a '(pwd | tr "/" "\n")' -f
#+end_src
** Completions
Function(s) that will be used by many completions.
Completions for the functions defined in [[Functions]].
#+begin_src fish
  # Return success if the command line contains no positional arguments
  function no_positional_args
      set -l -- args    (commandline -po)         # cmdline broken up into list
      set -l -- cmdline (commandline -p)          # single string
      set -l -- n       (count $args)             # number of cmdline tokens
      for i in (seq 2 $n)
          set -l arg $args[$i]
          [ -z "$arg" ] && continue               # can be caused by '--' argument

          # If the the last token is a positional argument and there is no
          # trailing space, we ignore it
          [ "$i" = "$n" ] && [ (string sub -s -1 "$cmdline") != ' ' ] && break

          if string match -rvq '^-' -- "$arg"     # doesn't start with -
              return 1
          end
      end
      # contains a '--' argument
      string match -r -- '\s--\s' "$cmdline" && return 1
      return 0
  end

  complete --command chbg --no-files --arguments="(pushd /usr/share/backgrounds/; command ls -1; popd)"
  complete --command cmd-with-notify -f -a '(complete -C(commandline -cp | sed "s:\S\+::"))'
  complete -c snip -f -a \
      "(pushd ~/.vim/snips; command ls | sed 's_\(.*\)\.snippets_\1_g'; popd)"

  # *cf and *cmd style commands
  for cmd in {,cd,vi,cat,e}cf
      complete --command $cmd --no-files -a '(lscf)'
  end
  for cmd in {f,cd,vi,cat,e, rm}cmd
      complete -c $cmd -f \
          -a '(command ls -1 $PATH 2>/dev/null | grep -v "/")'
  end
#+end_src
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/adhoc.fish")
  complete -c adhoc -f \
      -a "(complete -C'adsfadadflasdjflasdflnasdflasdu /tmp/adhoc-files/' | string replace /tmp/adhoc-files/ \"\")"
#+end_src
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/pass.fish")
  source /usr/share/fish/vendor_completions.d/pass.fish
  complete -c pass -a 'add' -n "no_positional_args"
  complete -c pass -a '(complete -C "pass show ")' -f -n '__fish_seen_subcommand_from add'
#+end_src
#+begin_src shell :tangle (haris/tangle-home ".config/fish/completions/otp.fish")
    complete -c otp -a '(fd "otp-secret.gpg" ~/.password-store -x echo {//} | sed "s:^.*/\.password-store/\?::")' -f
#+end_src
** Private
#+transclude: [[~/.haris/private/README.org::fish-private]]
#+begin_src fish
  source ~/.config/fish/private.fish
#+end_src
* Bash
Note: =~/.bashrc= is sourced by fish as well.
#+begin_src bash :tangle (haris/tangle-home ".bashrc")
  PS1='\[\e[1;36m\]\u\[\e[1;31m\]@\[\e[1;34m\]\h \[\e[1;32m\]\W \[\e[1;31m\]\$ \[\e[0;32m\]\[\e[0m\]'

  source ~/.alias
  source ~/.alias-tmp
  source ~/.alias-gui
  source ~/.alias-gui-tmp

  # Shell options
  shopt -s extglob
  shopt -s autocd
  shopt -s globstar
  unset HISTFILE

  {
  bind '"\C-p":previous-history'
  bind '"\C-k":previous-history'
  bind '"\C-n":next-history'
  bind '"\C-j":next-history'
  } 2>/dev/null

  export SHELL='fish'
  export MPD_HOST="localhost"
  export MPD_PORT="6601"
#+end_src
* Aliases
There are some aliases that I want to have available in all shells. I break
them up into two groups: aliases for CLI (~~/.alias~) and aliases GUI programs
(~~/.alias-gui~). I make this distinction because my custom ~dmenu_run~ script
takes all the aliases from the latter and I can run them as normal programs.
Both files have a variant suffixed by ~-tmp~ in which I keep temporary aliases
and I do not keep them under version control.

It makes no sense to launch CLI programs from dmenu. Still, I make aliases
from ~~/.alias~ available in ~dmenu_run~. When I enter them in dmenu, it launches
a terminal and runs the aliased command.
** CLI
#+begin_src shell :tangle (haris/tangle-home ".alias")
  alias x='startx'
  alias conf='git --git-dir=$HOME/.cfg/ --work-tree=$HOME'
  alias sconf='git --git-dir=$HOME/.secret/ --work-tree=$HOME'
  alias vim='nvim'
  alias vi='command vim'
  alias snips='cd ~/.vim/snips'
  alias vidir='VISUAL=nvim command vidir'
  alias wkpd='wikicurses'
  alias cppman='PAGER=viman command cppman'
  alias aurvote='ssh aur@aur.archlinux.org vote'
  alias ...='cd ../..'
  alias l1='ls -1'
  alias src='cd ~/src'
  alias tmp='cd /tmp'
  alias stage='mkdir -p /tmp/stage-"$USER"; cd /tmp/stage-"$USER"'
  alias bin='cd ~/.local/bin'
  alias usb='cd ~/mnt/usb'

  export me='veracioux.herokuapp.com'
  export api="$me/api"
#+end_src
** GUI
#+begin_src shell :tangle (haris/tangle-home ".alias-gui")
  alias calc='speedcrunch'
  alias screenkey='screenkey --bg-color "#99a3ff" --font-color "#1e1e1e"'
  alias VirtualBox="QT_QPA_PLATFORMTHEME=qt command VirtualBox"
  alias ff="firefox"
#+end_src
** Fish
:PROPERTIES:
:CUSTOM_ID: alias-fish
:END:
*** Aliases
#+begin_src fish
  alias src_fish  'source ~/.config/fish/config.fish'
  alias term      'term & disown'
  alias alpine    'docker run -it --rm --name alpine alpine'
  alias debian    'docker run -it --name debian debian:bookworm-slim'

  function dragon; dragon-drag-and-drop $argv & disown; end
  function vrg --wraps rg; vim (rg -l $argv); end
  function erg --wraps rg; myemacs -c (rg -l $argv); end
#+end_src
*** Abbreviations
#+begin_src fish
  # Safety precautions
  abbr -g rm 'rm -i'
  abbr -g mv 'mv -i'

  # Error correction
  abbr -g claer 'clear'
  abbr -g pas   'pass'
  abbr -g gs    'git status'

  # Pacman commands
  abbr -g p     'pacman'
  abbr -g pq    'pacman -Q'
  abbr -g pqq   'pacman -Qq'
  abbr -g pqi   'pacman -Qi'
  abbr -g pql   'pacman -Ql'
  abbr -g pqm   'pacman -Qm'
  abbr -g pqe   'pacman -Qe'
  abbr -g pqo   'pacman -Qo'
  abbr -g pqs   'pacman -Qs'
  abbr -g psi   'pacman -Si'
  abbr -g pss   'pacman -Ss'
  abbr -g pqdtq 'pacman -Qdtq'
  abbr -g sp    'sudo pacman'
  abbr -g sps   'sudo pacman -S'
  abbr -g spr   'sudo pacman -R'
  abbr -g sprq  'sudo pacman -R (pacman -Qdtq)'

  # Systemd
  abbr -g ctl       'sudo systemctl'
  abbr -g start     'sudo systemctl start'
  abbr -g stop      'sudo systemctl stop'
  abbr -g en        'sudo systemctl enable'
  abbr -g dis       'sudo systemctl disable'
  abbr -g sts       'systemctl status'
  abbr -g drel      'sudo systemctl daemon-reload'
  abbr -g rel       'sudo systemctl reload'
  abbr -g res       'sudo systemctl restart'
  abbr -g sus       'systemctl suspend'
  abbr -g j         'journalctl -f -u'
  #   --user versions
  abbr -g ctlu      'systemctl --user'
  abbr -g startu    'systemctl start --user'
  abbr -g stopu     'systemctl stop --user'
  abbr -g enu       'systemctl enable --user'
  abbr -g disu      'systemctl disable --user'
  abbr -g stsu      'systemctl status --user'
  abbr -g drelu     'systemctl daemon-reload --user'
  abbr -g relu      'systemctl reload --user'
  abbr -g resu      'systemctl restart  --user'
  abbr -g ju        'journalctl --user -f -u'

  # Docker
  abbr -g d    'docker'
  abbr -g db   'docker build'
  abbr -g dr   'docker run'
  abbr -g drit 'docker run -it'
  abbr -g deit 'docker exec -it'
  abbr -g drm  'docker rm -f'
  abbr -g dcl  'docker container list'
  abbr -g dc   'docker-compose'
  abbr -g dcub 'docker-compose up --build'
  abbr -g dce  'docker-compose exec'
  abbr -g dcd  'docker-compose down'

  # VirtualBox
  abbr -g vb   'vboxmanage'

  # Misc
  abbr -g g     'git'
  abbr -g v     'vim'
  abbr -g e     'myemacs'
  abbr -g E     'myemacs -c'
  abbr -g s     'sudo'
  abbr -g paru  'cmd-with-notify paru'
  abbr -g py    'python'
  abbr -g ipy   'ipython'
  abbr -g copy  'xsel -b'
  abbr -g paste 'xsel -b -o'
  abbr -g oct   'octave'
  abbr -g octb  'OCTAVE_BASIC=true command octave'
  abbr -g va    'vagrant'
  abbr -g u     'fusermount -u'
  abbr -g um    'sudo umount'
  abbr -g cmd   'command'
  abbr -g w     'watch -n0.1'

  abbr -g yt    'ytfzf -t -s'
  abbr -g t     'tem'
  abbr -g v     'vim (fzf)'
  abbr -g fm    'vifm'
  abbr -g fb    'facebook-cli'
  abbr -g c     'conf'
  abbr -g fl    'flameshot'
  abbr -g tb    'nc termbin.com 9999'
  abbr -g asc   'asciinema'
  abbr -g priv  'fish --private'
  abbr -g hk    'heroku'
  abbr -g mhc   'man http-codes'
  abbr -g rgh   'rg --hidden'
  if [ -n "$DISPLAY" ]
      abbr -g man   'eman'
  end

  # Pass
  abbr -g pn 'pass insert'
  abbr -g pg 'pass generate --clip'
  abbr -g pe 'pass edit'
  abbr -g pc 'pass show --clip'

  # Google cloud
  abbr -g gce 'gcloud compute'

  # Tmux
  abbr -g x   'tmux'
#+end_src
*** Variables
#+begin_src fish
  set aur 'aur@aur.archlinux.org'
#+end_src
* .profile
#+begin_src shell :tangle (haris/tangle-home ".profile")
  export MAKEFLAGS='-j6'
  export GPG_TTY=$(tty)
  [ "$(uname)" = "Linux" ] && export QT_QPA_PLATFORMTHEME=gtk2
  export PYTHONSTARTUP=~/.startup.py
  export RUSTC_WRAPPER=sccache
  export MOZ_USE_XINPUT2=1

  export PATH=~/.local/bin:$PATH:~/.pyenv/versions/3.8.3/bin:~/mnt/vm/.tem/path:/opt/android-sdk/emulator

  mkdir -p /tmp/stage-"$USER"

  [ -f ~/.alias ]           && . ~/.alias
  [ -f ~/.alias-tmp ]       && . ~/.alias-tmp
  [ -f ~/.alias-gui ]       && . ~/.alias-gui
  [ -f ~/.alias-gui-tmp ]   && . ~/.alias-gui-tmp
  [ -f ~/.profile-private ] && . ~/.profile-private
#+end_src
* Temporary configs
[[~/.config/fish/tmp.fish][Click to edit]]
#+begin_src fish
  source ~/.config/fish/tmp.fish
#+end_src
* Dependencies
#+begin_src shell :tangle (haris/tangle-deps "shells.sh")
  sudo pacman -S dash fish
#+end_src
