#+TITLE: Shell Config
#+SETUPFILE: .setup.org
#+PROPERTY: header-args:fish+ :tangle (haris/tangle-home ".config/fish/config.fish")

- *dash* as the system shell (because it's faster)
- *fish* as my interactive shell
- *bash* for some scripts because it's more convenient than dash and more POSIX compliant
  than fish
Using org-tangle, I output the configs to the files they need to be in:

- =~/.profile= is sourced by login, making everything in it available to all shells.
- =~/.bashrc= is sourced by *bash* and *fish* (using the *bass* extension).
- The files =~/.alias= and =~/.alias-gui= contain aliases that I want available in
  all shells.

Additionally, =~/.alias-tmp= and  =~/.alias-gui-tmp= are not tangled from this file.
Instead I create them manually when needed to hold temporary aliases for the
purposes of experimentation. They are not under VCS.

* Fish
Note: I keep fish aliases in [[#alias-fish][Aliases]].
#+begin_src fish
  set fish_greeting ''
  function __haris_init_key_bindings --on-event fish_prompt
      # If I don't postpone it, something overrides it in certain setups
      [ -z "$EMACS_VTERM_PATH" ] && fish_vi_key_bindings || fish_default_key_bindings
      functions --erase __haris_init_key_bindings
  end

  # Disable path shortening
  set fish_prompt_pwd_dir_length 0

  if type --quiet bass
      # I'm setting HOME to prevent errors when running inside tuterm
      HOME="/home/$USER" bass source ~/.bashrc # Load bash's config
      if status is-login
          bass source ~/.profile
      end
  end

  set -gx MANPATH  ":$__fish_data_dir/man"      # Add fish manpages to MANPATH
  set -gx MANWIDTH 80
  set -gx EDITOR 'editor'
  set -gx VISUAL 'visual-editor'
  set -gx PAGER 'less'
#+end_src
** Behavior overrides
*** =fish_prompt=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/fish_prompt.fish")
  function fish_prompt --description 'Write out the prompt'
      set -l last_pipestatus $pipestatus

      set -l normal (set_color normal)

      # Color the prompt differently when we're root
      set -l color_cwd $fish_color_cwd
      set -l prefix
      set -l suffix '$'
      if contains -- $USER root toor
          if set -q fish_color_cwd_root
              set color_cwd $fish_color_cwd_root
          end
          set suffix '#'
      end

      # If we're running via SSH, change the host color.
      set -l color_host $fish_color_host
      if set -q SSH_TTY
          set color_host $fish_color_host_remote
      end

      set -l prompt_status (__fish_print_pipestatus " [" "]" "|" \
          (set_color brred) (set_color --bold brred) $last_pipestatus)

      # Using a timeout here prevents hang on remotely mounted filesystems
      set -l vcs_prompt (timeout 0.2 fish --no-config -c fish_vcs_prompt 2>/dev/null)
      set -l vcs_prompt (
          echo "$vcs_prompt" |
          head -c 40 |
          string replace -r '([^\)])$' '$1)'
      )

      set -l host
      if [ -n "$SSH_CONNECTION" ]
          set host "$normal"(set_color white)"[$hostname]"
      end

      set -l sudo_privilege
      if sudo -n true 2>/dev/null
          set sudo_privilege " (#)"
      end

      echo -n -s  (set_color --bold brblue)   "$USER$host "                \
                  (set_color magenta)         (prompt_pwd)        $normal  \
                  (set_color brmagenta)       "$vcs_prompt"                \
                  (set_color brmagenta)       $prompt_status               \
                  (set_color white)           $sudo_privilege              \
                  (set_color yellow)          \n" $suffix "

      # These are needed because some apps (docker-compose) don't clean up properly
      begin
          # Exit AppMode
          echo -ne "\e[?1l"
          # Show the cursor again
          echo -e "\e[?25h"
      end
  end
#+end_src
**** =fish_mode_prompt=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/fish_mode_prompt.fish")
  function fish_mode_prompt
      if [ -z "$EMACS_VTERM_PATH" ]
          switch $fish_bind_mode
              case default
                  set_color --bold brred
                  echo '[N] '
              case insert
                  # Show nothing
              case replace_one
                  set_color --bold green
                  echo '[r] '
              case replace
                  set_color --bold blue
                  echo '[R] '
              case visual
                  set_color --bold magenta
                  echo '[V] '
              case '*'
                  set_color --bold red
                  echo '?'
          end
      end
      set_color normal
  end
#+end_src
*** Horizontal command output separator
**** =__haris_draw_output_separator=
This function prints a horizontal line spanning the terminal screen,
that serves as a visual separator of command outputs. It helps me to inspect the
scrollback buffer more easily.

It is bound to the =fish_postexec= event, so it is printed any time a command
finishes; unless the command was =clear= in which case we don't print it in order
to prevent the line to be visible after clearing.
#+begin_src fish
  function __haris_draw_output_separator --on-event fish_postexec
      set -l _pipestatus "$fish_pipestatus"
      # When clearing the screen using 'clear' (without -x), the output separator
      # should not be drawn. Otherwise the terminal would contain a line on the top.
      if echo "$argv" | grep -v -- '-x' | grep -qE '^clear($|\s)'
          return
      end

      # Clear any ^C text (due to pressing Ctrl+C to quit the previous process)
      if string match -rq 'SIGINT$' (__fish_print_pipestatus '' '' ' ' '' '' $pipestatus)
          echo -ne '\b\b'
      end

      bash -c 'echo -ne "\e[38;5;238m"; printf "%*s\n" "${COLUMNS:-$(tput cols)}" " " | sed "s: :—:g"'
  end
#+end_src
*** Notification when background job exits
Sends a graphical notification when a command running in a non-visible
context finishes. This applies to commands that are:
- running in a terminal emulator that is minimized or in a different workspace
- running without a terminal that can be accessed, e.g. launched via dmenu

This applies only to graphical sessions, the linux TTY is unaffected.
**** =__haris_notify_bg_task_done=
#+begin_src fish
  function __haris_notify_bg_task_done --on-event fish_postexec
      set -l _status "$status"

      [ -n "$HARIS_BACKGROUND_TASKS_SILENT" ] && return
      [ -n "$DISPLAY" ] || return

      if ! type --quiet xdotool
          return 0
      end

      # Check if terminal window is hidden
      if xdotool search --all --onlyvisible "" 2>/dev/null | ! grep -q "$WINDOWID"
          set -l exit_message
          if [ "$_status" = 0 ]
              set exit_message "exited successfully"
          else
              set exit_message "exited with $_status"
          end
          # Timeout is so the command doesn't hang when daemon is not running
          timeout 0.8 notify-send (echo "Command "(history | tac | tail -n +"$__haris_history_count" 2>/dev/null)"" "$exit_message")
          if [ "$status" = "124" ]
              echo ERR: NOTIFICATION TIMED OUT
          end
      end

      set -g __haris_history_count (history | wc -l)
  end
#+end_src
*** =edit_command_buffer_custom=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/edit_command_buffer_custom.fish")
  set -l actual_editor
  if which emacs >/dev/null
      set actual_editor emacs
  else
      set actual_editor nvim
  end

  functions edit_command_buffer |
      sed -E -e 's/^(function edit_command_buffer)/\1_custom/' \
             -e "s/(case.* $actual_editor\b)/\1 visual-editor /" \
      | source
#+end_src
** Bindings
:PROPERTIES:
:header-args:fish+: :tangle (haris/tangle-home ".config/fish/functions/fish_user_key_bindings.fish")
:END:
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/bind_both_modes.fish")
  function bind_both_modes
      bind -M default $argv
      bind -M insert $argv
  end
#+end_src
#+begin_src fish
  function fish_user_key_bindings               # Start bindings
#+end_src
*** Quasi-vim-like key bindings
#+begin_src fish
  bind_both_modes \el forward-char
  bind_both_modes \eh backward-char
  bind_both_modes \cp up-or-search
  bind_both_modes \cn down-or-search
#+end_src
*** Fish behavior control bindings
#+begin_src fish
  bind_both_modes \er src_fish

  # Some terminals like linux TTY and emacs vterm send Ctrl+P as \cP, so I enable
  # it only for alacritty which has been proven to work. I can add other terminals
  # here as needed.

  if [ "$TERM" = "alacritty" ]
      bind_both_modes \cP \
      '
      echo Starting private mode...;
      set fish_private_mode true;
      commandline -f repaint
      '
  end

  bind_both_modes \eL 'clear; commandline -f repaint'
#+end_src
*** Utility bindings
#+begin_src fish
  # Copy the current contents of the command line
  bind_both_modes \ec 'commandline -b | xsel -b'

  # Run the current command in bash
  bind_both_modes \eb __haris_run_in_bash

  # Prepend o in front of current command
  bind_both_modes \eo '__haris_cmdline_prepend o'

  # Prepend man in front of current command
  bind_both_modes \em '__haris_show_man'

  # Append --help to the end of the command line and submit
  bind_both_modes \eH '__haris_cmdline_append_or_toggle --help'

  # Append --version to the end of the command line and submit
  bind_both_modes \eV '__haris_cmdline_append_or_toggle --version'

  bind_both_modes \et term

  bind_both_modes \eg 'dragon (command ls | fzf --multi) >/dev/null 2>&1'

  bind_both_modes \ee 'edit_command_buffer_custom'

  bind_both_modes \eE 'myemacs-float .'

  bind_both_modes \ea 'commandline -i "(adhoc)"'

  bind_both_modes \eA 'commandline -i "(adhoc - | string collect)"'

  bind_both_modes \eG 'magit'

  bind_both_modes \e\cd 'disown'

  bind_both_modes \eC 'edocker-compose'
  end                                          # End fish_user_key_bindings
#+end_src
**** Helper functions
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/__haris_run_in_bash.fish")
  function __haris_run_in_bash
      set -l cmd (commandline -b)
      echo
      eval bash -c "'source ~/.bashrc; $cmd'"
      commandline -f repaint
      commandline -r ''
  end
#+end_src
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/__haris_cmdline_prepend.fish")
  function __haris_cmdline_prepend
      commandline --cursor 0
      commandline --insert "$argv "
      commandline --function end-of-line
  end
#+end_src
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/__haris_show_man.fish")
  function __haris_show_man
      eman (commandline --current-process --tokenize | grep -v '^sudo$' | head -1)
  end
#+end_src
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/__haris_cmdline_append_or_toggle.fish")
  function __haris_cmdline_append_or_toggle -a text
      if [ (commandline -o | tail -1) = "$text" ]
          commandline -r (commandline | string replace -r -- "\s+$text\s*\$" '')
          return
      end
      commandline --append " $text"
      commandline -f execute
  end
#+end_src
** Custom colors
#+begin_src fish
  set -U fish_color_command           brblue
  set -U fish_color_quote             brgreen
  set -U fish_color_param             brcyan
  set -U fish_color_autosuggestion    brblack
  set -U fish_color_cancel         -r red
  set -U fish_color_error             red
  set -U fish_color_comment           green
  set -U fish_color_operator          normal
  set -U fish_color_redirection       brmagenta
  set -U fish_pager_color_progress    brgreen
  set -U fish_pager_color_description green
  set -U fish_color_end               yellow
#+end_src
** Plugins
#+begin_src fish :tangle (haris/tangle-home ".config/fish/fish_plugins")
  jorgebucaran/fisher
  edc/bass
  oh-my-fish/plugin-pj
  PatrickF1/fzf.fish
  jorgebucaran/nvm.fish
  evanlucas/fish-kubectl-completions
  # Fixes some vterm issues
  pymander/vfish
  brgmnn/fish-docker-compose
#+end_src
*** Initialization
#+begin_src fish
  # pj plugin
  set -gx PROJECT_PATHS ~/proj ~/proj/drytoe

  # z.lua
  set _ZL_CMD z
  if type --quiet lua && [ -f /usr/share/z.lua/z.lua ]
      lua /usr/share/z.lua/z.lua --init fish | source
  end
  set -gx _ZL_CD cd

  # tem
  if type --quiet tem
      tem fish-init
  end

  # fzf bindings
  if functions | grep --quiet fzf_configure_bindings
      fzf_configure_bindings
  else if [ -e ~/.config/fish/conf.d/fzf.fish ]
      function __haris_load_fzf --on-event fish_prompt
          source ~/.config/fish/conf.d/fzf.fish
          functions --erase __haris_load_fzf
      end
  end
#+end_src
*** Dependencies
System packages:
#+begin_src text :tangle (haris/tangle-deps "fish/plugins.aur")
  fisher
#+end_src
#+begin_src text :tangle (haris/tangle-deps "fish/plugins.pacman")
  fish
  # Dependencies for fzf.fish
  fd bat
#+end_src
This code block installs all system dependencies and all plugins in fish based
on the plugin list above.
#+begin_src shell :tangle (haris/tangle-deps "fish/plugins.sh")
  touch ~/.config/fish/{private,tmp}.fish
  fish -c "fisher update"
#+end_src
** Functions
*** =ndir=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/ndir.fish")
  # Create a new dir and cd
  function ndir;  mkdir -p "$argv"; cd "$argv"; end
#+end_src
*** =1=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/1.fish")
  # Print first argument
  function 1; echo $argv[1]; end
#+end_src
*** =a=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/a.fish")
  # Run z through fzf
  function a
      z -l $argv | read -z choices
      set -l count (echo "$choices" | sed '/^$/d' | wc -l)
      set dest (echo "$choices" | sed '/^$/d' | tac | fzf --select-1)

      cd (echo "$dest" | sed -E -e '/^$/d' -e 's/^\S+\s+//')
  end
#+end_src
*** =open=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/open.fish")
  # Open a GUI app and disown
  function open; for file in $argv; o xdg-open "$file"; end; end
#+end_src
*** =imount=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/imount.fish")
  # Wrapper around imount script so I can cd to the mount directory
  function imount
      command imount $argv
      cd (cat /tmp/imount_directory)
  end
#+end_src
*** =vh=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/vh.fish")
  # Vim help
  function vh; vim -c ":h $argv | only"; end
#+end_src
*** =copypath=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/copypath.fish")
  # Save the path of the argument to the clipboard
  function copypath; realpath $argv | xsel -b; end
#+end_src
*** =ls=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/ls.fish")
  # When you ls, save the argument so you can quickly cd to that folder.
  # It's not fool-proof, but it works in most situations and it's safe.
  function ls
      if [ -z "$EMACS_VTERM_PATH" ] && type --quiet lsd
          # In emacs vterm, lsd outputs additional whitespace which is annoying
          lsd --color=auto $argv
      else
          command ls --color=auto $argv
      end
      set -g __last_ls_arg "$argv"
  end
#+end_src
*** =cdls=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/cdls.fish")
  # cd the last directory you have ls-ed
  function cdls
      [ -n "$__last_ls_arg" ] && cd "$__last_ls_arg"
  end
#+end_src
*** =vils=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/vils.fish")
  # vim the last file you have ls-ed
  function vils
      [ -n "$__last_ls_arg" ] && vim "$__last_ls_arg"
  end
#+end_src
*** =chbg=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/chbg.fish")
  function chbg
      set -l path (
          ls 2>/dev/null \
              ~/.local/share/backgrounds/"$argv[1]" \
              /usr/local/share/backgrounds/"$argv[1]" \
              /usr/share/backgrounds/"$argv[1]" |
              head -1
      )
      feh --bg-fill "$path"
      rm ~/.wallpaper
      ln -s "$path" ~/.wallpaper
  end
#+end_src
**** Completions
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/chbg.fish")
  complete --command chbg --no-files --arguments="(
      begin
          ls -1 2>/dev/null ~/.local/share/backgrounds
          ls -1 2>/dev/null /usr/local/share/backgrounds
          ls -1 2>/dev/null /usr/share/backgrounds
      end |
          sort |
          uniq
  )"
#+end_src
*** =vicmd=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/vicmd.fish")
  function vicmd
      set -l file (fcmd "$argv");
      if [ -f "$file" ]
          vim "$file"
      else
          read -n 1 -P "Create new script? [y/N]: " choice
          if [ "$choice" = 'y' ]
              myemacs-float ~/.haris/scripts.org
          else
              echo 'Aborting...'
              return 1
          end
      end
  end
#+end_src
*** =o=
#+NAME: o
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/o.fish") :eval no
  # Run a command and disown. Put it into a tmux session. Notify the user when done.
  # Persist a shell for a small time so the user can follow up on the command. If
  # the user doesn't follow up within 20 minutes, the background shell will exit
  # automatically.
  function o
      set -l __o_args $argv
      <<o/argparse>>
      set -l _status "$status"
      if [ "$_status" != 0 ]
          return "$_status"
      end

      if [ -n "$_flag_h" ]
          echo "Run a command in the background in a tmux session so its output can be inspected on-demand."
          echo
          echo "A GUI notification is sent when the command completes."
          echo "After the command completes, plus a certain linger period, the tmux session is killed."
          echo "The linger period can be adjusted with --linger-period or disabled with --persist."
          echo
          echo "Usage: o [OPTIONS] COMMAND..."
          echo
          echo "  -h, --help"        \t\t"Print this help message."
          echo "  -p, --persist"       \t"Persist the tmux session until manually killed."
          echo "  -l, --linger-period" \t"How long the tmux session should linger after the command completes."
          echo                     \t\t\t"Same format as for the sleep command. (default: 20m)"
          echo "  -s, --silent"      \t\t"Do not send a GUI notification when the command completes."
          echo "  -a, --attach"      \t\t"Immediately attach to the created tmux session"
          return
      end

      # The remaining args contain only the command to be run (argparse options have been extracted)
      set -l __cmdline (string escape -- $argv)
      # The arguments are forwarded to the helper script, so it can parse them
      set -l __o_args (string escape -- $__o_args)

      set -l tempfile (mktemp)

      echo >"$tempfile" "
      rm -f '$tempfile'
      set HARIS_BACKGROUND_TASKS_SILENT $HARIS_BACKGROUND_TASKS_SILENT;
      set __o_args $__o_args;
      set __cmdline $__cmdline;"'
      <<o/background-task>>
      '

      set -l tmux_session "$(echo "$__cmdline" | head -c20) [$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c 5)]"

      tmux new -d \
          -s "$tmux_session" \
          env "$(env)" fish --private -C "source $tempfile"

      if [ -n "$_flag_attach" ]
          tmux attach -t "$tmux_session"
      end
  end
#+end_src
**** Testing
Test the function by executing this code block:
#+NAME: o/test
#+begin_src fish :tangle no :cmdline --no-config
  <<o>>
  o --linger-period=8s fish -C '
      echo Simulating long command...;
      sleep 3s; echo Done.;
      echo The terminal window should close in a few seconds;
      echo "The exit code (\$status) should be 1!";
      false'
  alacritty-float -e tmux attach
#+end_src
**** Argparse block
#+NAME: o/argparse
#+begin_src fish :tangle no
  argparse \
    --stop-nonopt \
    --exclusive linger-period,persist \
    h/help \
    p/persist \
    l/linger-period= \
    s/silent \
    a/attach \
    -- $__o_args
#+end_src
**** Background task and follow-up shell
Note: This code block must not contain any apostrophes!
#+NAME: o/background-task
#+HEADER: :shebang "#!/usr/bin/env fish"
#+begin_src fish :tangle no :eval no
  # Convert o options to local variables
  <<o/argparse>>
  set linger_period 20m
  if [ -n "$_flag_linger_period" ]
      set linger_period "$_flag_linger_period"
  end
  set persist "$_flag_persist"
  set silent "$HARIS_BACKGROUND_TASKS_SILENT"
  if [ -n "$_flag_silent" ]
      set silent "$_flag_silent"
  end

  functions -e fish_greeting
  # Run the command
  $__cmdline

  set __status "$status"
  set -l tmux_session (tmux display-message -p "#S")

  if [ -z "$silent" ] && [ -z "$(tmux list-clients -t "$tmux_session")" ]
      # Send a notification and wait for it to close. The reason we wait for it is
      # because if the user is AFK, then the follow-up shell would exit prematurely.
      # This way, if the user has set up notiication persistence while AFK, we
      # leverage that feature.
      # If a tmux session is already attached, the notification is not displayed.
      set -l notif_options
      if [ "$__status" != 0 ]; set -a notif_options "--urgency=critical"; end
      set -l notif_id_file (mktemp)
      # If a client attaches, the notification is no longer necessary and is immediately closed
      set -l hook (string escape run-shell "sh -c \"[ -n \"$notif_id_file\" ] && dunstify --close=\$(cat $notif_id_file)\" || true")
      tmux set-hook client-attached "$hook"

      unbuffer \
          notify-send "Background task done" \
          "$__cmdline exited with code $__status" \
          --wait --print-id $notif_options \
          2>/dev/null >"$notif_id_file"

      rm -f "$notif_id_file"
  end

  if [ -z "$persist" ]
      # Start a timeout for the shell to close if the user does not perform any
      # follow-up commands
      sh -c "sleep $linger_period; kill $fish_pid" &
      jobs --last --pid | read _timeout_pid
      disown

      function __haris_on_stop_interaction_timeout --on-event fish_preexec
          kill "$_timeout_pid"
          functions --erase __haris_on_stop_interaction_timeout
      end
  end

  function __haris_reproduce_status_code
      functions --erase __haris_reproduce_status_code
      return $__status
  end

  __haris_reproduce_status_code
#+end_src
**** Completions
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/o.fish")
  complete -c o --wraps command
#+end_src
*** =enved=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/enved.fish")
  function enved --argument envvar --description "Edit an environment variable by name"
      set tmp (mktemp /tmp/envvar-XXXXXXXXX)
      bass echo \$"$envvar" > "$tmp"
      "$EDITOR" "$tmp"
      bass export "$envvar"=(cat "$tmp")
      /usr/bin/rm -f "$tmp"
  end
#+end_src
*** =^=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/^.fish")
  function '^' -d "cd to the first directory in the hierarchy by specified name" -a name
      pushd "$PWD"
      while [ "$PWD" != "/" ]
          if [ (basename "$PWD") = "$name" ]
              set -l dir "$PWD"
              popd
              cd "$dir"
              return
          end
          cd ..
      end
      popd
      return 1
  end
#+end_src
**** Completions
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/^.fish")
  complete -c '^' -a '(pwd | tr "/" "\n")' -f
#+end_src
*** =forever=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/forever.fish")
  function forever
      while :
          $argv
          sleep 2s
      end
  end
#+end_src
**** Completions
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/forever.fish")
  complete -c forever --wraps command --wraps builtin
#+end_src
*** Miscellaneous others
#+begin_src fish
  function cdcf;   set -l file (cf "$argv");   test -f "$file" && cd (dirname        "$file"); end
  function catcf;  set -l file (cf "$argv");   test -f "$file" && cat                "$file" ; end
  function vicf;   set -l file (cf "$argv");   test -e "$file" && vim                "$file" ; end
  function ecf;    set -l file (cf "$argv");   test -e "$file" && myemacs-float "$file" ; end

  function cdcmd;  set -l file (fcmd "$argv"); test -f "$file" && cd (dirname "$file"); end
  function catcmd; set -l file (fcmd "$argv"); test -f "$file" && cat         "$file" ; end
  function ecmd;   set -l file (fcmd "$argv"); test -f "$file" && myemacs     "$file" ; end
  function rmcmd;  set -l file (fcmd "$argv"); rm "$file";                              end
#+end_src
**** =eman=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/eman.fish")
  function eman
      if [ -n "$DISPLAY" ] && emacsclient -s emacs --eval nil >/dev/null 2>&1
          command eman $argv
      else
          man $argv
      end
  end
#+end_src
** Completions
Function(s) that will be used by many completions.
Completions for the functions defined in [[Functions]].
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/no_positional_args.fish")
  # Return success if the command line contains no positional arguments
  function no_positional_args
      set -l -- args    (commandline -po)         # cmdline broken up into list
      set -l -- cmdline (commandline -p)          # single string
      set -l -- n       (count $args)             # number of cmdline tokens
      for i in (seq 2 $n)
          set -l arg $args[$i]
          [ -z "$arg" ] && continue               # can be caused by '--' argument

          # If the the last token is a positional argument and there is no
          # trailing space, we ignore it
          [ "$i" = "$n" ] && [ (string sub -s -1 "$cmdline") != ' ' ] && break

          if string match -rvq '^-' -- "$arg"     # doesn't start with -
              return 1
          end
      end
      # contains a '--' argument
      string match -r -- '\s--\s' "$cmdline" && return 1
      return 0
  end
#+end_src
*** =snip=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/snip.fish")
  complete -c snip -f -a \
      "(pushd ~/.vim/snips; command ls | sed 's_\(.*\)\.snippets_\1_g'; popd)"
#+end_src
*** =adhoc=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/adhoc.fish")
  complete -c adhoc -f \
      -a "(complete -C'adsfadadflasdjflasdflnasdflasdu /tmp/adhoc-files/' | string replace /tmp/adhoc-files/ \"\")"
#+end_src
*** =pass=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/pass.fish")
  source /usr/share/fish/vendor_completions.d/pass.fish
  complete -c pass -a 'add' -n "no_positional_args"
  complete -c pass -a '(complete -C "pass show ")' -f -n '__fish_seen_subcommand_from add'
#+end_src
*** =otp=
#+begin_src shell :tangle (haris/tangle-home ".config/fish/completions/otp.fish")
    complete -c otp -a '(fd "otp-secret.gpg" ~/.password-store -x echo {//} | sed "s:^.*/\.password-store/\?::")' -f
#+end_src
*** Miscellaneous others
#+begin_src fish
  # *cf and *cmd style commands
  for cmd in {,cd,vi,cat,e}cf
      complete --command $cmd --no-files -a '(lscf)'
  end
  for cmd in {f,cd,vi,cat,e, rm}cmd
      complete -c $cmd -f \
          -a '(command ls -1 $PATH 2>/dev/null | grep -v "/")'
  end
#+end_src
* Bash
Note: =~/.bashrc= is sourced by fish as well.
#+begin_src bash :tangle (haris/tangle-home ".bashrc")
  PS1='\[\e[1;36m\]\u\[\e[1;31m\]@\[\e[1;34m\]\h \[\e[1;32m\]\W \[\e[1;31m\]\$ \[\e[0;32m\]\[\e[0m\]'

  [ -f ~/.alias ]         && source ~/.alias
  [ -f ~/.alias-tmp ]     && source ~/.alias-tmp
  [ -f ~/.alias-gui ]     && source ~/.alias-gui
  [ -f ~/.alias-gui-tmp ] && source ~/.alias-gui-tmp

  # Shell options
  shopt -s extglob
  shopt -s autocd
  shopt -s globstar

  {
  bind '"\C-p":previous-history'
  bind '"\C-k":previous-history'
  bind '"\C-n":next-history'
  bind '"\C-j":next-history'
  } 2>/dev/null

  export SHELL='fish'
  export MPD_HOST="localhost"
  export MPD_PORT="6601"

  if ! [[ "$PATH" =~ ~/\.local/bin ]]; then
      export PATH=~/.local/bin:"$PATH"
  fi
#+end_src
* Aliases
There are some aliases that I want to have available in all shells. I break
them up into two groups: aliases for CLI (~~/.alias~) and aliases GUI programs
(~~/.alias-gui~). I make this distinction because my custom ~dmenu_run~ script
takes all the aliases from the latter and I can run them as normal programs.
Both files have a variant suffixed by ~-tmp~ in which I keep temporary aliases
and I do not keep them under version control.

It makes no sense to launch CLI programs from dmenu. Still, I make aliases
from ~~/.alias~ available in ~dmenu_run~. When I enter them in dmenu, it launches
a terminal and runs the aliased command.
** CLI
#+begin_src shell :tangle (haris/tangle-home ".alias")
  if which startx >/dev/null; then
      alias x='startx'
  fi
  if which nvim >/dev/null; then
      alias vim='nvim'
  fi
  alias snips='cd ~/.vim/snips'
  alias vidir='VISUAL=nvim command vidir'
  alias cppman='PAGER=viman command cppman'
  alias aurvote='ssh aur@aur.archlinux.org vote'
  alias ...='cd ../..'
  alias l1='ls -1'
  alias src='cd ~/src'
  alias tmp='cd /tmp'
  alias stage='mkdir -p /tmp/stage-"$USER"; cd /tmp/stage-"$USER"'
  alias bin='cd ~/.local/bin'
  alias usb='cd ~/mnt/usb'
#+end_src
** GUI
#+begin_src shell :tangle (haris/tangle-home ".alias-gui")
  alias calc='speedcrunch'
  alias screenkey='screenkey --bg-color "#99a3ff" --font-color "#1e1e1e"'
  alias VirtualBox="QT_QPA_PLATFORMTHEME=qt command VirtualBox"
  alias ff="firefox"
#+end_src
** Fish
:PROPERTIES:
:CUSTOM_ID: alias-fish
:END:
*** Aliases
#+begin_src fish
  alias src_fish  'source ~/.config/fish/config.fish'
  alias term      'term & disown'
  if command --quiet docker
      alias alpine    'docker run -it --rm --name alpine alpine'
      alias debian    'docker run -it --name debian debian:bookworm-slim'
  end

  function dragon
      o dragon-drag-and-drop --on-top --thumb-size 32 $argv
  end

  function vrg --wraps rg; vim (rg -l $argv); end
  function vfd --wraps fd; vim (fd $argv); end
#+end_src
*** Abbreviations
**** Helper functions
***** =conditional_abbr=
Create an abbreviation of a callable (command, function or builting), optionally
with arguments, but only if the callable actually exists.
#+begin_src fish
  function conditional_abbr
      set -l command (echo $argv[-1] | cut -f1 -d' ')
      if type --quiet "$command"
          abbr -g $argv
      end
  end
#+end_src
**** Safety precautions
#+begin_src fish
  abbr -g rm 'rm -i'
  abbr -g mv 'mv -i'
#+end_src
**** Typo correction
#+begin_src fish
  conditional_abbr -g claer 'clear'
  conditional_abbr -g pas   'pass'
  conditional_abbr -g gs    'git status'
#+end_src
**** Pacman commands
I also sometimes use Ubuntu, but since I'm so used to pacman, I use the same
abbreviations for equivalent apt operations.
***** Guard
#+begin_src fish
  function _if_pacman_else
      if command --quiet pacman
          echo "$argv[1]"
      else
          echo "$argv[2]"
      end
  end
#+end_src
#+begin_src fish
  if command --quiet pacman || command --quiet apt
#+end_src
***** Abbreviations
#+begin_src fish
  abbr -g p     (_if_pacman_else 'pacman'         'apt')
  abbr -g pq    (_if_pacman_else 'pacman -Q'      'apt list --installed')
  abbr -g pqq   (_if_pacman_else 'pacman -Qq'     'apt list --installed')
  abbr -g pqi   (_if_pacman_else 'pacman -Qi'     'dpkg --status')
  abbr -g pql   (_if_pacman_else 'pacman -Ql'     'dpkg --listfiles')
  abbr -g pqm   (_if_pacman_else 'pacman -Qm')
  abbr -g pqe   (_if_pacman_else 'pacman -Qe')
  abbr -g pqo   (_if_pacman_else 'pacman -Qo'     'apt-file search --regexp')
  abbr -g pqs   (_if_pacman_else 'pacman -Qs')
  abbr -g psi   (_if_pacman_else 'pacman -Si'     'apt-cache show')
  abbr -g pss   (_if_pacman_else 'pacman -Ss'     'apt search')
  abbr -g pqdtq (_if_pacman_else 'pacman -Qdtq')
  abbr -g sp    (_if_pacman_else 'sudo pacman'    'sudo apt')
  abbr -g sps   (_if_pacman_else 'sudo pacman -S' 'sudo apt install')
  abbr -g spr   (_if_pacman_else 'sudo pacman -R' 'sudo apt remove')
  abbr -g sprq  (_if_pacman_else 'sudo pacman -R (pacman -Qdtq)' 'sudo apt autoremove')
#+end_src
***** End guard
#+begin_src fish
  end
  functions --erase _if_pacman_else
#+end_src
**** Systemd
***** Guard
#+begin_src fish
  if command --quiet systemctl
#+end_src
***** Abbreviations
#+begin_src fish
  abbr -g ctl       'sudo systemctl'
  abbr -g start     'sudo systemctl start'
  abbr -g stop      'sudo systemctl stop'
  abbr -g en        'sudo systemctl enable'
  abbr -g dis       'sudo systemctl disable'
  abbr -g sts       'systemctl status'
  abbr -g drel      'sudo systemctl daemon-reload'
  abbr -g rel       'sudo systemctl reload'
  abbr -g res       'sudo systemctl restart'
  abbr -g sus       'systemctl suspend'
  abbr -g j         'journalctl -f -u'
#+end_src
****** --user versions
#+begin_src fish
  abbr -g ctlu      'systemctl --user'
  abbr -g startu    'systemctl start --user'
  abbr -g stopu     'systemctl stop --user'
  abbr -g enu       'systemctl enable --user'
  abbr -g disu      'systemctl disable --user'
  abbr -g stsu      'systemctl status --user'
  abbr -g drelu     'systemctl daemon-reload --user'
  abbr -g relu      'systemctl reload --user'
  abbr -g resu      'systemctl restart  --user'
  abbr -g dresu     'systemctl daemon-reload --user && systemctl restart  --user'
  abbr -g ju        'journalctl --user -f -u'
#+end_src
***** End guard
#+begin_src fish
  end
#+end_src
**** Docker
#+begin_src fish
  if command --quiet docker
      set -g __haris_docker docker
  else if command --quiet podman
      set -g __haris_docker podman
  end

  if [ -n "$__haris_docker" ]
#+end_src
#+begin_src fish
  abbr -g d      "$__haris_docker"
  abbr -g db     "$__haris_docker build"
  abbr -g dbn    "$__haris_docker build --no-cache"

  abbr -g dr     "$__haris_docker run"
  abbr -g drit   "$__haris_docker run -it"
  abbr -g drite  "$__haris_docker run -it --entrypoint"

  abbr -g deit   "$__haris_docker exec -it"

  abbr -g drm    "$__haris_docker rm -f"

  abbr -g di     "$__haris_docker image"
  abbr -g dil    "$__haris_docker image ls"
  abbr -g dip    "$__haris_docker image prune"
  abbr -g dii    "$__haris_docker image inspect"
  abbr -g dir    "$__haris_docker image rm"

  abbr -g dc     "$__haris_docker container"
  abbr -g dcl    "$__haris_docker container ls"
  abbr -g dcp    "$__haris_docker container prune"
  abbr -g dci    "$__haris_docker container inspect"

  abbr -g dv     "$__haris_docker volume"
  abbr -g dvl    "$__haris_docker volume ls"
  abbr -g dvc    "$__haris_docker volume create"
  abbr -g dvr    "$__haris_docker volume rm"
  abbr -g dvi    "$__haris_docker volume inspect"
  abbr -g dvp    "$__haris_docker volume prune"

  abbr -g dn     "$__haris_docker network"
  abbr -g dnl    "$__haris_docker network ls"
  abbr -g dni    "$__haris_docker network inspect"
  abbr -g dnp    "$__haris_docker network prune"
  abbr -g dnr    "$__haris_docker network rm"
  abbr -g dnc    "$__haris_docker network connect"
  abbr -g dnd    "$__haris_docker network disconnect"
  abbr -g dnC    "$__haris_docker network create"

  abbr -g ds     "$__haris_docker system"
  abbr -g dsp    "$__haris_docker system prune"
  abbr -g dsd    "$__haris_docker system df -v"

  abbr -g dm     "$__haris_docker manifest"
  abbr -g dmi    "$__haris_docker manifest inspect"

  abbr -g dhh    "$__haris_docker history"
#+end_src
#+begin_src fish
  end
#+end_src
***** Compose
#+begin_src fish
  if [ "$__haris_docker" = "docker" ] &&
      begin
          docker compose version ||
          docker-compose version
      end &>/dev/null
      abbr -g D      'docker-compose'

      abbr -g Db     'docker-compose build'

      abbr -g Du     'docker-compose up'
      abbr -g Dub    'docker-compose up --build'
      abbr -g Dud    'docker-compose up -d'
      abbr -g Dubd   'docker-compose up --build -d'
      abbr -g Dubt   'docker-compose up --build --timestamps'

      abbr -g Dr     'docker-compose run'
      abbr -g Drit   'docker-compose run -it'
      abbr -g Dritd  'docker-compose run -it -d'
      abbr -g Dritb  'docker-compose run -it --build'
      abbr -g Dritn  'docker-compose run -it --no-deps'
      abbr -g Dritbn 'docker-compose run -it --build --no-deps'
      abbr -g Drite  'docker-compose run -it --entrypoint'

      abbr -g Ds     'docker-compose start'
      abbr -g DS     'docker-compose stop'
      abbr -g DR     'docker-compose restart'

      abbr -g Dd     'docker-compose down'
      abbr -g Ddo    'docker-compose down --remove-orphans'
      abbr -g Ddv    'docker-compose down --volumes'
      abbr -g Ddov   'docker-compose down --remove-orphans --volumes'

      abbr -g Deit   'docker-compose exec -it'
      abbr -g Drm    'docker-compose rm -sf'
      abbr -g Dl     'docker-compose logs -f'
      abbr -g Dc     'docker-compose config'
  end
#+end_src
**** Pass
#+begin_src fish
  if command --quiet pass
      conditional_abbr -g pn 'pass insert'
      conditional_abbr -g pg 'pass generate --clip'
      conditional_abbr -g pe 'pass edit'
      conditional_abbr -g pc 'pass show --clip'
  end
#+end_src
**** Watch
#+begin_src fish
  abbr -g w0 'watch -n0.1'
  abbr -g w1 'watch -n1'
  abbr -g w2 'watch -n2'
#+end_src
**** Ufw
#+begin_src fish
  abbr ufw   'sudo ufw'
  abbr ufws  'sudo ufw status numbered'
#+end_src
**** Miscellaneous
#+begin_src fish
  conditional_abbr -g g     'git'
  if [ -n "$DISPLAY" ]
      conditional_abbr -g e 'myemacs -c'
  else
      conditional_abbr -g e 'myemacs'
  end
  conditional_abbr -g E     'myemacs'
  conditional_abbr -g s     'sudo'
  conditional_abbr -g py    'python'
  conditional_abbr -g ipy   'ipython'
  conditional_abbr -g copy  'xsel -b'
  conditional_abbr -g paste 'xsel -b -o'
  conditional_abbr -g oct   'octave'
  conditional_abbr -g octb  'OCTAVE_BASIC=true command octave'
  conditional_abbr -g va    'vagrant'
  conditional_abbr -g u     'fusermount -u'
  conditional_abbr -g um    'sudo umount'
  conditional_abbr -g cmd   'command'
  conditional_abbr -g w     'which'
  conditional_abbr -g P     "pgrep -af"
  conditional_abbr -g Pu     "pgrep -afu "(whoami)
  conditional_abbr -g yt    'ytfzf -t -s'
  conditional_abbr -g t     'tem'
  conditional_abbr -g v     'vim'
  conditional_abbr -g vf    'vim (fzf)'
  conditional_abbr -g fm    'vifm'
  conditional_abbr -g fb    'facebook-cli'
  conditional_abbr -g fl    'flameshot'
  conditional_abbr -g tb    'nc termbin.com 9999'
  conditional_abbr -g asc   'asciinema'
  conditional_abbr -g hk    'heroku'
  conditional_abbr -g mhc   'man http-codes'
  conditional_abbr -g rgh   'rg --hidden'
  conditional_abbr -g px    'ping x'
  conditional_abbr -g ii    'curl ipinfo.io'
  conditional_abbr -g bt    'bluetoothctl'
  conditional_abbr -g sshk  --set-cursor 'ssh-copy-id -i ~/.ssh/%'
  conditional_abbr -g sshkm 'ssh-copy-id -i ~/.ssh/main.pub'

  if [ "$TERM" != "linux" ]
      conditional_abbr -g man   'eman'
  end
  conditional_abbr -g R     'reset'
  conditional_abbr -g pa    'printarg'
  conditional_abbr -g hosts 'myemacs -c /etc/hosts'
#+end_src
**** Google cloud
#+begin_src fish
  conditional_abbr -g gce 'gcloud compute'
#+end_src
**** Tmux
#+begin_src fish
  # Tmux
  conditional_abbr -g x   'tmux'
  conditional_abbr -g X   'tmux attach -t (tmux list-sessions -F "#{session_created} #{session_name}" | sort | tac | grep -Po "(?<= ).*" | fzf -s)'
#+end_src
**** VirtualBox
#+begin_src fish
  # VirtualBox
  conditional_abbr -g vb   'vboxmanage'
#+end_src
**** Discard helper function
#+begin_src fish
  functions --erase conditional_abbr
#+end_src
*** Variables
#+begin_src fish
  set aur 'aur@aur.archlinux.org'
#+end_src
* .profile
#+begin_src shell :tangle (haris/tangle-home ".profile")
  export PATH=~/.local/bin:$PATH:~/.go/bin:"$CLOUDSDK_ROOT_DIR"/bin:~/mnt/vm/.tem/path:/opt/android-sdk/emulator
  mkdir -p ~/.go
  export GOPATH="$HOME"/.go

  export MAKEFLAGS='-j6'
  export GPG_TTY=$(tty)
  export PYTHONSTARTUP=~/.startup.py
  export RUSTC_WRAPPER=sccache
  export MOZ_USE_XINPUT2=1
  [ "$(get-os-type)" = "arch" ] && export QT_QPA_PLATFORMTHEME=gtk2

  # If rootless docker is used, configure the DOCKER_HOST variable
  if systemctl is-enabled --user --quiet docker.service; then
      export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/docker.sock
  fi

  # Better pager for psql command
  if which pspg >/dev/null 2>&1; then
      # '-s 5' chooses the mutt theme
      export PSQL_PAGER='pspg -s 5'
  fi

  mkdir -p /tmp/stage-"$USER"

  [ -f ~/.alias ]           && . ~/.alias           || true
  [ -f ~/.alias-tmp ]       && . ~/.alias-tmp       || true
  [ -f ~/.alias-gui ]       && . ~/.alias-gui       || true
  [ -f ~/.alias-gui-tmp ]   && . ~/.alias-gui-tmp   || true
  [ -f ~/.profile-private ] && . ~/.profile-private || true
#+end_src
* Temporary and private configs
These are optional and must be provided separately.
[[~/.config/fish/private.fish][Click to edit]].
#+begin_src fish
  if [ -f ~/.config/fish/private.fish ]
      source ~/.config/fish/private.fish
  end
#+end_src
[[~/.config/fish/tmp.fish][Click to edit]]
#+begin_src fish
  if [ -f ~/.config/fish/tmp.fish ]
      source ~/.config/fish/tmp.fish
  end
#+end_src
* Dependencies
#+begin_src text :tangle (haris/tangle-deps "shells.pacman")
  dash fish
#+end_src
