#+TITLE: Shell Config
#+SETUPFILE: .setup.org
#+PROPERTY: header-args:fish+ :tangle (haris/tangle-home ".config/fish/config.fish")

- *dash* as the system shell (because it's faster)
- *fish* as my interactive shell
- *bash* for some scripts because it's more convenient than dash and more POSIX compliant
  than fish
Using org-tangle, I output the configs to the files they need to be in:

- =~/.profile= is sourced by login, making everything in it available to all shells.
- =~/.bashrc= is sourced by *bash* and *fish* (using the *bass* extension).
- The files =~/.alias= and =~/.alias-gui= contain aliases that I want available in
  all shells.

Additionally, =~/.alias-tmp= and  =~/.alias-gui-tmp= are not tangled from this file.
Instead I create them manually when needed to hold temporary aliases for the
purposes of experimentation. They are not under VCS.

* Fish
Note: I keep fish aliases in [[#alias-fish][Aliases]].
#+begin_src fish
  set fish_greeting ''
  [ -z "$EMACS_VTERM_PATH" ] && fish_vi_key_bindings || fish_default_key_bindings

  # Disable path shortening
  set fish_prompt_pwd_dir_length 0

  # I'm setting HOME to prevent errors when running inside tuterm
  type --quiet bass && HOME="/home/$USER" bass source ~/.bashrc # Load bash's config

  set -gx MANPAGER 'viman'                      # Set default pager to vim
  set -gx MANPATH  ":$__fish_data_dir/man"      # Add fish manpages to MANPATH
  set -gx MANWIDTH 80
  set -gx EDITOR 'editor'
  set -gx VISUAL 'visual-editor'
  set -gx PAGER 'less'
#+end_src
** Behavior overrides
*** =fish_prompt=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/fish_prompt.fish")
  function fish_prompt --description 'Write out the prompt'
      set -l last_pipestatus $pipestatus
      set -l normal (set_color normal)

      # Color the prompt differently when we're root
      set -l color_cwd $fish_color_cwd
      set -l prefix
      set -l suffix '$'
      if contains -- $USER root toor
          if set -q fish_color_cwd_root
              set color_cwd $fish_color_cwd_root
          end
          set suffix '#'
      end

      # If we're running via SSH, change the host color.
      set -l color_host $fish_color_host
      if set -q SSH_TTY
          set color_host $fish_color_host_remote
      end

      set -l prompt_status (__fish_print_pipestatus " [" "]" "|" \
          (set_color brred) (set_color --bold brred) $last_pipestatus)

      # Using a timeout here prevents hang on remotely mounted filesystems
      set -l vcs_prompt (timeout 0.2 fish --no-config -c fish_vcs_prompt 2>/dev/null)
      if [ (echo "$vcs_prompt" | wc -c) -gt 15 ]
          set vcs_prompt ''
      end

      set -l host
      if [ -n "$SSH_CONNECTION" ]
          set host "$normal"(set_color white)"[$hostname]"
      end

      echo -n -s  (set_color --bold brblue)   "$USER$host "                      \
                  (set_color magenta)         (prompt_pwd)        $normal  \
                  (set_color brmagenta)       "$vcs_prompt"                \
                  (set_color brmagenta)       $prompt_status               \
                  (set_color yellow)          " $suffix "
  end
#+end_src
**** =fish_mode_prompt=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/fish_mode_prompt.fish")
  function fish_mode_prompt
      [ -n "$EMACS_VTERM_PATH" ] && return
      switch $fish_bind_mode
          case default
              set_color --bold brred
              echo '[N] '
          case insert
              # Show nothing
          case replace_one
              set_color --bold green
              echo '[r] '
          case replace
              set_color --bold blue
              echo '[R] '
          case visual
              set_color --bold magenta
              echo '[V] '
          case '*'
              set_color --bold red
              echo '?'
      end
      set_color normal
  end

#+end_src
*** =fish_right_prompt=
Sends a graphical notification when a command running in a non-visible
context finishes. This applies to commands that are:
- running in a terminal emulator that is minimized or in a different workspace
- running without a terminal that can be accessed, e.g. launched via dmenu

This applies only to graphical sessions, the linux TTY is unaffected.
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/fish_right_prompt.fish")
  function fish_right_prompt
      [ -n "$HARIS_BACKGROUND_TASKS_SILENT" ] && return
      [ -n "$DISPLAY" ] || return

      set -l _status "$status"

      if ! type --quiet xdotool
          return 0
      end

      # Check if terminal window is hidden
      if xdotool search --all --onlyvisible "" 2>/dev/null | ! grep -q "$WINDOWID"
          set -l exit_message
          if [ "$_status" = 0 ]
              set exit_message "exited successfully"
          else
              set exit_message "exited with $_status"
          end
          # Timeout is so the command doesn't hang when daemon is not
          timeout 0.8 notify-send (echo "Command "(history | tac | tail -n +1 | tail -n +"$__haris_history_count" | head -1)"" "$exit_message")
          if [ "$status" = "124" ]
              echo ERR: NOTIFICATION TIMED OUT
          end
      end

      set -g __haris_history_count (history | wc -l)
  end
#+end_src
*** =edit_command_buffer_custom=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/edit_command_buffer_custom.fish")
  set -l actual_editor
  if which emacs >/dev/null
      set actual_editor emacs
  else
      set actual_editor nvim
  end

  functions edit_command_buffer |
      sed -E -e 's/^(function edit_command_buffer)/\1_custom/' \
             -e "s/(case.* $actual_editor\b)/\1 visual-editor /" \
      | source
#+end_src
** Bindings
:PROPERTIES:
:header-args:fish+: :tangle (haris/tangle-home ".config/fish/functions/fish_user_key_bindings.fish")
:END:
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/bind_both_modes.fish")
  function bind_both_modes
      bind -M default $argv
      bind -M insert $argv
  end
#+end_src
#+begin_src fish
  function fish_user_key_bindings               # Start bindings
#+end_src
*** Quasi-vim-like key bindings
#+begin_src fish
  bind_both_modes \el forward-char
  bind_both_modes \eh backward-char
  bind_both_modes \cp up-or-search
  bind_both_modes \cn down-or-search
#+end_src
*** Fish behavior control bindings
#+begin_src fish
  bind_both_modes \er src_fish

  # Some terminals like linux TTY and emacs vterm send Ctrl+P as \cP, so I enable
  # it only for alacritty which has been proven to work. I can add other terminals
  # here as needed.

  if [ "$TERM" = "alacritty" ]
      bind_both_modes \cP \
      '
      echo Starting private mode...;
      set fish_private_mode true;
      commandline -f repaint
      '
  end

  # Ctrl+L to clear screen
  bind_both_modes \cl 'clear; commandline -f repaint'
#+end_src
*** Utility bindings
#+begin_src fish
  # Copy the current contents of the command line
  bind_both_modes \ec 'commandline -b | xsel -b'

  # Run the current command in bash
  bind_both_modes \eb __haris_run_in_bash

  # Prepend o in front of current command
  bind_both_modes \eo '__haris_prepend_cmdline o'

  # Prepend man in front of current command
  bind_both_modes \em '__haris_show_man'

  # Append --help to the end of the command line and submit
  bind_both_modes \eH '__haris_print_help_or_toggle'

  bind_both_modes \et term

  bind_both_modes \eg 'dragon (command ls | fzf --multi) >/dev/null 2>&1'

  bind_both_modes \ee 'edit_command_buffer_custom'

  bind_both_modes \eE 'myemacs-float .'

  bind_both_modes \ea 'commandline -i "(adhoc)"'

  bind_both_modes \eA 'commandline -i "(adhoc - | string collect)"'

  bind_both_modes \eG 'magit'
  end                                          # End fish_user_key_bindings
#+end_src
**** Helper functions
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/__haris_run_in_bash.fish")
  function __haris_run_in_bash
      set -l cmd (commandline -b)
      echo
      eval bash -c "'source ~/.bashrc; $cmd'"
      commandline -f repaint
      commandline -r ''
  end
#+end_src
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/__haris_prepend_cmdline.fish")
  function __haris_prepend_cmdline
      commandline --cursor 0
      commandline --insert "$argv "
      commandline --function end-of-line
  end
#+end_src
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/__haris_show_man.fish")
  function __haris_show_man
      eman (commandline --current-process --tokenize | grep -v '^sudo$' | head -1)
  end
#+end_src
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/__haris_print_help_or_toggle.fish")
  function __haris_print_help_or_toggle
      if [ (commandline -o | tail -1) = "--help" ]
          commandline -r (commandline | string replace -r -- '\s*--help$' '')
          return
      end
      commandline --append " --help"
      commandline -f execute
  end
#+end_src
** Custom colors
#+begin_src fish
  set -U fish_color_command           brblue
  set -U fish_color_quote             brgreen
  set -U fish_color_param             brcyan
  set -U fish_color_autosuggestion    brblack
  set -U fish_color_cancel         -r red
  set -U fish_color_error             red
  set -U fish_color_comment           green
  set -U fish_color_operator          normal
  set -U fish_color_redirection       brmagenta
  set -U fish_pager_color_progress    brgreen
  set -U fish_pager_color_description green
  set -U fish_color_end               yellow
#+end_src
** Plugins
#+begin_src fish
  # pj plugin
  set -gx PROJECT_PATHS ~/proj ~/proj/drytoe

  # z.lua
  set _ZL_CMD z
  if type --quiet lua && [ -f /usr/share/z.lua/z.lua ]
      lua /usr/share/z.lua/z.lua --init fish | source
  end
  set -gx _ZL_CD cd

  # tem
  if type --quiet tem
      tem fish-init
  end

  # fzf bindings
  if type --quiet fzf_configure_bindings
      fzf_configure_bindings
  end
#+end_src
*** Dependencies
System packages:
#+begin_src text :tangle (haris/tangle-deps "fish/plugins.aur")
  fisher
#+end_src
#+begin_src text :tangle (haris/tangle-deps "fish/plugins.pacman")
  fish
  # Dependencies for fzf.fish
  fd bat
#+end_src
Fish plugins:
#+begin_src fish :tangle (haris/tangle-home ".config/fish/fish_plugins")
  edc/bass
  oh-my-fish/plugin-pj
  PatrickF1/fzf.fish
  jorgebucaran/nvm.fish
  evanlucas/fish-kubectl-completions
  # Fixes some vterm issues
  pymander/vfish
#+end_src
This code block installs all system dependencies and all plugins in fish based
on the plugin list above.
#+begin_src shell :tangle (haris/tangle-deps "fish/plugins.sh")
  touch ~/.config/fish/{private,tmp}.fish
  fish -c "fisher update"
#+end_src
** Functions
*** =ndir=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/ndir.fish")
  # Create a new dir and cd
  function ndir;  mkdir -p "$argv"; cd "$argv"; end
#+end_src
*** =1=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/1.fish")
  # Print first argument
  function 1; echo $argv[1]; end
#+end_src
*** =a=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/a.fish")
  # Run z through fzf
  function a
      z -l $argv | read -z choices
      set -l count (echo "$choices" | sed '/^$/d' | wc -l)
      set dest (echo "$choices" | sed '/^$/d' | tac | fzf --select-1)

      cd (echo "$dest" | sed -E -e '/^$/d' -e 's/^\S+\s+//')
  end
#+end_src
*** =open=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/open.fish")
  # Open a GUI app and disown
  function open; for file in $argv; o xdg-open "$file"; end; end
#+end_src
*** =imount=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/imount.fish")
  # Wrapper around imount script so I can cd to the mount directory
  function imount
      command imount $argv
      cd (cat /tmp/imount_directory)
  end
#+end_src
*** =vh=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/vh.fish")
  # Vim help
  function vh; vim -c ":h $argv | only"; end
#+end_src
*** =copypath=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/copypath.fish")
  # Save the path of the argument to the clipboard
  function copypath; realpath $argv | xsel -b; end
#+end_src
*** =ls=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/ls.fish")
  # When you ls, save the argument so you can quickly cd to that folder.
  # It's not fool-proof, but it works in most situations and it's safe.
  function ls
      if [ -z "$EMACS_VTERM_PATH" ] && type --quiet lsd
          # In emacs vterm, lsd outputs additional whitespace which is annoying
          lsd --color=auto $argv
      else
          command ls --color=auto $argv
      end
      set -g __last_ls_arg "$argv"
  end
#+end_src
*** =cdls=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/cdls.fish")
  # cd the last directory you have ls-ed
  function cdls
      [ -n "$__last_ls_arg" ] && cd "$__last_ls_arg"
  end
#+end_src
*** =vils=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/vils.fish")
  # vim the last file you have ls-ed
  function vils
      [ -n "$__last_ls_arg" ] && vim "$__last_ls_arg"
  end
#+end_src
*** =chbg=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/chbg.fish")
  function chbg
      set path /usr/share/backgrounds/"$argv[1]"
      feh --bg-fill "$path"
      rm ~/.wallpaper
      ln -s "$path" ~/.wallpaper
  end
#+end_src
**** Completions
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/chbg.fish")
  complete --command chbg --no-files --arguments="(pushd /usr/share/backgrounds/; command ls -1; popd)"
#+end_src
*** =vicmd=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/vicmd.fish")
  function vicmd
      set -l file (fcmd "$argv");
      if [ -f "$file" ]
          vim "$file"
      else
          read -n 1 -P "Create new script? [y/N]: " choice
          if [ "$choice" = 'y' ]
              myemacs-float ~/.haris/scripts.org
          else
              echo 'Aborting...'
              return 1
          end
      end
  end
#+end_src
*** =o=
#+NAME: o
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/o.fish") :eval no
  # Run a command and disown. Put it into a tmux session. Notify the user when done.
  # Persist a shell for a small time so the user can follow up on the command. If
  # the user doesn't follow up within 20 minutes, the background shell will exit
  # automatically.
  function o
      set -l __o_args $argv
      <<o/argparse>>
      set -l _status "$status"
      if [ "$_status" != 0 ]
          return "$_status"
      end

      if [ -n "$_flag_h" ]
          echo "Run a command in the background in a tmux session so its output can be inspected on-demand."
          echo "A GUI notification is sent when the command completes."
          echo "After the command completes, plus a certain linger period, the tmux session is killed."
          echo "The linger period can be adjusted with --linger-period or disabled with --persist."
          echo
          echo "Usage: o [OPTIONS] COMMAND..."
          echo
          echo "  -h, --help"        \t\t"Print this help message."
          echo "  -p, --persist "    \t\t"Persist the tmux session until manually killed."
          echo "  -l, --linger-period" \t"How long the tmux session should linger after the command completes."
          echo                     \t\t\t"Same format as for the sleep command. (default: 20m)"
          echo "  -s, --silent"      \t\t"Do not send a GUI notification when the command completes."
          return
      end

      # The remaining args contain only the command to be run (argparse options have been extracted)
      set -l __cmdline (string escape -- $argv)
      # The arguments are forwarded to the helper script, so it can parse them
      set -l __o_args (string escape -- $__o_args)

      tmux new -d fish --private -C "
      set HARIS_BACKGROUND_TASKS_SILENT $HARIS_BACKGROUND_TASKS_SILENT;
      set __o_args $__o_args;
      set __cmdline $__cmdline;"'
      <<o/background-task>>
      '
  end
#+end_src
**** Testing
Test the function by executing this code block:
#+NAME: o/test
#+begin_src fish :tangle no :cmdline --no-config
  <<o>>
  o --linger-period=3s sh -c '
      echo Simulating long command...;
      sleep 3s; echo Done.;
      echo The terminal window should close in a few seconds;
      echo "The exit code (\$status) should be 1!";
      false'
  alacritty-float -e tmux attach
#+end_src
**** Argparse block
#+NAME: o/argparse
#+begin_src fish :tangle no
  argparse \
    --stop-nonopt \
    --exclusive linger-period,persist \
    h/help \
    p/persist \
    l/linger-period= \
    s/silent \
    -- $__o_args
#+end_src
**** Background task and follow-up shell
Note: This code block must not contain any apostrophes!
#+NAME: o/background-task
#+HEADER: :shebang "#!/usr/bin/env fish"
#+begin_src fish :tangle no :eval no
  # Convert o options to local variables
  <<o/argparse>>
  set linger_period 20m
  if [ -n "$_flag_linger_period" ]
      set linger_period "$_flag_linger_period"
  end
  set persist "$_flag_persist"
  set silent "$HARIS_BACKGROUND_TASKS_SILENT"
  if [ -n "$_flag_silent" ]
      set silent "$_flag_silent"
  end

  functions -e fish_greeting
  # Run the command
  $__cmdline

  set __status "$status"
  set -l tmux_session (tmux display-message -p "#S")

  if [ -z "$silent" ] && [ -z "$(tmux list-clients -t "$tmux_session")" ]
      # Send a notification and wait for it to close. The reason we wait for it is
      # because if the user is AFK, then the follow-up shell would exit prematurely.
      # This way, if the user has set up notiication persistence while AFK, we
      # leverage that feature.
      # If a tmux session is already attached, the notification is not displayed.
      set -l notif_options
      if [ "$__status" != 0 ]; set -a notif_options "--urgency=critical"; end
      set -l notif_id_file (mktemp)
      # If a client attaches, the notification is no longer necessary and is immediately closed
      set -l hook (string escape run-shell "sh -c \"[ -n \"$notif_id_file\" ] && dunstify --close=\$(cat $notif_id_file)\"")
      tmux set-hook client-attached "$hook"

      unbuffer \
          notify-send "Background task done" \
          "$__cmdline exited with code $__status" \
          --wait --print-id $notif_options \
          2>/dev/null >"$notif_id_file"

      rm -f "$notif_id_file"
  end

  if [ -z "$persist" ]
      # Start a timeout for the shell to close if the user does not perform any
      # follow-up commands
      sh -c "sleep $linger_period; kill $fish_pid" &
      jobs --last --pid | read _timeout_pid
      disown

      function __haris_on_stop_interaction_timeout --on-event fish_preexec
          kill "$_timeout_pid"
          functions --erase __haris_on_stop_interaction_timeout
      end
  end

  function __haris_reproduce_status_code
      functions --erase __haris_reproduce_status_code
      return $__status
  end

  __haris_reproduce_status_code
#+end_src
**** Completions
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/o.fish")
  complete -c o --wraps command
#+end_src
*** =enved=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/enved.fish")
  function enved --argument envvar --description "Edit an environment variable by name"
      set tmp (mktemp /tmp/envvar-XXXXXXXXX)
      bass echo \$"$envvar" > "$tmp"
      "$EDITOR" "$tmp"
      bass export "$envvar"=(cat "$tmp")
      /usr/bin/rm -f "$tmp"
  end
#+end_src
*** =^=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/^.fish")
  function '^' -d "cd to the first directory in the hierarchy by specified name" -a name
      pushd "$PWD"
      while [ "$PWD" != "/" ]
          if [ (basename "$PWD") = "$name" ]
              set -l dir "$PWD"
              popd
              cd "$dir"
              return
          end
          cd ..
      end
      popd
      return 1
  end
#+end_src
**** Completions
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/^.fish")
  complete -c '^' -a '(pwd | tr "/" "\n")' -f
#+end_src
*** Miscellaneous others
#+begin_src fish
  function cdcf;   set -l file (cf "$argv");   test -f "$file" && cd (dirname        "$file"); end
  function catcf;  set -l file (cf "$argv");   test -f "$file" && cat                "$file" ; end
  function vicf;   set -l file (cf "$argv");   test -e "$file" && vim                "$file" ; end
  function ecf;    set -l file (cf "$argv");   test -e "$file" && myemacs-float "$file" ; end

  function cdcmd;  set -l file (fcmd "$argv"); test -f "$file" && cd (dirname "$file"); end
  function catcmd; set -l file (fcmd "$argv"); test -f "$file" && cat         "$file" ; end
  function ecmd;   set -l file (fcmd "$argv"); test -f "$file" && myemacs     "$file" ; end
  function rmcmd;  set -l file (fcmd "$argv"); rm "$file";                              end
#+end_src
**** =eman=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/eman.fish")
  function eman
      if [ -n "$DISPLAY" ] && emacsclient -s emacs --eval nil >/dev/null 2>&1
          command eman $argv
      else
          man $argv
      end
  end
#+end_src
** Completions
Function(s) that will be used by many completions.
Completions for the functions defined in [[Functions]].
#+begin_src fish :tangle (haris/tangle-home ".config/fish/functions/no_positional_args.fish")
  # Return success if the command line contains no positional arguments
  function no_positional_args
      set -l -- args    (commandline -po)         # cmdline broken up into list
      set -l -- cmdline (commandline -p)          # single string
      set -l -- n       (count $args)             # number of cmdline tokens
      for i in (seq 2 $n)
          set -l arg $args[$i]
          [ -z "$arg" ] && continue               # can be caused by '--' argument

          # If the the last token is a positional argument and there is no
          # trailing space, we ignore it
          [ "$i" = "$n" ] && [ (string sub -s -1 "$cmdline") != ' ' ] && break

          if string match -rvq '^-' -- "$arg"     # doesn't start with -
              return 1
          end
      end
      # contains a '--' argument
      string match -r -- '\s--\s' "$cmdline" && return 1
      return 0
  end
#+end_src
*** =snip=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/snip.fish")
  complete -c snip -f -a \
      "(pushd ~/.vim/snips; command ls | sed 's_\(.*\)\.snippets_\1_g'; popd)"
#+end_src
*** =adhoc=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/adhoc.fish")
  complete -c adhoc -f \
      -a "(complete -C'adsfadadflasdjflasdflnasdflasdu /tmp/adhoc-files/' | string replace /tmp/adhoc-files/ \"\")"
#+end_src
*** =pass=
#+begin_src fish :tangle (haris/tangle-home ".config/fish/completions/pass.fish")
  source /usr/share/fish/vendor_completions.d/pass.fish
  complete -c pass -a 'add' -n "no_positional_args"
  complete -c pass -a '(complete -C "pass show ")' -f -n '__fish_seen_subcommand_from add'
#+end_src
*** =otp=
#+begin_src shell :tangle (haris/tangle-home ".config/fish/completions/otp.fish")
    complete -c otp -a '(fd "otp-secret.gpg" ~/.password-store -x echo {//} | sed "s:^.*/\.password-store/\?::")' -f
#+end_src
*** Miscellaneous others
#+begin_src fish
  # *cf and *cmd style commands
  for cmd in {,cd,vi,cat,e}cf
      complete --command $cmd --no-files -a '(lscf)'
  end
  for cmd in {f,cd,vi,cat,e, rm}cmd
      complete -c $cmd -f \
          -a '(command ls -1 $PATH 2>/dev/null | grep -v "/")'
  end
#+end_src
** Private config
Private fish config is optional and must be provided separately as
[[~/.config/fish/private.fish]].
#+begin_src fish
  [ -f ~/.config/fish/private.fish ] && source ~/.config/fish/private.fish
#+end_src
* Bash
Note: =~/.bashrc= is sourced by fish as well.
#+begin_src bash :tangle (haris/tangle-home ".bashrc")
  PS1='\[\e[1;36m\]\u\[\e[1;31m\]@\[\e[1;34m\]\h \[\e[1;32m\]\W \[\e[1;31m\]\$ \[\e[0;32m\]\[\e[0m\]'

  [ -f ~/.alias ]         && source ~/.alias
  [ -f ~/.alias-tmp ]     && source ~/.alias-tmp
  [ -f ~/.alias-gui ]     && source ~/.alias-gui
  [ -f ~/.alias-gui-tmp ] && source ~/.alias-gui-tmp

  # Shell options
  shopt -s extglob
  shopt -s autocd
  shopt -s globstar

  {
  bind '"\C-p":previous-history'
  bind '"\C-k":previous-history'
  bind '"\C-n":next-history'
  bind '"\C-j":next-history'
  } 2>/dev/null

  export SHELL='fish'
  export MPD_HOST="localhost"
  export MPD_PORT="6601"

  if ! [[ "$PATH" =~ ~/\.local/bin ]]; then
      export PATH=~/.local/bin:"$PATH"
  fi
#+end_src
* Aliases
There are some aliases that I want to have available in all shells. I break
them up into two groups: aliases for CLI (~~/.alias~) and aliases GUI programs
(~~/.alias-gui~). I make this distinction because my custom ~dmenu_run~ script
takes all the aliases from the latter and I can run them as normal programs.
Both files have a variant suffixed by ~-tmp~ in which I keep temporary aliases
and I do not keep them under version control.

It makes no sense to launch CLI programs from dmenu. Still, I make aliases
from ~~/.alias~ available in ~dmenu_run~. When I enter them in dmenu, it launches
a terminal and runs the aliased command.
** CLI
#+begin_src shell :tangle (haris/tangle-home ".alias")
  alias x='startx'
  alias vim='nvim'
  alias vi='command vim'
  alias snips='cd ~/.vim/snips'
  alias vidir='VISUAL=nvim command vidir'
  alias cppman='PAGER=viman command cppman'
  alias aurvote='ssh aur@aur.archlinux.org vote'
  alias ...='cd ../..'
  alias l1='ls -1'
  alias src='cd ~/src'
  alias tmp='cd /tmp'
  alias stage='mkdir -p /tmp/stage-"$USER"; cd /tmp/stage-"$USER"'
  alias bin='cd ~/.local/bin'
  alias usb='cd ~/mnt/usb'
#+end_src
** GUI
#+begin_src shell :tangle (haris/tangle-home ".alias-gui")
  alias calc='speedcrunch'
  alias screenkey='screenkey --bg-color "#99a3ff" --font-color "#1e1e1e"'
  alias VirtualBox="QT_QPA_PLATFORMTHEME=qt command VirtualBox"
  alias ff="firefox"
#+end_src
** Fish
:PROPERTIES:
:CUSTOM_ID: alias-fish
:END:
*** Aliases
#+begin_src fish
  alias src_fish  'source ~/.config/fish/config.fish'
  alias term      'term & disown'
  if command --quiet docker
      alias alpine    'docker run -it --rm --name alpine alpine'
      alias debian    'docker run -it --name debian debian:bookworm-slim'
  end

  function dragon; dragon-drag-and-drop $argv & disown; end
  function vrg --wraps rg; vim (rg -l $argv); end
  function vfd --wraps fd; vim (fd $argv); end
#+end_src
*** Abbreviations
#+begin_src fish
  # Safety precautions
  abbr -g rm 'rm -i'
  abbr -g mv 'mv -i'

  # Error correction
  abbr -g claer 'clear'
  abbr -g pas   'pass'
  abbr -g gs    'git status'

  function _if_pacman_else
      if command --quiet pacman
          echo "$argv[1]"
      else
          echo "$argv[2]"
      end
  end

  # Pacman commands
  abbr -g p     (_if_pacman_else 'pacman'         'apt')
  abbr -g pq    (_if_pacman_else 'pacman -Q'      'apt list --installed')
  abbr -g pqq   (_if_pacman_else 'pacman -Qq'     'apt list --installed')
  abbr -g pqi   (_if_pacman_else 'pacman -Qi'     'dpkg --status')
  abbr -g pql   (_if_pacman_else 'pacman -Ql'     'dpkg --listfiles')
  abbr -g pqm   (_if_pacman_else 'pacman -Qm')
  abbr -g pqe   (_if_pacman_else 'pacman -Qe')
  abbr -g pqo   (_if_pacman_else 'pacman -Qo'     'apt-file search --regexp')
  abbr -g pqs   (_if_pacman_else 'pacman -Qs')
  abbr -g psi   (_if_pacman_else 'pacman -Si'     'apt-cache show')
  abbr -g pss   (_if_pacman_else 'pacman -Ss'     'apt search')
  abbr -g pqdtq (_if_pacman_else 'pacman -Qdtq')
  abbr -g sp    (_if_pacman_else 'sudo pacman'    'sudo apt')
  abbr -g sps   (_if_pacman_else 'sudo pacman -S' 'sudo apt install')
  abbr -g spr   (_if_pacman_else 'sudo pacman -R' 'sudo apt remove')
  abbr -g sprq  (_if_pacman_else 'sudo pacman -R (pacman -Qdtq)' 'sudo apt autoremove')

  functions --erase _if_pacman_else

  # Systemd
  abbr -g ctl       'sudo systemctl'
  abbr -g start     'sudo systemctl start'
  abbr -g stop      'sudo systemctl stop'
  abbr -g en        'sudo systemctl enable'
  abbr -g dis       'sudo systemctl disable'
  abbr -g sts       'systemctl status'
  abbr -g drel      'sudo systemctl daemon-reload'
  abbr -g rel       'sudo systemctl reload'
  abbr -g res       'sudo systemctl restart'
  abbr -g sus       'systemctl suspend'
  abbr -g j         'journalctl -f -u'
  #   --user versions
  abbr -g ctlu      'systemctl --user'
  abbr -g startu    'systemctl start --user'
  abbr -g stopu     'systemctl stop --user'
  abbr -g enu       'systemctl enable --user'
  abbr -g disu      'systemctl disable --user'
  abbr -g stsu      'systemctl status --user'
  abbr -g drelu     'systemctl daemon-reload --user'
  abbr -g relu      'systemctl reload --user'
  abbr -g resu      'systemctl restart  --user'
  abbr -g ju        'journalctl --user -f -u'

  # Docker
  abbr -g d    'docker'
  abbr -g db   'docker build'
  abbr -g dr   'docker run'
  abbr -g drit 'docker run -it'
  abbr -g deit 'docker exec -it'
  abbr -g drm  'docker rm -f'
  abbr -g dcl  'docker container list'
  abbr -g dc   'docker-compose'
  abbr -g dcub 'docker-compose up --build'
  abbr -g dce  'docker-compose exec'
  abbr -g dcd  'docker-compose down'

  # VirtualBox
  abbr -g vb   'vboxmanage'

  # Misc
  abbr -g g     'git'
  abbr -g e     'myemacs -c'
  abbr -g E     'myemacs'
  abbr -g s     'sudo'
  abbr -g paru  'paru'
  abbr -g py    'python'
  abbr -g ipy   'ipython'
  abbr -g copy  'xsel -b'
  abbr -g paste 'xsel -b -o'
  abbr -g oct   'octave'
  abbr -g octb  'OCTAVE_BASIC=true command octave'
  abbr -g va    'vagrant'
  abbr -g u     'fusermount -u'
  abbr -g um    'sudo umount'
  abbr -g cmd   'command'
  abbr -g w     'watch -n0.1'
  abbr -g P     "pgrep -afu "(whoami)
  abbr -g yt    'ytfzf -t -s'
  abbr -g t     'tem'
  abbr -g v     'vim'
  abbr -g vf    'vim (fzf)'
  abbr -g fm    'vifm'
  abbr -g fb    'facebook-cli'
  abbr -g fl    'flameshot'
  abbr -g tb    'nc termbin.com 9999'
  abbr -g asc   'asciinema'
  abbr -g priv  'fish --private'
  abbr -g hk    'heroku'
  abbr -g mhc   'man http-codes'
  abbr -g rgh   'rg --hidden'
  abbr -g px    'ping x'
  abbr -g ii    'curl ipinfo.io'
  abbr -g bt    'bluetoothctl'
  abbr -g man   'eman'

  # Pass
  abbr -g pn 'pass insert'
  abbr -g pg 'pass generate --clip'
  abbr -g pe 'pass edit'
  abbr -g pc 'pass show --clip'

  # Google cloud
  abbr -g gce 'gcloud compute'

  # Tmux
  abbr -g x   'tmux'
#+end_src
*** Variables
#+begin_src fish
  set aur 'aur@aur.archlinux.org'
#+end_src
* .profile
#+begin_src shell :tangle (haris/tangle-home ".profile")
  export PATH=~/.local/bin:$PATH:~/.pyenv/versions/3.8.3/bin:~/mnt/vm/.tem/path:/opt/android-sdk/emulator

  export MAKEFLAGS='-j6'
  export GPG_TTY=$(tty)
  export PYTHONSTARTUP=~/.startup.py
  export RUSTC_WRAPPER=sccache
  export MOZ_USE_XINPUT2=1
  [ "$(get-os-type)" = "arch" ] && export QT_QPA_PLATFORMTHEME=gtk2

  mkdir -p /tmp/stage-"$USER"

  [ -f ~/.alias ]           && . ~/.alias
  [ -f ~/.alias-tmp ]       && . ~/.alias-tmp
  [ -f ~/.alias-gui ]       && . ~/.alias-gui
  [ -f ~/.alias-gui-tmp ]   && . ~/.alias-gui-tmp
  [ -f ~/.profile-private ] && . ~/.profile-private
#+end_src
* Temporary configs
[[~/.config/fish/tmp.fish][Click to edit]]
#+begin_src fish
  [ -f ~/.config/fish/tmp.fish ] && source ~/.config/fish/tmp.fish
#+end_src
* Dependencies
#+begin_src text :tangle (haris/tangle-deps "shells.pacman")
  dash fish
#+end_src
