#+TITLE: Scripts
#+SETUPFILE: .setup.org
#+PROPERTY: header-args+
#+PROPERTY: header-args:shell+ :comments both
#+PROPERTY: header-args:bash+ :comments both
#+TAGS: wrapper(w) script(s)

This is where my custom scripts live. That includes shell scripts, dmenu
scripts, and potentially programming-language-specific scripts. One of the
things I strive for is to have the same script available in different
environments. For example, I have a dmenu script for creating a QR code, which
allows me to scan or generate a QR code with a few keystrokes. But sometimes I
want to call this script from a terminal, so I also have a =qr= command available
in =~/.local/bin=. Likewise, I have ideas to port some scripts to tridactyl (a
firefox extension) as well. Since those different versions of the same script
differ only by UX, it is useful to have all the versions defined in the same
place - here.

Note: For code reusability, I use some [[* Helper code][helper code blocks]] defined at the bottom
of this document. These code blocks are utilized via =org-sbe= or via noweb references.

* Wrappers around existing commands
** =git=                                                             :wrapper:
#+begin_src bash :tangle ~/.local/bin/git
  git() {
      alternative-command git "$@"
  }

  git_root="$(git root 2>/dev/null)"
  if [ "$git_root" = ~ ]; then
      if [ "$PWD" = ~ ] || [[ "${PWD#~/}" =~ ^\. ]]; then
          git "$@"
      else
          export GIT_CEILING_DIRECTORIES=~
          git "$@"
      fi
  else
      git "$@"
  fi
#+end_src
** =rm=                                                              :wrapper:
#+begin_src shell :tangle ~/.local/bin/rm
  for arg in "$@"; do
      [ ! -e "$arg" ] && continue
      arg="$(realpath "$arg")"
      if echo "$arg" \
              | grep -q '^/home' && echo "$arg" \
                  | grep -qv '^/home/[^/]\+/[^/]\+'
      then
          echo "WTF: Trying to delete a home directory???"
          exit 1
      fi
  done
  /usr/bin/rm "$@"
#+end_src
** =pass=                                                            :wrapper:
This is a wrapper around GNU =pass=.
#+begin_src bash :tangle ~/.local/bin/pass
  shopt -s expand_aliases

  # TODO: Use alternative-command instead
  alias pass=/usr/bin/pass

  clipctl_previous_status="$(clipctl status || echo enable)"

  clipctl disable >/dev/null || true

  exit_status=0

  # Add a password read directly from stdin (without prompting to interactively
  # enter it)
  if [ "$1" = "add" ]; then
      dest=~/.password-store/"$2"
      destdir="$(dirname "$dest")"
      mkdir -p "$destdir"
      cat | gpg -e -o- -r "$(cat ~/.password-store/.gpg-id)" > "$dest".gpg
      exit_status=$?
  else
      pass "$@"
      exit_status=$?
  fi

  clipctl "$clipctl_previous_status" >/dev/null || true

  exit $exit_status
#+end_src
** =passmenu=                                                        :wrapper:
This is a wrapper around =passmenu=, trying to use =passmenu-otp= if present,
otherwise falling back to the default =passmenu=.
#+begin_src bash :tangle ~/.local/bin/passmenu
  if command -v passmenu-otp >/dev/null; then
      passmenu-otp "$@"
  else
      alternative-command passmenu "$@"
  fi
#+end_src
** =dmenu=                                                           :wrapper:
Note: This depends on my custom build of dmenu with the height patch applied.
The PKGFILE can be found [[https://github.com/veracioux/aur][here]].
#+NAME: dmenu
#+begin_src shell :tangle ~/.local/bin/dmenu
  alternative-command dmenu -b -f -i -h 25 \
      -nb '#1e1e1e' -nf '#dddddd' -sb '#99a3ff' -sf '#1e1e1e' \
      -fn 'Ubuntu Mono-12' \
      "$@"
#+end_src
** =ipython=                                                         :wrapper:
#+begin_src bash :tangle ~/.local/bin/ipython
  /usr/bin/ipython "$@" -i -- "$PYTHONSTARTUP"
#+end_src
** =gvim=                                                            :wrapper:
#+begin_src bash :tangle ~/.local/bin/gvim
  # Fake gvim which will just launch a terminal with neovim in it

  for arg in "$@"; do
      # Hacky solution that will open files in real gvim when opened by xdg-open
      if [ "$arg" = "-f" ]; then /usr/bin/gvim "$@"; exit; fi
  done

  # nvim is launched through the shell because otherwise it behaves weirdly
  # All arguments are surrounded with ''
  FISH_CMD="$(printf "%q " nvim "$@")"

  if [ ! -t 0 ]; then
      # Input is from a PIPE
      pipe_input="$(mktemp -t XXXXXXXXXXXXXXXX)"
      cat > "$pipe_input"
      FISH_CMD="cat $pipe_input | $FISH_CMD"
  fi

  alacritty --class Alacritty,Float -e fish -C "$FISH_CMD"

  if [ ! -t 0 ]; then
      # Input is from a PIPE
      rm -f "$pipe_input"
  fi
#+end_src
** =redshift=                                                        :wrapper:
#+begin_src shell :tangle ~/.local/bin/redshift
  /usr/bin/redshift -l 43.84:18.35
#+end_src
** =firefox=                                                         :wrapper:
#+begin_src shell :tangle ~/.local/bin/firefox
  if [ -n "$VSCODE_PID" ]; then
      args="$(printarg "$@" | uniq)"
  else
      args="$(printarg --new-tab "$@" | uniq)"
  fi

  if [ "$(get-os-type)" = ubuntu ] && [ -e ~/.local/opt/firefox ]; then
      ~/.local/opt/firefox/firefox $args
      exit
  fi

  alternative-command firefox $args
#+end_src
** =myemacs=                                                         :wrapper:
#+begin_src bash :tangle ~/.local/bin/myemacs
  # Run emacsclient in the terminal, unless the -c option is given, which will
  # open the GUI.
  # - Also enables proper color support.
  # - Any additional arguments you provide are passed to emacsclient

  export TERM='xterm-256color'
  create_frame=""
  socket_name=""
  modified_options=()

  print_help() {
      emacsclient --help
      echo
      echo "CUSTOM OPTIONS:"
      echo -e "--wait \t\t\tOverride --no-wait if it would otherwise be in effect"
      echo -e "--no-tty \t\tUndoes the effects of --tty"
  }

  declare -A custom_options_map

  # Get custom option named $1 (success code = on, error code = off)
  # If $2 is given, then the option named $1 is set to the truth
  # value of $2 (empty is false, non-empty is true)
  custom_option() {
      if [ "$#" = 2 ]; then
          custom_options_map["$1"]="$2"
      else
          [ -n "${custom_options_map["$1"]}" ]
      fi
  }

  # Since this is a wrapper around emacsclient, we need to parse and pass through
  # all options that emacsclient recognizes
  parsed_args="$(
      getopt --name "$BASH_SOURCE" \
          --options "h"VHtcrF:enw:qud:s:f:a:T: \
          --long "wait,no-tty",version,help,tty,create-frame,reuse-frame,frame-parameters:,eval,no-wait,timeout:,quiet,suppress-output,display:,parent-id:,socket-name:,server-file:,alternate-editor:,tramp: \
          -- "$@"
  )"

  eval set -- "$parsed_args"

  while :; do
      case "$1" in
          -h | --help)
              print_help
              exit ;;
          -c | --create-frame)
              create_frame="true"
              modified_options+=("$1")
              shift 1 ;;
          -s | --socket-name)
              modified_options+=("$1" "$2")
              socket_name="$2"
              shift 2 ;;
          --no-wait)
              custom_option wait ""
              shift 1 ;;
          --wait)
              custom_option wait "true"
              shift 1 ;;
          -t | --tty)
              custom_option tty "true"
              shift 1 ;;
          --no-tty)
              custom_option tty ""
              shift 1 ;;
          --)
              shift 1
              break ;;
          ,*)
              modified_options+=("$1")
              shift 1 ;;
      esac
  done

  if [ ! -t 0 ]; then
      custom_option wait ""
  fi

  # Set reasonable default values for --tty option and --no-wait option
  # based on --create-frame.
  if [ ! -v custom_options_map["tty"] ]; then
      custom_option tty "$([ -z "$create_frame" ] && echo true)"
  fi
  if [ ! -v custom_options_map["wait"] ]; then
      custom_option wait "$([ -z "$create_frame" ] && echo true)"
  fi

  if custom_option tty; then
      modified_options+=(--tty)
  fi

  if ! custom_option wait; then
      modified_options+=(--no-wait)
  fi

  if [ -z "$socket_name" ]; then
      modified_options+=(--socket-name emacs)
  fi

  emacsclient() {
      exec -a "$BASH_SOURCE" command emacsclient "$@"
  }

  set -- "${modified_options[@]}" -- "$@"

  if [ ! -t 0 ]; then
      file="$(mktemp /tmp/haris-pipe-XXXXXXXX)"
      tee "$file" <&0 >/dev/null &
      bg_pid="$!"
      set -- "$@" "$file"
      trap "kill $bg_pid &>/dev/null" EXIT INT ERR
  fi

  exec -a "$BASH_SOURCE" emacsclient \
       --alternate-editor ~/.local/lib/haris/emacs-alternate-editor \
       "$@"

  if [ -n "$bg_pid" ]; then
      wait "$bg_pid"
  fi
#+end_src
*** Helper program
#+begin_src bash :tangle ~/.local/lib/haris/emacs-alternate-editor
  is_running() {
      emacsclient --no-wait --socket-name emacs --eval '(ignore)' >/dev/null 2>&1
  }

  id="$(notify-send --print-id "Emacs" "Starting daemon...")"
  systemctl restart --user emacs
  until is_running; do
      sleep 2s
  done
  notify-send --print-id --replace-id="$id" "Emacs" "Daemon ready"
#+end_src
*** Shell completion
#+begin_src fish :tangle ~/.config/fish/completions/myemacs.fish
  complete -c myemacs --wraps emacsclient
  complete -c myemacs --long "wait" --description "Override --no-wait if it would otherwise be in effect"
#+end_src
** =myemacs-float=                                                 :wrapper:
#+begin_src shell :tangle ~/.local/bin/myemacs-float
  myemacs -c --frame-parameters='(quote (name . "EmacsFloat"))' "$@"
#+end_src
** =notify-send=                                                   :wrapper:
#+begin_src shell :tangle ~/.local/bin/notify-send
  export DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/<<eval-real-uid()>>/bus"

  # If notify-send can't communicate, it blocks. That's the reason for the timeout
  timeout 1s alternative-command notify-send "$@"
#+end_src
** =sudo=                                                          :wrapper:
#+NAME: sudo
#+begin_src bash :tangle ~/.local/bin/sudo
  # Sudo but with a hook that sends a notification when the prompt is shown

  # TODO: Not robust enough. What if the wrapped command itself accepts a --stdin flag?

  if [ -z "$SUDO_ASKPASS" ] && [[ ! "$*" =~ --stdin ]] && [[ ! "$*" =~ -S ]]; then
      export SUDO_ASKPASS="$(mktemp)"
      chmod u+x "$SUDO_ASKPASS"
      cat > "$SUDO_ASKPASS" <<'EOF'
  <<sudo-askpass>>
  EOF
      trap "rm -f $SUDO_ASKPASS" EXIT
      alternative-command sudo --askpass "$@"
  else
      alternative-command sudo "$@"
  fi
#+end_src
#+NAME: sudo-askpass
#+begin_src shell :tangle no
  #!/usr/bin/env sh
  askpass "[sudo] password for $(getent passwd "$USER" | cut -d: -f1)" "SUDO password" "Please enter your password"
#+end_src
** =ssh=                                                           :wrapper:
#+begin_src bash :tangle ~/.local/bin/ssh
  # This checks whether ssh is run via sshpass or perhaps some other tool that
  # assigns its own terminal to ssh.
  is_tty_available() {
      { : >/dev/tty; } &>/dev/null
  }

  if [ -z "$SSH_ASKPASS" ] && is_tty_available; then
      export SSH_ASKPASS="$(mktemp)"
      export SSH_ASKPASS_REQUIRE="prefer"
      chmod u+x "$SSH_ASKPASS"
      cat > "$SSH_ASKPASS" <<'EOF'
  <<ssh-askpass>>
  EOF
      trap "rm -f $SSH_ASKPASS" EXIT
  fi

  alternative-command ssh "$@"
#+end_src
#+NAME: ssh-askpass
#+begin_src shell
  # The default prompt supplied as call args
  prompt="$(echo "$1" | sed 's/: $//')"
  askpass "$prompt" "SSH passphrase" "Please enter SSH passphrase"
#+end_src
** =alacritty=                                                     :wrapper:
#+begin_src shell :tangle ~/.local/bin/alacritty
  alternative-command alacritty "$@"
  #+end_src
** =alacritty-float=                                               :wrapper:
#+begin_src shell :tangle ~/.local/bin/alacritty-float
  alacritty --class Alacritty,Float "$@"
#+end_src
** =sway=                                                          :wrapper:
#+begin_src shell :tangle ~/.local/bin/sway
  export XDG_CURRENT_DESKTOP=Sway
  /usr/bin/sway --unsupported-gpu "$@"
#+end_src
** =xlock=                                                         :wrapper:
#+begin_src shell :tangle ~/.local/bin/xlock
  pkill gpg-agent 2>/dev/null
  alternative-command xlock "$@"
#+end_src
** =vscode=                                                        :wrapper:
The name =code= is a bit too generic. I need something more specific in order to
get better search matches.
#+begin_src shell :tangle ~/.local/bin/vscode
  code "$@"
#+end_src
** =lnav=                                                          :wrapper:
#+begin_src shell :tangle ~/.local/bin/lnav
  export TERM=xterm-256color

  # alternative-command lnav "$@"
  /usr/bin/lnav "$@"
#+end_src
** =clipmenu=                                                      :wrapper:
#+begin_src shell :tangle ~/.local/bin/clipmenu
  alternative-command clipmenu "$@"
#+end_src
** =clipctl=                                                       :wrapper:
#+begin_src bash :tangle ~/.local/bin/clipctl
  set -e

  if [ "$#" -ne 1 ]; then
      echo "Usage: $0 enable|disable|status|tmp-disable"
      echo "  enable: enable clipboard synchronization"
      echo "  disable: disable clipboard synchronization"
      echo "  status: shows the current clipboard synchronization status"
      echo "  tmp-disable: disable clipboard synchronization for the current shell pipeline, cat stdin to stdout"
      exit 1
  fi

  status_file="$XDG_RUNTIME_DIR/haris/clipctl-status"
  mkdir -p "$(dirname "$status_file")"

  previous_state="$(cat "$status_file" 2>/dev/null || echo "enable")"

  # Perform action
  if [ "$1" = "enable" ] || [ "$1" = "disable" ]; then
      alternative-command clipctl "$1"
      echo "$1" > "$status_file"
  elif [ "$1" = "status" ]; then
       echo "$previous_state"
  elif [ "$1" = "tmp-disable" ]; then
      if [ "$previous_state" = "disable" ]; then
          alternative-command clipctl disable >/dev/null # Just making sure
          cat
      else
          alternative-command clipctl disable >/dev/null
          cat
          re_enable() {
              sleep 0.2s
              alternative-command clipctl "$(cat "$status_file" 2>/dev/null || echo "enable")" >/dev/null
          }
          export -f re_enable
          nohup bash -c re_enable &>/dev/null &
      fi
  else
      echo "Invalid argument: $1"
      exit 1
  fi
#+end_src
*** Completions
#+begin_src fish :tangle ~/.config/fish/completions/clipctl.fish
  complete -c clipctl -f -a "enable" -d "Enable clipboard synchronization"
  complete -c clipctl -f -a "disable" -d "Disable clipboard synchronization"
  complete -c clipctl -f -a "status" -d "Show the current clipboard synchronization status"
  complete -c clipctl -f -a "tmp-disable" -d "Disable clipboard synchronization for the current shell pipeline; cat"
#+end_src
** =docker-compose=                                                :wrapper:
#+begin_src bash :tangle ~/.local/bin/docker-compose
  if grep -q 'down.*--volumes' <<<"$*"; then
      echo 'Option --volumes used. Make sure this is the intended compose project'
      echo -e "COMPOSE_PROJECT_NAME: \e[1;31m $COMPOSE_PROJECT_NAME\e[0m"
      read -p "Are you sure? [y|N]: " -n 1 answer
      if [ "$answer" != "y" ]; then
          echo
          echo "Aborting."
          exit 1
      fi
  fi

  if [ "$(which -a docker-compose | uniq | wc -l)" -gt 1 ]; then
      alternative-command docker-compose "$@"
  else
      docker compose "$@"
  fi
#+end_src
** =ngrok=                                                         :wrapper:
#+begin_src shell :tangle ~/.local/bin/ngrok
  export TERM=xterm-256color
  alternative-command ngrok "$@"
#+end_src
** =teams=                                                         :wrapper:
#+begin_src shell :tangle ~/.local/bin/teams
  flatpak_name="com.github.IsmaelMartinez.teams_for_linux"

  if [ "$(which -a teams | uniq | wc -l)" -gt 1 ]; then
      alternative-command teams "$@"
  elif [ "$(which -a teams-for-linux | uniq | wc -l)" -gt 0 ]; then
      teams-for-linux "$@"
  elif flatpak info "$flatpak_name" >/dev/null 2>&1; then
       flatpak run "$flatpak_name"
  else
      echo "Teams is not installed. Tried:" >&2
      printf '    %s\n' teams teams-for-linux "Flatpak: $flatpak_name"
  fi
#+end_src
** =yarn=                                                          :wrapper:
#+begin_src shell :tangle ~/.local/bin/yarn
  if [ "$(which -a yarn | uniq | wc -l)" -gt 1 ]; then
      alternative-command yarn "$@"
  else
      yarnpkg "$@"
  fi
#+end_src
** =iredis=                                                        :wrapper:
#+begin_src shell :tangle ~/.local/bin/iredis
  export PAGER=cat
  alternative-command iredis "$@"
#+end_src
** =VirtualBox=                                                    :wrapper:
#+begin_src shell :tangle ~/.local/bin/VirtualBox
  export QT_QPA_PLATFORMTHEME=qt
  alternative-command VirtualBox "$@"
#+end_src
** =screenkey=                                                     :wrapper:
#+begin_src shell :tangle ~/.local/bin/screenkey
  alternative-command screenkey --bg-color "#99a3ff" --font-color "#1e1e1e" "$@"
#+end_src
** =fzf=                                                           :wrapper:
#+begin_src shell :tangle ~/.local/bin/fzf
  alternative-command fzf --layout=reverse "$@"
#+end_src
** =opencode=                                                      :wrapper:
#+begin_src shell :tangle ~/.local/bin/opencode
  if [ "$(pwd)" = ~ ]; then
      cd ~/.empty/
  fi
  bunx opencode-ai@latest "$@"
#+end_src
* Utilities
** =visual-editor=
#+begin_src shell :tangle ~/.local/bin/visual-editor
  if xprop -id "$WINDOWID" | grep -q _NET_WM_STATE_FULLSCREEN; then
      myemacs --wait "$@"
  elif which myemacs-float >/dev/null; then
      myemacs-float --wait "$@" >/dev/null
  else
      editor "$@"
  fi
#+end_src
** =editor=
#+begin_src shell :tangle ~/.local/bin/editor
  exists() {
      which "$1" >/dev/null
  }
  if exists myemacs; then
      myemacs "$@"
  elif exists nvim; then
      nvim "$@"
  elif exists vim; then
      vim "$@"
  elif exists nvim; then
      vi "$@"
  fi
#+end_src
** =abspath=
#+begin_src bash :tangle ~/.local/bin/abspath
  pushd "$(dirname "$1")" >/dev/null
  echo "$PWD/$(basename "$1")"
  popd >/dev/null
#+end_src
** =askpass=
#+begin_src bash :tangle ~/.local/bin/askpass
  # Usage: askpass [PROMPT] [WINDOW_TITLE] [NOTIFICATION]

  prompt="$1"
  window_title="$2"
  notification="$3"

  if [ "$TERM" != "dumb" ]; then
      if [ -n "$DISPLAY" ]; then
          id="$(notify-send "$window_title" "$notification" --print-id --expire-time 0)"
          trap "dunstify --close=$id" EXIT
      fi
      echo -n "$prompt: " >/dev/tty

      stty -echo </dev/tty
      head -1 </dev/tty | tr -d '\n'

      echo >/dev/tty
  else
      {
          echo SETTITLE "$window_title"
          echo SETDESC "$prompt"
          echo SETPROMPT Password:
          echo GETPIN
          echo BYE
      } | pinentry -g 2>&1 | sed -n "/^D/ s/^D //p" | tr -d '\n'
  fi
#+end_src
** =askpass-gui=                                                    :script:
#+begin_src bash :tangle ~/.local/bin/askpass-gui
  TERM=dumb askpass "$@"
#+end_src
** =chx=
#+begin_src shell :tangle ~/.local/bin/chx
  chmod u+x "$@"
#+end_src
** =diffgpg=
#+begin_src bash :tangle ~/.local/bin/diffgpg
  # Compare the contents of two GPG encrypted files

  diff <(gpg --decrypt --output - "$1") <(gpg --decrypt --output - "$2") "${@:3}"
#+end_src
** =diffpiped=                                                      :script:
#+begin_src bash :tangle ~/.local/bin/diffpiped
  # Diff two files named $1 and $2, piped through a command given as the remaining
  # arguments.

  options=()

  for arg in "$@"; do
      if [[ "$arg" =~ ^- ]]; then
          options=("${options[@]}" "$arg")
          shift
      else
          break
      fi
  done

  file1="$1"
  file2="$2"

  shift 2

  tmp1="$(mktemp)"
  tmp2="$(mktemp)"

  cat "$file1" | "$@" > "$tmp1"
  cat "$file2" | "$@" > "$tmp2"

  diff --color=auto "${options[@]}" "$tmp1" "$tmp2"

  rm -f "$tmp1" "$tmp2"
#+end_src
#+NAME: diffpiped/test
#+begin_src bash :tangle no
  diffpiped --strip-trailing-cr <(echo -e "a\nb") <(echo -e "a\nB") sed 's/a/A/g'
#+end_src
** =fcmd=
#+begin_src bash :tangle ~/.local/bin/fcmd
  type "$@" 2>/dev/null | awk '{print $3}'
  exit "${PIPESTATUS[0]}"
#+end_src
** =lscf=
Parses the contents of the [[*=cf=][cf]] script to obtain all the configurations that can
be listed using it. In addition it shows the =*.org= files in [[~/.haris/]].
#+begin_src shell :tangle ~/.local/bin/lscf
  for f in ~/.haris/*.org; do
      basename "$f"
  done
  cat $(fcmd cf) | sed -n 's/\s*\([^\*]\+\)).*/\1/p'
#+end_src
** =ls-wallpapers=
#+begin_src bash :tangle ~/.local/bin/ls-wallpapers
  lookup_dirs=(
      ~/.local/share/wallpapers
      ~/.local/share/backgrounds
      /usr/local/share/wallpapers
      /usr/local/share/backgrounds
      /usr/share/wallpapers
      /usr/share/backgrounds
  )

  fd . "${lookup_dirs[@]}" 2>/dev/null
#+end_src
** =n=
#+begin_src shell :tangle ~/.local/bin/n
  # Print n of the received arguments, where n=$1

  [ "$#" = 0 ] && exit 1

  num="$1"
  shift
  printarg $(printarg "${@}" | head -"$num")
#+end_src
** =printarg=
#+begin_src bash :tangle ~/.local/bin/printarg
  # Print commandline arguments passed to this function each on its own line
  printf "%q\n" "$@"
#+end_src
** =rmws=
#+begin_src shell :tangle ~/.local/bin/rmws
  # Remove whitespace from a file (or stdin if input is from a pipe) and write the
  # output to stdout (or rewrite the file if the -i option is given)

  [ ! -t 0 ] &&\
      cat | sed 's:\s\+$::' ||\
          sed 's:\s\+$::' "$@"
#+end_src
** =trim=
#+begin_src shell :tangle ~/.local/bin/trim
  # Remove trailing newline from stdin

  echo -n "$(cat)"
#+end_src
** =adhoc=
#+begin_src bash :tangle ~/.local/bin/adhoc
  # Create an ad-hoc file, edit it in $EDITOR and then print its path. If a '-'
  # argument is given, the file contents are printed instead of its path.

  destdir="/tmp/adhoc-files"
  mkdir -p "$destdir"
  cd "$destdir"

  if [ "$#" != 0 ] && [ "$1" = "-" ]; then
      print_content=true
      files=("${@:2}")
  else
      files=("$@")
  fi

  # Convert files to realpaths
  readarray -t files < <(realpath "${files[@]}" 2>/dev/null)

  if [ -z "$files" ]; then
      files=("$(mktemp "$destdir"/XXXXXXXXXXX)")
  fi

  myemacs-float --wait "${files[@]}" >&2

  if [ -n "$print_content" ]; then
      cat "${files[@]}"
  else
      realpath "${files[@]}"
  fi
#+end_src
** =cmd-with-notify=
#+begin_src shell :tangle ~/.local/bin/cmd-with-notify
  if [ "$TERM" = "linux" ]; then
      "$@"
      exit
  fi

  "$@" && notify-send "Command $* exited successfully." || {
          err=$?
          notify-send -u critical "Command $* exited with error $err."
      }
  exit $err
#+end_src
*** Completions
#+begin_src fish :tangle ~/.config/fish/completions/cmd-with-notify.fish
  complete --command cmd-with-notify -f -a '(complete -C(commandline -cp | sed "s:\S\+::"))'
#+end_src
** =delayed-command=
#+begin_src bash :tangle ~/.local/bin/delayed-command
  sleep "$1"
  exec "${@:2}"
#+end_src
*** Completions
#+begin_src fish :tangle ~/.config/fish/completions/delayed-command.fish
  complete -c delayed-command -a '(complete -C "command ")'
#+end_src
** =xpreset=
#+begin_src shell :tangle ~/.local/bin/xpreset
  [ "$#" != 1 ] && exit 1

  ln -sf .xinitrc-"$1" ~/.xinitrc
#+end_src
*** Fish completions
#+HEADER: :tangle-mode (identity #o644)
#+begin_src fish :tangle ~/.config/fish/completions/xpreset.fish
  complete -c xpreset -f -a "(pushd ~; ls .xinitrc-* | string replace .xinitrc- ''; popd)"
#+end_src
** =xrandr-toggle=
#+begin_src shell :tangle ~/.local/bin/xrandr-toggle
  n="$(xrandr --listmonitors | head -1 | awk '{print $NF}')"

  [ "$n" = 1 ] && {\
                   xrandr2 --auto
                   MSG='enabled'
  } || {\
        xrandr2 --off
        MSG='disabled'
  }
  [ "$?" = 0 ] && notify-send "second monitor sucessfully $MSG" || notify-send -u "monitor operation unsuccessful"

  # Fix wallpaper on second monitor
  feh --bg-fill .wallpaper
#+end_src
** =xrandr2=
#+begin_src shell :tangle ~/.local/bin/xrandr2
  # Wrapper for xrandr command with some options applied based on my current
  # monitor configuration

  xrandr --output HDMI-1-0 "$@" --pos 1920x1080
#+end_src
** =pipetest=
#+begin_src bash :tangle ~/.local/bin/pipetest
  # Create three tmux panes:
  # - A SOURCE text file opened in vim
  # - A SCRIPT file opened in vim
  # - An output buffer that shows the results of processing SOURCE with SCRIPT
  #
  # The SOURCE is supplied to the SCRIPT via pipe, i.e. the output buffer shows
  # the results of:
  #
  # SCRIPT < SOURCE
  #
  # The output automatically updates when one of SCRIPT, SOURCE changes.
  #
  # USAGE: pipetest [SOURCE] [SCRIPT]
  #
  # If the optional arguments SCRIPT and SOURCE are given, the SCRIPT and SOURCE
  # buffers will have an initial content equal to the content of those files.

  vim_executable=vim
  if command -v nvim >/dev/null; then
      vim_executable=nvim
  fi
  temp_dir="$(mktemp -d)"

  INITIAL_SOURCE="$1"
  INITIAL_SCRIPT="$2"

  [ -z "$INITIAL_SOURCE" ] && INITIAL_SOURCE=/dev/null
  [ -z "$INITIAL_SCRIPT" ] && INITIAL_SCRIPT=/dev/null

  if [ "$#" -gt 2 ]; then
      echo "Too many arguments" >&2
      exit 1
  fi

  # Create a temporary file with content from stdin
  # Usage: create_file HANDLE <CONTENT
  # HANDLE is the name of the bash variable that will point to the file's path
  create_file() {
      local file
      file="$temp_dir/$1"
      if [ ! -t 0 ]; then
          cat > "$file"
      else
          touch "$file"
      fi

      declare -g "$1"="$file"
  }

  # Same as create_file but also marks it executable by the current user
  create_file_x() {
      create_file "$@"
      chmod u+x "${!1}"
  }

  # Create a fifo so the first and second windows can notify the third window of
  # changes
  fifo="$temp_dir/fifo"
  mkfifo "$fifo"

  # The source file (first buffer) that is being piped to SCRIPT
  create_file SOURCE < "$INITIAL_SOURCE"

  # The script file (second buffer) that will process the file and generate
  # output in the third buffer
  create_file_x SCRIPT < "$INITIAL_SCRIPT"

  #
  # Notifies the output terminal that some of the first two buffers have changed.
  #
  create_file_x on_change <<EOF
  <<pipetest_on_change>>
  EOF

  #
  # Supplementary vimrc file that is loaded by each vim session started from this
  # program.
  #
  create_file vimrc <<EOF
  <<pipetest_vimrc>>
  EOF

  #
  # Vim wrapper that loads our supplementary vimrc file.
  #
  create_file_x custom_vim <<EOF
  <<pipetest_custom_vim>>
  EOF

  #
  # Output script - script that is run in the third buffer that shows the output
  # of the user SCRIPT when applied to the SOURCE file.
  #
  create_file_x output_script <<EOF
  <<pipetest_output_script>>
  EOF

  #
  # Main script that launches tmux and everything.
  #
  create_file_x main_script <<EOF
  <<pipetest_main_script>>
  EOF

  tmux new "$main_script"

  #
  # Print the resulting script
  #
  cat "$SCRIPT"

  #
  # Remove created temporary directory
  #
  rm -rf "$temp_dir"
#+end_src
*** Helper scripts
These scripts are embedded into the =pipetest= script as heredocs, but we define
them as code blocks here for better readability.
**** =on_change=
#+NAME: pipetest_on_change
#+begin_src shell
  echo > "$fifo"
#+end_src
**** =vimrc=
#+NAME: pipetest_vimrc
#+begin_src text
  " On write run the on_change script
  autocmd BufWritePost * silent !$on_change
  autocmd ExitPre $SOURCE,$SCRIPT silent !tmux kill-session
#+end_src
**** =custom_vim=
#+NAME: pipetest_custom_vim
#+begin_src shell
  "$vim_executable" -c "source $vimrc" "\$@"
#+end_src
**** =output_script=
#+NAME: pipetest_output_script
#+begin_src shell
  echo "This is the output."
  echo "It will automatically refresh when either of the files change."
  echo "Press Ctrl+C here or quit any of the two vim instances to exit."

  trap "tmux kill-session" INT TERM EXIT

  while :; do
      #stty -echo
      read _ < "$fifo"
      [ "$?" != "0" ] && break
      clear
      "$SCRIPT" <"$SOURCE"
  done
#+end_src
**** =main_script=
#+NAME: pipetest_main_script
#+begin_src shell
  tmux split-window -h "$custom_vim" "$SCRIPT"
  tmux split-window -h sh -c 'cd "$(pwd)"; "$output_script"'
  tmux select-pane -L
  tmux select-layout even-horizontal

  "$custom_vim" "$SOURCE"
#+end_src
*** TODO consider extracting this script into its own project
** =auto-browser=
#+begin_src bash :tangle ~/.local/bin/auto-browser
  browser='firefox -P «eval-user-name()»'
  # If a firefox window is currently active, open the link in the active window
  if xprop -id "$(xdotool getactivewindow)" | grep -qi 'firefox'; then
      where='--new-tab'
  else # Otherwise open a new window
      where='--new-window'
  fi

  args="$(printf '%q ' "$@")"
  i3-msg exec "$browser $where $args"
#+end_src
*** Dependencies                                                     :deps:
#+begin_src text :tangle (haris/tangle-deps "auto-browser.pacman")
  xdotool xorg-xprop
#+end_src
** =alternative-command=
#+begin_src bash :tangle ~/.local/bin/alternative-command
  cmd="$(which -a "$1" | uniq | sed -n 2p)"

  exec "$cmd" "${@:2}"
#+end_src
** =curltb=
#+begin_src shell :tangle ~/.local/bin/curltb
  # Get https://termbin.com/<TERMBIN_BLOB> using curl
  # Usage: curltb TERMBIN_BLOB [CURL_OPTIONS]

  curl https://termbin.com/"$1" "${@:2}"
#+end_src
** =colortest=
#+begin_src bash :tangle ~/.local/bin/colortest
  # Print out all 256 colors in the terminals

  f=0
  l=256

  if [ -n "$1" ]; then
      l="$1"
  fi

  if [ -n "$2" ]; then
      f="$1"
      l="$2"
  fi

  (x=`tput op` y=`printf %40s`;for i in $(seq "$f" "$l");do o=00$i;echo -e ${o:${#o}-3:3} \
    `tput setaf $i;tput setab $i`${y// /=}$x;done)
#+end_src
** =myemacs-load=
Wrapper to [[*=myemacs=][myemacs]] that will load its first argument instead of opening it. The
remaining args simply passed to myemacs as usual. The main use for this is as a
shebang for elisp scripts.
*NOTE:* It must be implemented in such a convoluted way as a shell script, because
process management in emacs is shit.
#+NAME: myemacs-load
#+begin_src bash :tangle ~/.local/bin/myemacs-load :eval no
  tmpfile="$(mktemp)"
  cat >"$tmpfile" <<'EOF_c478eee3'
    <<stringify-arg-to-eval-option>>
  EOF_c478eee3

  if [ -t 0 ]; then
      input_file="$(realpath "$1")"
  else
      input_file="$(mktemp)"
      trap "$(printf "%q " rm -rf "$input_file")" ERR EXIT
      cat >"$input_file"
  fi

  arg="$(
      emacs --quick --batch --load "$tmpfile" "$input_file" "${@:2}"
  )"
  myemacs --no-tty --no-wait --eval "$arg" | sed '/^<<do-not-print-token>>$/d'

  rm -f "$tmpfile"
#+end_src
#+NAME: stringify-arg-to-eval-option
#+begin_src elisp :tangle no
  (let* ((file (car argv))
         (code `(progn
                  (defvar argv)
                  (defvar process-environment)
                  (defvar default-directory)
                  (let ((argv (list ,@(cdr argv)))
                        (process-environment (list ,@process-environment)))
                    (load ,file)
                    <<do-not-print-token>>))))
    (prin1 code))
#+end_src
#+CALL: stringify-arg-to-eval-option[:var argv='("a" "b")]()
Emacsclient prints the result of evaluation of =--eval=. The only non-hacky way I
know to disable this is to give it the =--suppress-output= option. But this would also
suppress desirable output like calls to =(message)=. So I put this token as the
last statement, and remove it from the output by piping to =sed=.
#+NAME: do-not-print-token
#+begin_src text
  "1617875f9593bd741b9637ad26aabb9f42ff3df769564f7881d7603a80ea0ae2"
#+end_src
** =o=
Wrapper command around the equivalent [[file:shells.org::*=o=][fish function]].
#+begin_src bash :tangle ~/.local/bin/o
  fish -C "o $(printf "%q " "$@")"
#+end_src
** =get-os-type=
Get the OS type.
#+begin_src shell :tangle ~/.local/bin/get-os-type
  cat /etc/lsb-release 2>/dev/null | grep -q 'Ubuntu'     && echo 'ubuntu' && exit
  cat /etc/os-release  2>/dev/null | grep -q 'Arch Linux' && echo 'arch'   && exit
  echo 'warning: get-os-type: Unsupported OS' >&2
  exit 1
#+end_src
** =get-self-ip=
#+begin_src shell :tangle ~/.local/bin/get-self-ip
  case "$(get-os-type)" in
      arch)   hostname -i | cut -f1 -d' ' ;;
      *)      hostname -I | cut -f1 -d' ' ;;
  esac
#+end_src
** =urlencode=
#+begin_src bash :tangle ~/.local/bin/urlencode
  python -c 'import urllib.parse as p; print(p.quote(input()))'
#+end_src
** =urldecode=
#+begin_src bash :tangle ~/.local/bin/urldecode
  python -c 'import urllib.parse as p; print(p.unquote(input()))'
#+end_src
** =fifo=
#+begin_src shell :tangle ~/.local/bin/fifo
  mkfifo /tmp/fifo 2>/dev/null

  session_exists() {
      tmux has-session -t fifo 2>/dev/null
  }

  create_session() {
      tmux new -s fifo "$@" tail --follow=name /tmp/fifo
  }

  if [ -t 0 ]; then
      if session_exists; then
          tmux attach -t fifo
      else
          create_session
      fi
  else
      if ! session_exists; then
          create_session -d
      fi
      tee /tmp/fifo
  fi
#+end_src
** =get-random-unused-port=                                         :script:
#+begin_src bash :tangle ~/.local/bin/get-random-unused-port
  # This piece of magic was generated by ChatGPT. Don't try to understand it, just
  # accept it.
  comm -23 <(seq 49152 65535 | sort) <(ss -tan | awk '{print $4}' | cut -d':' -f2 | sort -u) | shuf | head -n 1
#+end_src
** =docker-ls-context=
#+begin_src bash :tangle ~/.local/bin/docker-ls-context
  tag="$(date +%s%3N | sha256sum | head -c 32)"
  docker image build --tag "$tag" --no-cache -f - "$@" >&2 <<'EOF'
  «docker-ls-context/dockerfile»
  EOF

  docker run --rm "$tag"
  docker rmi "$tag" >&2
#+end_src
#+NAME: docker-ls-context/dockerfile
#+begin_src dockerfile
  FROM busybox
  WORKDIR /workdir
  COPY . .
  CMD find . | grep -v '^\.$'
#+end_src
** =info=
#+begin_src bash :tangle ~/.local/bin/info
  echo -ne "\033[1;32m" >&2
  echo "$@" | fifo >&2
  echo -ne "\033[0m" >&2
#+end_src
** =debug=
#+begin_src bash :tangle ~/.local/bin/debug
  echo -ne "\033[1;33m" >&2
  bash -c 'printf "%q " "$@"' -s "$@" >&2
  echo | fifo >&2
  echo -ne "\033[0m" >&2

  "$@"
#+end_src
** =dragon=
#+begin_src bash :tangle ~/.local/bin/dragon
  set -- --on-top --thumb-size 32 "$@"

  if which dragon-drag-and-drop &>/dev/null; then
      dragon-drag-and-drop "$@"
  elif which dragon-drop &>/dev/null; then
      dragon-drop "$@"
  else
      alternative-command dragon "$@"
  fi
#+end_src
** =tee-notify=
#+begin_src shell :tangle ~/.local/bin/tee-notify
  content="$(cat)"
  notify-send "tee-notify" "$content"
  echo "$content"
#+end_src
** =get-cert=
#+begin_src shell :tangle ~/.local/bin/get-cert
  {
      timeout 0.5 openssl s_client -connect "$1" -showcerts 2>/dev/null
      true
  } | awk '/^-----BEGIN CERTIFICATE-----$/,/^-----END CERTIFICATE-----$/'
#+end_src
** =forever=
#+begin_src shell :tangle ~/.local/bin/forever
  while :; do
      command "$@"
      sleep 2
  done
#+end_src
** =PR=
Create a BitBucket PR.
#+begin_src bash :tangle ~/.local/bin/PR
  uriEncode() {
      tr -d '\n' | jq -sRr @uri
  }

  source_branch="$1"
  dest_branch="$2"

  if [ -z "$source_branch" ]; then
      source_branch="$(git branch --show-current | tr -d '\n')"
  fi
  source_branch_enc="$(uriEncode <<<"$source_branch")"
  if [ -z "$dest_branch" ]; then
      dest_branch="$(
          {
              git config init.defaultBranch
              git branch | sed 's/^..//'
          } | head -1
      )"
  fi
  dest_branch_enc="$(uriEncode <<<"$dest_branch")"
  remote="$(git remote get-url upstream 2>/dev/null)"
  if [ -z "$remote" ]; then
      remote="$(git remote get-url origin)"
  fi

  if [ -z "$remote" ]; then
      echo "Either upstream or origin remote must exist"
  fi

  if [[ ! "$remote" =~ .*bitbucket\.org.* ]]; then
      echo "Only BitBucket is supported currently"
      exit 1
  fi

  bitbucket_repo="$(
      echo "$remote" |
          sed  's_.*bitbucket\.org[:/]__' |
          grep '^[^/]\+/[^/]\+' |
          sed  's_\.git$__'
  )"
  url="https://bitbucket.org/$bitbucket_repo/pull-requests/new?source=$source_branch_enc&dest=$dest_branch_enc"

  echo "Opening a PR in the browser..."

  echo "Source branch: $source_branch"
  echo "Destination branch: $dest_branch"
  echo "BitBucket repo: $bitbucket_repo"
  echo "PR URL: $url"

  gtk-launch "$(xdg-settings get default-web-browser)" "$url"
#+end_src
** =mosquitto_sub_yq=
#+begin_src bash :tangle ~/.local/bin/mosquitto_sub_yq
  mosquitto_sub \
      -F '{"topic": "%t",\n"body": %p}' \
      "$@" |
      while :; do
          echo
          yq -P \
             2> >(grep -v "Error: bad file '-': yaml: line [0-9]\+: did not find expected <document start>")
      done
#+end_src
*** Completions
#+begin_src fish :tangle ~/.config/fish/completions/mosquitto_sub_yq.fish
  complete -c mosquitto_sub_yq --wraps mosquitto_sub
#+end_src
** =mosquitto_sub_jq=
#+begin_src bash :tangle ~/.local/bin/mosquitto_sub_jq
  mosquitto_sub \
      -F '{"topic": "%t",\n"body": %p}' \
      "$@" |
      while :; do
          echo
          jq
      done
#+end_src
*** Completions
#+begin_src fish :tangle ~/.config/fish/completions/mosquitto_sub_jq.fish
  complete -c mosquitto_sub_jq --wraps mosquitto_sub
#+end_src
** =@gh=
Clone a Github repo using the given URL (HTTPS or SSH) and execute the given
command there.
#+begin_src bash :tangle ~/.local/bin/@gh
  if [ "$#" -lt 3 ]; then
      echo "Usage: @gh REPO_URL [BRANCH_OR_COMMIT] COMMAND [ARGS...]"
      exit 1
  fi

  ref="$2"

  mkdir -p ~/.cache/haris/tmp-{commits,repos}
  (cd ~/.cache/haris/tmp-commits && git init --bare &>/dev/null)

  dest=~/.cache/haris/tmp-repos/"$(echo "$1" | sed 's|[:/]|_|g')_$ref"

  git clone \
      --reference ~/.cache/haris/tmp-commits \
      --depth 1 --no-checkout "$1" "$dest" 2> \
      >(sed -E 's/fatal: (destination path)/info: \1/g' >&2)

  cd "$dest" || exit 1
  git fetch origin "$ref"
  git checkout FETCH_HEAD
  shift 2
  exec "$@"
  rm -rf "$tmpdir"
#+end_src
** =with-xdg=
Run a command in the specified directory used for all XDG base directories.
#+begin_src bash :tangle ~/.local/bin/with-xdg
  dir="$1"
  shift 1

  _mkdir() {
      mkdir -p "$1"
      echo "$1"
  }

  export XDG_CONFIG_HOME="$(_mkdir "$dir/config")"
  export XDG_CACHE_HOME="$(_mkdir "$dir/cache")"
  export XDG_DATA_HOME="$(_mkdir "$dir/data")"
  export XDG_DATA_DIRS="$(_mkdir "$dir/data")"
  export XDG_RUNTIME_DIR="$(_mkdir "$dir/runtime")"
  export XDG_STATE_HOME="$(_mkdir "$dir/state")"

  exec "$@"
#+end_src
** =noxdg=
Reset all XDG environment variables to mimic a fresh user environment.
#+begin_src bash :tangle ~/.local/bin/noxdg
  tmpdir="$(mktemp -d)"
  echo "TMPDIR: $tmpdir" >&2
  with-xdg "$tmpdir" "$@"
#+end_src
** =in=
Run a command in a given directory.
#+begin_src bash :tangle ~/.local/bin/in
  print_help() {
      echo "Usage: in <directory> <command> [args...]"
      echo "Runs the specified command in the given directory."
  }

  dir="$1"
  shift 1

  (
      cd "$dir" || exit 1
      exec "$@"
  )
#+end_src
*** Completions
#+begin_src fish :tangle ~/.config/fish/completions/in.fish
  function __haris_complete_in
      set -l argv (commandline -opc) (commandline -t)
      set -l cursor_index (count $argv)
      if [ "$cursor_index" -gt 2 ]
          complete -C "command $(echo $argv[3..])"
      else
          complete -C "ls $argv[2]"
      end
  end
  complete -c in -fa '(__haris_complete_in)'
#+end_src
** =git-haris-setup=
#+begin_src bash :tangle ~/.local/bin/git-haris-setup
  # Setup git remotes for Haris' workflow
  # - If origin exists and doesn't start with "myghg:" and there's no upstream, rename origin to upstream
  # - Create remote "me" pointing to git@veracioux.me:<directory-basename>

  # Check if we're in a git repository
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
      echo "Error: Not in a git repository"
      exit 1
  fi

  # Get current directory basename for the remote URL
  dir_basename="$(basename "$(pwd)")"

  # Check if origin remote exists
  if git remote get-url origin >/dev/null 2>&1; then
      origin_url="$(git remote get-url origin)"

      # Check if origin doesn't start with "myghg:" and there's no upstream remote
      if [[ ! "$origin_url" =~ ^myghg: ]] && ! git remote get-url upstream >/dev/null 2>&1; then
          echo "Renaming origin to upstream..."
          git remote rename origin upstream
          echo "Remote 'origin' renamed to 'upstream'"
      else
          echo "Origin remote already configured correctly or upstream exists"
      fi
  else
      echo "No origin remote found"
  fi

  # Create or update the "me" remote
  if git remote get-url me >/dev/null 2>&1; then
      echo "Remote 'me' already exists"
  else
      echo "Creating remote 'me' pointing to git@veracioux.me:$dir_basename..."
      git remote add me "git@veracioux.me:$dir_basename"
      echo "Remote 'me' created successfully"
  fi

  # Create or update the "me-eo" remote
  if git remote get-url me-eo >/dev/null 2>&1; then
      echo "Remote 'me-eo' already exists"
  else
      echo "Creating remote 'me-eo' pointing to me-git@veracioux.me:$dir_basename..."
      git remote add me-eo "eo-git@veracioux.me:$dir_basename"
      echo "Remote 'me-eo' created successfully"
  fi

  # Show final remote configuration
  echo
  echo "Current remotes:"
  git remote -v
#+end_src
* Applications
These are programs that are meant to be used mostly interactively. As such, they
are designed to be easily integrated into dmenu scripts.
** =cf=
#+begin_src shell :tangle ~/.local/bin/cf
  # Look up a configuration file by its user-friendly alias.

  # Note: This script is statically parsed by lscf. Keep its structure intact.

  for arg in "$@"; do
      case "$arg" in
          .haris)                  echo ~/.haris ;;
          README.org)              echo ~/.haris/README.org ;;
          temporary.org)           echo ~/.haris/temporary.org ;;
          bootstrap.org)           echo ~/.haris/bootstrap/README.org ;;
          alacritty)               echo ~/.haris/terminal.org ;;
          alias-tmp)               echo ~/.alias-tmp ;;
          alias-gui-tmp)           echo ~/.alias-gui-tmp ;;
          fish)                    echo ~/.haris/shells.org ;;
          fish-private)            echo ~/.config/fish/private.fish ;;
          fish-tmp)                echo ~/.config/fish/tmp.fish ;;
          vifm)                    echo ~/.haris/terminal.org ;;
          git)                     echo ~/.haris/vcs.org ;;
          gh)                      echo ~/.haris/vcs.org ;;
          hg)                      echo ~/.haris/vcs.org ;;
          picom)                   echo ~/.haris/wm.org ;;
          dunst)                   echo ~/.haris/misc.org ;;
          tem)                     echo ~/.haris/terminal.org ;;
          mime)                    echo ~/.haris/README.org ;;
          zathura)                 echo ~/.haris/gui.org ;;
          emacs)                   echo ~/.haris/emacs.org ;;
          spacemacs)               echo ~/.spacemacs ;;
          cron)                    echo ~/.crontab ;;
          octave)                  echo ~/.octaverc ;;
          python)                  echo ~/.startup.py ;;
          tuterm)                  echo ~/.haris/terminal.org ;;
          xinit)                   echo ~/.haris/wm.org ;;
          sxhkd)                   echo ~/.haris/wm.org ;;
          mpv)                     echo ~/.haris/gui.org ;;
          flameshot)               echo ~/.haris/gui.org ;;
          cheat)                   echo ~/.haris/terminal.org ;;
          xmrig)                   echo ~/.config/xmrig.json ;;
          tmux)                    echo ~/.tmux.conf ;;
          vscode/settings.json)    echo ~/.haris/vscode/settings.json ;;
          vscode/keybindings.json) echo ~/.haris/vscode/keybindings.json ;;
          ,*)
              if [ -f ~/.haris/"$arg" ]; then
                  echo ~/.haris/"$arg"
              fi
              ;;
      esac
  done
#+end_src
** =elisp=
#+begin_src shell :tangle ~/.local/bin/elisp
  # Run an elisp interpreter through emacs
  <<add-create-frame-option-if-term-dumb>>
  myemacs --eval "(ielm)" "$@"
#+end_src
** =eoctave=
#+begin_src shell :tangle ~/.local/bin/eoctave
  # Run octave interpreter through emacs
  <<add-create-frame-option-if-term-dumb>>
  myemacs --eval "(progn (run-octave) (delete-other-windows))" "$@"
#+end_src
** =epython=
#+begin_src shell :tangle ~/.local/bin/epython
  # Run a python interpreter through emacs
  <<add-create-frame-option-if-term-dumb>>
  myemacs --eval "(progn (call-interactively 'run-python) (delete-other-windows))" "$@"
#+end_src
** =eterm=
#+begin_src shell :tangle ~/.local/bin/eterm
  # Run an emacs-hosted terminal via vterm
  <<add-create-frame-option-if-term-dumb>>
  myemacs --socket-name=vterm --eval '(multi-vterm)' "$@"
#+end_src
** =eman=
#+NAME: eman
#+HEADER: :shebang "#!/usr/bin/env myemacs-load"
#+begin_src elisp :tangle ~/.local/bin/eman
  (with-selected-frame (make-frame `((name . "EmacsMan")
                                     (display . ,(getenv "DISPLAY"))
                                     (environment . ,process-environment)))
    (let ((man-buffer nil))
      (defvar haris/last-man-buffer nil "The last man buffer that was opened")
      (setq man-buffer
            (if argv
                (man (car argv))
              (progn
                (when (and (boundp 'haris/last-man-buffer)
                           (buffer-live-p haris/last-man-buffer))
                  (switch-to-buffer haris/last-man-buffer))
                (call-interactively 'man))))
      (when man-buffer (setq haris/last-man-buffer man-buffer))))
#+end_src
#+CALL: eman(argv='())
#+CALL: eman(argv='("vim"))
#+CALL: eman(argv='("git"))
#+CALL: eman(argv='("emacs"))
*** Completions
#+begin_src fish :tangle ~/.config/fish/completions/eman.fish
  complete -c eman --wraps man
#+end_src
** =etranslate=
#+NAME: etranslate
#+HEADER: :shebang "#!/usr/bin/env myemacs-load"
#+begin_src elisp :tangle ~/.local/bin/etranslate
  (with-selected-frame (make-frame `((name . "EmacsFloat")
                                     (display . ,(getenv "DISPLAY"))
                                     (environment . ,process-environment)))
    (spacemacs/switch-to-scratch-buffer)
    (with-temp-buffer
      (insert (shell-command-to-string "~/.local/lib/haris/etranslate-helper 2>/dev/null"))
      (let* ((gt-taker-text 'buffer)
             (gt-buffer-prompt-window-config '(display-buffer-same-window))
             (gt-buffer-render-window-config gt-buffer-prompt-window-config))
        (gt-do-translate))))
#+end_src
*** Helper script
This script prints the contents of the clipboard
#+NAME: etranslate/get-selection
#+begin_src bash :tangle ~/.local/lib/haris/etranslate-helper
  # In order to get the time when the selection happened I use a timestamp
  # reported by xclip and to get the current time I use a timestamp reported by
  # xsel. I have no idea what these timestamps are relative to, but I have
  # empirically determined that this works.

  set -e

  ts_current="$(
      timeout 0.5 \
          xsel --output -vvv 2>&1 >/dev/null \
              | grep '^xsel: Timestamp:' \
              | awk '{print $3}'
  )"
  ts_sel="$(timeout 0.5 xclip -target TIMESTAMP -out 2>/dev/null)"

  # Uncomment for debugging:
  # echo "current timestamp: $ts_current, selection timestamp: $ts_sel" >&2

  elapsed_time_millis="$(expr "$ts_current" - "$ts_sel" 2>/dev/null)"

  status="$?"
  # Some programs (alacritty) don't handle the primary clipboard correctly,
  # so ts_sel might not contain a valid timestamp
  if [ "$status" != 0 ]; then
      exit "$status"
  fi

  if [ "$elapsed_time_millis" -lt "10000" ]; then
      xsel --primary --output
  fi
#+end_src
** =erc=
#+begin_src shell :tangle ~/.local/bin/erc
  # Open emacs and run ERC in it

  <<add-create-frame-option-if-term-dumb>>
  myemacs --socket-name="irc" \
          --eval "(unless erc-server-connected (call-interactively 'erc-tls))" \
          "$@"
#+end_src
** =edocker=
#+HEADER: :shebang "#!/usr/bin/env myemacs-load"
#+begin_src elisp :tangle ~/.local/bin/edocker
  (let ((dir default-directory))
    (with-selected-frame (make-frame `((name . "EmacsFloat")
                                       (display . ,(getenv "DISPLAY"))
                                       (environment . ,process-environment)))
      (setq-local default-directory dir)
      (spacemacs/switch-to-scratch-buffer)
      (run-with-timer 0.3 nil 'docker)))
#+end_src
** =edocker-compose=
#+HEADER: :shebang "#!/usr/bin/env myemacs-load"
#+begin_src elisp :tangle ~/.local/bin/edocker-compose
  (let ((dir default-directory))
    (with-selected-frame (make-frame `((name . "EmacsFloat")
                                       (display . ,(getenv "DISPLAY"))
                                       (environment . ,process-environment)))
      (switch-to-buffer (get-buffer-create
                         (generate-new-buffer-name haris/custom-temp-buffer-name)))
      (setq-local default-directory dir)
      (setq-local process-environment (cdr (assq 'environment
                                                 (frame-parameters
                                                  (selected-frame)))))
      (run-with-timer 0.3 nil 'docker-compose)))
#+end_src
** =ebluetooth=
#+begin_src shell :tangle ~/.local/bin/ebluetooth
  myemacs-float -c --eval '(bluetooth-list-devices)'
#+end_src
** =proced=
#+begin_src shell :tangle ~/.local/bin/proced
  <<add-create-frame-option-if-term-dumb>>
  myemacs-float --eval '(progn (proced) (delete-other-windows))' "$@"
#+end_src
** =magit=
#+HEADER: :shebang "#!/usr/bin/env myemacs-load"
#+begin_src elisp :tangle ~/.local/bin/magit
  (let ((dir default-directory))
    (with-selected-frame (make-frame `((name . "EmacsFloat")
                                       (display . ,(getenv "DISPLAY"))
                                       (environment . ,process-environment)))
      (let ((default-directory dir))
        (magit-status))))
#+end_src
** =qr=
#+begin_src bash :tangle ~/.local/bin/qr
  # Copy, show or open the argument based on its content
  copy_or_show_or_open() {
      notify-send 'QR Code:' "$@"
      echo "$1" | xsel -b
      if echo "$1" | grep -q '^https://'; then
          firefox --new-tab "$@"
      fi
  }

  if [ "$1" = 'in' ]; then
      copy_or_show_or_open "$(timeout 20s zbarcam /dev/video0 -1 | sed 's/^QR-Code://')"
  elif [ "$1" = 'screen' -o "$1" = 's' ]; then
      copy_or_show_or_open "$(zbarimg -q <(flameshot screen --raw) | sed 's/^QR-Code://')"
  else # out
      if [ -t 0 ] || [ "$TERM" = 'linux' ]; then
          input="$(xsel -b -o)"
      else
          input="$(cat)"
      fi
      echo "$input" | qrencode -s 10 -o - | feh -
  fi
#+end_src
*** Dependencies                                                     :deps:
#+begin_src text :tangle (haris/tangle-deps "qr.pacman")
  zbar qrencode
#+end_src
** =rb=
# TODO: linux-only
#+begin_src shell :tangle ~/.local/bin/rb
  # One-time reboot into selected OS

  set -e # Quit if any command fails

  index="$(grep "menuentry '\|submenu '" /boot/grub/grub.cfg |\
    grep -v -P '\t' |\
    grep -i -n "$1" |\
    head -1 | awk -F':' '{print $1}')"

  if [ -z $index ]; then
      echo "No entry found"
  else
      index=$(( $index - 1 ))
      echo "Selected menuentry: $index. Proceed?"
      read response
      if [ "$response" == 'y' ]; then
          sudo grub-reboot $index >/home/haris/src/grublog 2>&1
          reboot
      fi
  fi
#+end_src
** =vimdiff=
#+begin_src shell :tangle ~/.local/bin/vimdiff
  # Like regular vimdiff, but in nvim

  nvim -d "$@"
#+end_src
** =vicc=
#+begin_src shell :tangle ~/.local/bin/vicc
  # Find and open in vim a header file from the default include path

  vim "$(echo "#include <$1>" | cpp -H 2>&1 >/dev/null | head -1 | sed 's/^. //')"
#+end_src
** =vipydoc=
#+begin_src shell :tangle ~/.local/bin/vipydoc
  # Open alacritty with pydoc in it
  # - All arguments are passed to pydoc
  # - Alacritty window class tracks those defined in my i3 config

  alacritty --class Alacritty,Float -e fish -C "pydoc $*" &
#+end_src
** =rgf=
#+begin_src shell :tangle ~/.local/bin/rgf
  # Run rg and fzf to search through file contents and jump to a file

  where="$1"
  [ -z "$where" ] && where='.'

  rg --column --line-number --no-heading --color=always --smart-case . | fzf --ansi
#+end_src
** =otp=
#+begin_src python :tangle ~/.local/bin/otp
  import shlex
  import subprocess

  import dryparse
  from dryparse.objects import Option
  import sys
  from urllib.parse import urlparse, parse_qs

  @dryparse.command
  def otp(name: str, *, new: bool = False, extract: Option("-x", "--extract", bool) = False):
      """Use and manage one-time passwords.

      :param name: name of the OTP
      :param new: store a new OTP instead of printing an existing one
      :param extract: Extract the secret from the URL given as argument
      """
      extract: bool

      def run(*args, **kwargs):
          return subprocess.run(*args, shell=True, encoding="utf-8", **kwargs)

      if new and extract:
          print("--new and --extract can't be used together", file=sys.stderr)
          sys.exit(1)

      if new:
          p = run(f"pass insert {name}/otp-secret")
          sys.exit(p.returncode)
      elif extract:
          query = parse_qs(urlparse(name).query)
          print(query["secret"][-1])
          return


      otp_secret = run(
          f"pass show {name}/otp-secret", stdout=subprocess.PIPE
      ).stdout.strip()

      p = run(f"oathtool --totp --base32 {shlex.quote(otp_secret)}")
      sys.exit(p.returncode)


  otp = dryparse.parse(otp, sys.argv)
  otp()
#+end_src
*** Dependencies                                                     :deps:
#+begin_src text :tangle (haris/tangle-deps "otp.pip-user")
  dryparse
#+end_src
** =imount=
#+begin_src bash :tangle ~/.local/bin/imount
  # List of all blocks
  listing="$(lsblk --list -o PATH,LABEL)"

  # ... with header removed
  items="$(
      echo "$listing" \
          | tail -n +2 \
          | sed 's/.*/"&"/' \
          | nl --number-width=1 \
          | grep -v '/dev/loop'
  )"
  # number of lines
  lineno="$(echo "$items" | wc -l)"

  # Open file descriptor 3
  exec 3>&1
  # Show dialog and store id of selection
  id=$(
      eval dialog  2>&1 1>&3 \
          --default-item $lineno \
          --menu '"Choose a device/partition:"' 60 50 $lineno $items
  )
  [ "$?" != 0 ] && exit 1     # Dialog exited with error
  # Select mounting directory
  mount_dir="$(dialog --fselect ~/mnt/ 60 50 2>&1 1>&3)"
  [ "$?" != 0 ] && exit 1     # Dialog exited with error

  # Clear but keep scrollback buffer
  clear -x

  if [ ! -d "$mount_dir" ]; then # Nonexisting mount directory
      read -n 1 -p\
           "The directory $mount_dir does not exist and will be created. Continue?  [y/n]: " \
           choice 1>/dev/null
      [ "$choice" != "y" ] && exit 1
      echo # newline
      mkdir "$mount_dir"
  fi

  # Get path to selected device
  device="$(echo "$items" | sed -n ${id}p | sed 's_.*"\(\S*\)\s.*_\1_')"

  read -n 1 -p\
       "$device will be mounted at $mount_dir. Continue? (requires sudo) [y/n]: " \
       choice
  echo # newline

  [ "$choice" != "y" ] && exit 1

  # Mount the device at last
  sudo mount "$device" "$mount_dir" -o umask=002,uid=$(id -u),gid=$(id -g)

  echo -e "$mount_dir" > /tmp/imount_directory
  chmod a+rw /tmp/imount_directory
#+end_src
** =kbind=
#+begin_src bash :tangle ~/.local/bin/kbind
  # Temporarily bind keys

  pkill -f '^sxhkd\.tmp '
  myemacs-float --wait -c ~/.tmp.sxhkdrc

  notify-send "kbind" "Applying config"
  o --silent sxhkd.tmp
#+end_src
** =xpeek=
Create a Xephyr session for the current user that tries to mimic a regular
=startx= session as closely as possible.
#+begin_src bash :tangle ~/.local/bin/xpeek
  # Option variables
  host_display="$DISPLAY"
  display=1"$(id -u "$USER")"

  Xephyr :"$display" -once -resizeable \
      -screen "$(xdpyinfo | grep dimensions | grep -P '\d+x\d+' --only-matching | head -1)" \
      "$@" &
  sleep 0.5s
  windowid="$(xdotool getactivewindow)"
  echo "WINDOW ID: $windowid"

  export DISPLAY=:"$display"
  i3 &
  sxhkd &
  dunst &

  DISPLAY="$host_display" xev -id "$windowid" -event structure |
      while read line; do
          if grep "^ConfigureNotify event" <<<"$line"; then
              xrandr
          fi
      done
#+end_src
** =lock-screen=
#+begin_src bash :tangle ~/.local/bin/lock-screen
  # Custom configuration
  HARIS_WALLPAPER_CHANGE=true
  HARIS_WALLPAPER_CHANGE_INTERVAL_SEC=60

  # Configure xsecurelock
  export XSECURELOCK_LIST_VIDEOS_COMMAND="ls-wallpapers | grep -P '\.(mp4|webm|avi|mkv|gif)$'"
  export XSECURELOCK_AUTH_TIMEOUT=10
  export XSECURELOCK_BLANK_TIMEOUT=1200
  export XSECURELOCK_BLANK_DPMS_STATE=suspend
  export XSECURELOCK_SAVER=saver_mpv
  export XSECURELOCK_IMAGE_DURATION_SECONDS=3
  export XSECURELOCK_VIDEOS_FLAGS='--loop --panscan=1 --autofit=100%x100%'
  export XSECURELOCK_SAVER_RESET_ON_AUTH_CLOSE=0
  export XSECURELOCK_PASSWORD_PROMPT=asterisks
  export XSECURELOCK_KEY_Super_L_COMMAND='systemctl suspend'

  if [ -z "$($XSECURELOCK_LIST_VIDEOS_COMMAND)" ]; then
      # No videos found, use images
      export XSECURELOCK_LIST_VIDEOS_COMMAND="ls-wallpapers | grep -P '\.(png|jpg|jpeg|webp)$'"
      export XSECURELOCK_VIDEOS_FLAGS=''
      HARIS_WALLPAPER_CHANGE=''
  fi

  picom_running="$(pgrep '^picom$' >/dev/null && echo true)"
  pkill '^picom$'

  # Run xsecurelock, restarting at intervals in order to change the wallpaper
  xsecurelock &
  xsecurelock_pid="$!"
  last_change_time="$(date +%s)"

  # If a suspend was the trigger for this lock, make sure the suspend is delayed
  # until xsecurelock is ready. This makes sure the screensaver is active
  # immediately after a wake-up.
  if [ -n "$XSS_SLEEP_LOCK_FD" ]; then
      exec "$XSS_SLEEP_LOCK_FD"<&-
  fi

  # Restart xsecurelock at intervals to change the wallpaper,
  # but without interrupting the user if they are entering their password.
  while [ -n "$HARIS_WALLPAPER_CHANGE" ]; do
      sleep 1s
      if ! ps -p "$xsecurelock_pid" >/dev/null; then
          # xsecurelock exited, exit this program as well
          break
      fi
      # Check if the wallpaper has been active for enough time
      now="$(date +%s)"
      change_interval="$HARIS_WALLPAPER_CHANGE_INTERVAL_SEC"
      diff="$(($now - $last_change_time))"
      echo "Wallpaper has been active for $diff s."
      if [ "$diff" -ge "$change_interval" ]; then
          echo "Wallpaper change is due"
          idle_time="$(xprintidle)"
          if [ "$idle_time" -ge "${XSECURELOCK_AUTH_TIMEOUT}000" ]; then
              echo "Changing wallpaper"
              last_change_time="$(date +%s)"
              xsecurelock &
              new_pid="$!"
              sleep 0.3s
              kill "$xsecurelock_pid"
              xsecurelock_pid="$new_pid"
          else
              echo "Wallpaper change skipped due to user activity. idle_time: $idle_time ms"
          fi
      fi
  done

  if [ -n "$picom_running" ]; then
      sleep 0.5s
      o picom
  fi
#+end_src
* Dmenu
** Main entrypoint (=dmenu_run=)
#+begin_src bash :tangle ~/.local/bin/dmenu_run
  export HARIS_CALLER_IS_DMENU=true
  CACHE_FILE=~/.cache/haris/desktop-apps.txt
  mkdir -p "$(dirname "$CACHE_FILE")"

  # If an argument is provided, run corresponding custom dmenu script
  if [ -n "$1" ]; then
      script=~/.local/lib/dmenu/"$1"
      if [ -e "$script" ]; then
          "$script"
          exit
      fi
  fi
  # Otherwise open a generic dmenu where the user will choose what dmenu script
  # or other program to run

  run_script() {
      if [ -n "$TMUX" ]; then
          ~/.local/lib/dmenu/"$1"
      else
          o --silent ~/.local/lib/dmenu/"$1"
      fi
  }

  pull_desktop_apps() {
      # Print out desktop apps by reading *.desktop files and also cache them
      CACHE_FILE="$CACHE_FILE" sh <<'EOF'
  «pull_desktop_apps»
  EOF
  }
  get_desktop_apps() {
      age="$(date -d "now - $(stat -c '%Y' "$CACHE_FILE") seconds" +%s)"
      # Refresh the cache only if the file is older than a specified age (seconds)
      {
          if [ ! -f "$CACHE_FILE" -o  $age -gt 36000 ]; then
              pull_desktop_apps
          else
              cat "$CACHE_FILE"
          fi
      } | sort | uniq
  }
  get_custom_scripts() {
      find ~/.local/bin -executable -type f -printf '%f\n' | sort | uniq | sed 's/^/ /'
  }

  # ┏━━━━━━━━━━━━━━━┓
  # ┃ dmenu entries ┃
  # ┗━━━━━━━━━━━━━━━┛
  get_dmenu_entries() {
      echo " Open"           # Open an URL or bookmark
      echo " Clipboard"      # Clipboard using clipmenu
      echo " Snippets"       # Text snippets
      echo " TODO"           # Open TODO file of a project
      echo " Windows"        # Choose windows
      echo " Pacman"         # Package management
      echo " Color"          # Pick a color
      echo " Unicode"        # Pick an icon
      echo " Kill Process"   # Kill process
      echo " Fix Wifi"      # Fix Wi-Fi drop issue on some networks
      echo " Config"        # Open documentation selection
      echo " System"        # System actions
      echo " Update cache"   # Update desktop app cache
      echo "Tem"              # Launch tem development environment
      echo "Octave"           # Launch octave in emacs
      echo " Python"         # Launch python interpreter in emacs
      echo " GPG"           # GPG addresses
      echo " Books"         # Pick a book to read
      echo " IRC"           # Open emacs client for IRC
      echo "Quickmenu"        # Menu to quickly revisit recent activity
      get_desktop_apps        # Programs extracted from *.desktop files
      get_custom_scripts      # Programs from ~/.local/bin
  }

  # ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Actions based on user's choice ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  if [ -n "$1" ]; then
      choice="$1"
  else
      choice="$(get_dmenu_entries | dmenu)"
      [ "$?" = "0" ] || exit
      if grep -q '^' <<<"$choice"; then
          is_dotdesktop_app=true
      fi
      # If it starts with a non-ascii character (as in get-commands), remove it and the space following it
      if grep -qP "[^\x00-\x7F]" <<<"$choice"; then
          choice="$(cut -f2- -d' ' <<<"$choice")"
      fi
  fi
  case "$choice" in
      "Open")
          run_script open ;;
      "Clipboard")
          clipmenu ;;
      "Snippets")
          run_script snips ;;
      "TODO")
          run_script todo ;;
      "Windows")
          ~/.local/lib/i3/i3-container-commander.py ;;
      "Pacman")
          run_script pacman ;;
      "Color")
          run_script color ;;
      "Unicode")
          run_script unicode ;;
      "Kill Process")
          run_script pkill ;;
      "Fix Wifi")
          fix-wifi ;;
      "Config")
          run_script config ;;
      "System")
          run_script system ;;
      "Update cache")
          rm "$CACHE_FILE" ;;
      "Tem")
          alacritty -e fish -C 'pj tem; clear' ;;
      "Octave")
          eoctave -c ;;
      "Python")
          epython -c ;;
      "GPG")
          run_script gpg ;;
      "Books")
          run_script books ;;
      "IRC")
          myemacs --socket-name="irc" -c ;;
      "Quickmenu")
          run_script quickmenu ;;
      # The rest: aliases and regular commands
      ,*)
          if [ -n "$is_dotdesktop_app" ]; then
              # If the choice is an x.desktop app, launch it
              # DO NOT USE the `o` command here, because it kills the process
              # after linger-period
              gtk-launch "$choice"
              exit
          fi
          # Fallback, if the entry matches none of the above, just run the command
          fish -c "o $choice"
          ;;
  esac
#+end_src

This code block separated so that it can be run in =sh= instead of =bash= and thus
possibly benefit from a performance boost, in case =sh= happens to point to a more
lightweight shell.
#+NAME: pull_desktop_apps
#+begin_src shell
  ls -1 $(echo "$XDG_DATA_DIRS" | tr ':' '\n' | sed 's|$|/applications/*.desktop|') |
      sort | uniq |
      sed -E 's|.*/([^/]+)\.desktop$| \1|' | tee "$CACHE_FILE"
#+end_src
** Open
Open a website in Firefox. Suggests bookmarks managed by buku, but you can input
any URL. To suggest additional URLs, you can create the script
[[~/.local/lib/haris/custom/dmenu/open.sh]], which should print a list of additional
URLs (each on a new line) to display in this menu.
#+begin_src bash :tangle ~/.local/lib/dmenu/open
  edit=" Edit..."
  sync=" Sync..."

  firefox_about_pages() {
      cat <<'EOF_e245552b'
  about:about
  about:addons
  about:buildconfig
  about:cache
  about:certificate
  about:config
  about:crashes
  about:credits
  about:devtools
  about:downloads
  about:home
  about:license
  about:memory
  about:networking
  about:newtab
  about:performance
  about:plugins
  about:preferences
  about:privatebrowsing
  about:profiles
  about:protections
  about:rights
  about:robots
  about:serviceworkers
  about:sessionrestore
  about:support
  about:telemetry
  about:welcome
  about:studies
  EOF_e245552b
  }

  from_etc_hosts() {
      if ! which hostess &>/dev/null; then
          notify-send \
              --expire-time 1000 \
              "dmenu: open: warning" "hostess is not installed, some entries may be missing"
          return
      fi
      hostess ls | cut -f1 -d' '
  }

  choice="$(
      {
          echo "$edit"
          echo "$sync"
          unbuffer buku -p --format 30 | grep -v '^$' | sort
          [ -x ~/.local/lib/haris/custom/dmenu/open.sh ] && ~/.local/lib/haris/custom/dmenu/open.sh
          firefox_about_pages
          from_etc_hosts
      } | dmenu -p 'Open:'
  )"

  [ -z "$choice" ] && exit

  if [ "$choice" = "$edit" ]; then
      # Open this file for editing
      gvim "$0"
  elif [ "$choice" = "$sync" ]; then
      alacritty --class Alacritty,Float -e fish -C "
          echo -e \"--- Importing bookmarks from Firefox ---\nDefault is: n y y \";
          buku --import ~/.mozilla/firefox/haris/bookmarks.html"
  else
      # Try to open it as a bookmark in firefox
      url="$(
          buku --sreg "^$choice\$" -n 1 --format 10 |
          grep -v 'waiting for input'
      )"
      [ -z "$url" ] && url="$choice"
      # All google links shall be opened in firefox
      echo "$url" | grep -q 'google' && browser="$(echo "$browser" | sed 's_librewolf_/bin/firefox/')"

      # If choice is a number, assume it's a localhost port
      if [[ "$url" =~ ^[0-9]+$ ]]; then
          url="localhost:$choice"
      fi

      echo "$url"
      auto-browser -P haris "$url"
  fi
#+end_src
** Todo
#+begin_src bash :tangle ~/.local/lib/dmenu/todo
  edit=" Edit..."
  lookup="$(
    ls ~/proj/*/TODO.org \
       ~/proj/drytoe/*/TODO.org \
       ~/data/personal/todos/*/TODO.org
  )"
  echo "$lookup"

  entries="$(echo "$edit"
             echo "$lookup" |
             while read p; do
                 basename "$(dirname "$p")"
             done)"

  choice="$(
      echo "$entries" | dmenu -p TODO:
  )"

  [ "$?" != 0 ] && exit 1

  if [ "$choice" = " Edit..." ]; then
      cd "$(dirname "$0")"; gvim "$0"
  else
      myemacs-float "$(echo "$lookup" | grep "/$choice/TODO.org")"
  fi
#+end_src
** Pacman
#+begin_src shell :tangle ~/.local/lib/dmenu/pacman
  install=" Install..."
  about=" About..."
  remove=" Remove..."
  manage=" Manage..."
  update=" Update..."
  keyring=" Keyring..."
  edit=" Edit..."

  print_options() {
      echo "$install"
      echo "$about"
      echo "$update"
      echo "$remove"
      echo "$manage"
      echo "$keyring"
      echo "$edit"
  }

  get_fish_cmd() {
      echo "echo 'Running command:'; echo '$*'"
      echo "$*"
  }

  choice="$(print_options | dmenu -l $(print_options | wc -l))"

  case "$choice" in
      "$install")
          cache_file=~/.cache/.aur-package-list.txt
          age="$(date -d "now - $(stat -c '%Y' "$cache_file") seconds" +%s)"
          # Create cache file if it does not exist or is older than 5 hours
          if [ ! -f "$cache_file" ] || [ $age -gt 18000 ]; then
              curl -s 'https://aur.archlinux.org/packages.gz' \
                   -o - | gunzip -c > "$cache_file"
          fi
          # Pull the list of AUR packages
          list="$(cat "$cache_file")"
          # Prepend official packages to the list
          list="$(pacman -Ssq; echo "$list")"
          choice="$(echo "$list" | dmenu -l 20)"
          [ -z "$choice" ] && exit
          cmd="$(pacman -Ss "^$choice\$" >/dev/null && echo sudo pacman -S || echo paru)"
          alacritty --class Alacritty,Float -e fish -C "$(get_fish_cmd $cmd $choice)" && exit
          ;;
      "$about")
          choice="$(echo "$(pacman -Qq)" | dmenu -p 'About:' -l 20)"
          [ -z "$choice" ] && exit
          alacritty --class Alacritty,Float -e fish -C "$(get_fish_cmd pacman -Qi $choice)" && exit
          ;;
      "$update")
          alacritty --class Alacritty,Float -e fish -C "paru -Syu"
          ;;
      "$remove")
          choice="$(pacman -Qq | dmenu -l 20)"
          [ -z "$choice" ] && exit
          alacritty --class Alacritty,Float -e fish -C "$(get_fish_cmd sudo pacman -R $choice)" && exit
          ;;
      "$manage")
          myemacs-float "$(fcmd system-install)"
          ;;
      "$keyring")
          alacritty --class Alacritty,Float -e fish -C "$(get_fish_cmd sudo pacman -Sy archlinux-keyring && exit)"
          ;;
      "$edit")
          gvim "$0"
          ;;
  esac
#+end_src
** Color
#+begin_src bash :tangle ~/.local/lib/dmenu/color
  declare -A colors

  colors[',k black']='         #1e1e1e'
  colors[',r red']='           #ff5555'
  colors[',g green']='         #5ac2a8'
  colors[',y yellow']='        #f2b374'
  colors[',b blue']='          #6980fa'
  colors[',m magenta']='       #d098ff'
  colors[',c cyan']='          #8cceff' # TODO Change to something darker
  colors[',w white']='         #92aab7'
  colors['.k brblack']='       #6b746b'
  colors['.r brred']='         #ff8c8c'
  colors['.g brgreen']='       #98eb98'
  colors['.y bryellow']='      #e0d97b'
  colors['.b brblue']='        #99a3ff'
  colors['.m brmagenta']='     #f298c3'
  colors['.c brcyan']='        #a6d9ff'
  colors['.w brwhite']='       #dddddd'

  get_entries() {
      echo ' Edit...'
      printf '%s\n' "${!colors[@]}" | sort | sed 's_.*_ &_'
  }

  entries=$(get_entries)

  let n=$(echo "$entries" | wc -l)

  choice="$(echo "$entries" | dmenu -l $n -p 'Color:')"

  [ -z "$choice" ] && exit

  if [ "$choice" = ' Edit...' ]; then
      gvim "$0"
      exit
  fi

  # Remove decoration from the choice
  choice_filtered="$(echo $choice | sed 's_[^ ]* *\(.*\)_\1_')"
  # Copy the color, after removing whitespace
  echo -n "${colors["$choice_filtered"]}" | sed 's_[^ ]* *\(.*\)_\1_' | xsel -b
#+end_src
** Unicode
#+begin_src python :tangle ~/.local/lib/dmenu/unicode
  # Choose a font-awesome icon from dmenu and copy it

  from urllib.request import urlopen
  from subprocess import run, PIPE
  import os.path
  import yaml

  # ┏━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Prepare the icon list ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━┛

  cache_file = os.path.expanduser('~/.cache/font-awesome-icon-list.yml')

  # Read the yml file from cache, or download it from GitHub
  if os.path.exists(cache_file):
      text = open(cache_file).read()
  else:
      url = 'https://raw.githubusercontent.com/FortAwesome/Font-Awesome/6.x/metadata/icons.yml'
      data = urlopen(url).read()
      text = data.decode('utf-8')
      open(cache_file, 'w').write(text)

  # Read the YAML file
  data = yaml.load(text, yaml.Loader)

  # ┏━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Add custom options ┃
  # ┗━━━━━━━━━━━━━━━━━━━━┛
  top_entries =   [
      ' Edit...',
      ' FontAwesome...',
      ' From code...',
      ' Get code...',
  ]

  char_entries = []
  # Create a (decorated) list of entries
  for key in data.keys():
      unicode = int(data[key]['unicode'], base=16)
      char_entries.append(chr(unicode) + ' ' + key)

  def add_custom(char):
      global char_entries
      char_entries.append(char + ' [custom]')

  # ┏━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Add custom characters ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━┛
  add_custom('├ |-')
  add_custom('└ |_')
  add_custom('─ --')
  add_custom('┃┗━┛┏━┓ ||')
  add_custom('š .sh')
  add_custom('ć .ch meko')
  add_custom('č .ch tvrdo')
  add_custom('đ .dj')
  add_custom('ž .zj')

  # Form entry lists as multi-line strings
  char_entries = '\n'.join(char_entries)
  # Add options and character entries together
  top_entries  = '\n'.join(top_entries) + '\n' + char_entries

  # Run dmenu and get user choice
  p = run(['dmenu'], stdout=PIPE, input=top_entries, encoding='utf-8')
  choice = p.stdout[:-1]

  def copy_to_clipboard(text):
      run(['xsel', '-b'], input=text, encoding='utf-8')

  # ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Actions based on user's choice ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  if choice[2:] == 'Edit...': # Open this file for editing
     run(['alacritty', '--class', 'Alacritty,Float', '-e', 'fish', '-C',
           'cd (dirname ' + __file__ + '); vim -c "norm 45z." ' + __file__])
  elif choice[2:] == 'FontAwesome...':
      run(['firefox', 'https://fontawesome.com/search'])
  elif choice[2:] == 'From code...':
      p = run(['dmenu', '-p', 'Code:'], stdout=PIPE, input=char_entries, encoding='utf-8')
      open('/home/haris/src/testlog', 'w').write(choice)
      code = p.stdout[:-1]
      if choice:
          copy_to_clipboard(chr(int(code, base=16)))
  elif choice[2:] == 'Get code...':
      p = run(['dmenu', '-p', 'Character:'], stdout=PIPE, input=char_entries, encoding='utf-8')
      choice = p.stdout[:-1]
      if choice:
          copy_to_clipboard(str(ord(choice[0])))
  elif choice:
      copy_to_clipboard(choice.split(' ')[0])
#+end_src
** Kill Process
#+begin_src shell :tangle ~/.local/lib/dmenu/pkill
  choice="$(ps -A -o comm --no-headers | dmenu)"

  [ -z "$choice" ] && exit

  process="$choice"

  choice="$(echo " No\n Yes, kill $process" | dmenu -p 'Sure?' -l 2)"

  [ "$choice" = " Yes, kill $process" ] && pkill "$process"
#+end_src
** Config
#+begin_src python :tangle ~/.local/lib/dmenu/config
  from subprocess import run, PIPE
  import os
  import os.path
  import sys

  # Load regular configuration entries
  entries = run('lscf', stdout=PIPE, encoding='utf-8').stdout.replace('-', ' ')
  # Load dmenu scripts
  dmenu_scripts = os.listdir(os.path.expanduser('~/.local/lib/dmenu/'))

  # ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Additional entries and customization ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  entries = (
      ' Agent...\n' +
      ' Edit...\n' +
      ' ' + entries.replace('\n', '\n ') +
      'dmenu\n dmenu ' +
      '\n dmenu '.join(dmenu_scripts)
  )

  # Run dmenu
  choice = run(['dmenu', '-l', '20',  '-p', 'Config:'],
               input=entries, encoding='utf-8', stdout=PIPE).stdout

  if not choice:
      sys.exit()

  # Strip decoration from the entry
  choice = choice[2:-1].replace(' ', '-')

  def run_command(cmd):
      run(['alacritty', '--class', 'Alacritty,Float', '-e',
           'fish', '-C', cmd])

  # ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
  # ┃ Actions based on user's choice ┃
  # ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
  if choice == 'dmenu':
      EVAL = fr'''
          (progn (find-file "~/.haris/scripts.org")
                 (call-interactively (swiper "^\\* Dmenu"))
                 (evil-ex-nohiglight))
      '''
      run(["myemacs-float", "--eval", EVAL])
  if choice.startswith('dmenu-'):
      submenu = choice.replace("dmenu-", "")
      submenu = submenu[0].upper() + submenu[1:]
      EVAL = fr'''
          (progn (find-file "~/.haris/scripts.org")
                 (call-interactively (swiper "^\\*\\* {submenu}"))
                 (evil-ex-nohiglight))
      '''
      run(["myemacs-float", "--eval", EVAL])
  elif choice == 'Edit...':
      EVAL = '''
          (progn (find-file "~/.haris/scripts.org")
                 (goto-char (org-find-property "CUSTOM_ID" "cf"))
                 (evil-ex-nohiglight))
      '''
      run(["myemacs-float", "--eval", EVAL])
  elif choice == 'Agent...':
      run(["alacritty-float", "-e", "fish", "-C", "cd ~/.haris && opencode --agent build"])
  else:
      run("fish -c 'ecf {}'".format(choice), shell=True)
      sys.exit()
#+end_src
** System
#+begin_src shell :tangle ~/.local/lib/dmenu/system
  choice="$(echo "Suspend\nSuspend & Lock\nShutdown\nReboot..." | dmenu)"

  # No choice, bye-bye
  [ -z "$choice" ] && exit

  if [ "$choice" = "Shutdown" ]; then

      choice="$(echo " No\n Yes, shutdown" | dmenu -p 'Sure?')"
      [ "$choice" = " Yes, shutdown" ] && shutdown now

  elif [ "$choice" = "Suspend & Lock" ]; then
      xlock &  # NOTE: using the 'o' script here doesn't detach tmux for some reason
      sleep 1
      systemctl suspend -i
  elif [ "$choice" = "Suspend" ]; then
      systemctl suspend -i
  elif [ "$choice" = "Reboot..." ]; then
      print_entries() {
          # Extract only lines with menu entries from grub
          grep "menuentry '\|submenu '" /boot/grub/grub.cfg |
              # Only top-level menus are considered
              grep -v -P '\t' |
              # Take only the entry name
              sed "s_\S* '\([^']*\)'.*_\1_" |
              # Add numbers
              nl -w 1 -v 0 -n rn | sed -E 's/\s+/ /g'
      }

      entries="$(print_entries)"
      choice="$(echo "$entries" | dmenu -l $(echo "$entries" | wc -l) | egrep --only-matching '^[0-9]+')"
      [ -z "$choice" ] && exit

      # For convenience, grub-reboot should be allowed passwordless in sudoers.
      sudo grub-reboot "$choice"
      reboot || sudo reboot
  fi
#+end_src
** GPG
#+begin_src bash :tangle ~/.local/lib/dmenu/gpg
  # Get list of all public keys
  keylist=($(gpg --list-public-keys Haris | grep '^\s' | sed 's/^\s*//g'))

  entries="$(
      for key in "${keylist[@]}"; do
          # Get info for key
          keyinfo="$(gpg --list-public-keys | grep "$key" -A1)"
          # Get email of key owner
          email="$(echo "$keyinfo" | grep '<.*>' | sed 's/^.*\]//')"
          echo "$key" "$email"
      done
  )"
  let n="$(echo "$entries" | wc -l)"

  choice="$(echo "$entries" | dmenu -l $n -p 'GPG:')"

  echo "$choice" | awk '{print $1}' | xsel -b
#+end_src
** Books
#+begin_src bash :tangle ~/.local/lib/dmenu/books
  cd ~/data/literature

  choice="$(fd --type file '' | dmenu -l 10 -p 'Book:')"

  [ -z "$choice" ] && exit

  sioyek "$choice"
  sts="$?"

  sleep 2s
  trap 'kill "$pid"' EXIT
  # trap 'printarg kill "$pid"' ERR
  # Ensure that this script stays running as long as the program, so `o` doesn't
  # time out
  while :; do
      pid="$(pgrep -a '' | grep --fixed-strings "$choice" | cut -f1 -d' ' | head -1)"
      if [ -z "$pid" ]; then break; fi
      sleep 5s
  done
#+end_src
** Quickmenu
The quickmenu script is optional and must be provided separately at
[[~/.local/lib/dmenu/quickmenu]].
** Dependencies                                                       :deps:
#+begin_src text :tangle (haris/tangle-deps "dmenu.pacman")
  # Root menu (dmenu_run)
  clipmenu
  # Open menu
  xdotool xorg-xprop
#+end_src
#+begin_src text :tangle (haris/tangle-deps "dmenu.aur")
  # Open menu
  buku
#+end_src
* System maintenance
** =pacman-update-mirrorlist=
#+begin_src shell :tangle ~/.local/bin/pacman-update-mirrorlist
  # Update /etc/pacman.d/mirrorlist using reflector

  sudo reflector --sort rate --save /etc/pacman.d/mirrorlist
#+end_src
** =texclean=
#+begin_src bash :tangle ~/.local/bin/texclean
  # Array of extensions
  extarray=($(sed -e '/^#/d' -e '/^$/d' ~/templates/latex/ignored_files))

  if [ "$1" == '-r' ]; then
      shopt -s globstar
      rm -f ${extarray[*]/#/\*\*\/\*.} # **/*.extension
  else
      rm -f ${extarray[*]/#/\*.} # **/*.extension
  fi

  exit
#+end_src
** =springclean=
#+begin_src shell :tangle ~/.local/bin/springclean
  docker system prune
  docker volume prune

  rm -rf ~/.local/share/Trash
  rm -rf ~/.local/share/*.xbel*

  # I think this is created by KDE plasma
  rm -rf ~/.local/share/baloo

  sudo journalctl --vacuum-size=250M
  paccache -vuk0 -r
#+end_src
** =createhome=
#+begin_src bash :tangle ~/.local/bin/createhome
  # Top level home directory
  dirs=(
      src
      tmp
      repo
      data
  )
  mkdir -p "${dirs[@]}"

  mkdir -p ~/mnt
  cd ~/mnt

  dirs=(
      drive
      dbox
      phone
      android1
      android2
      ssd
      usb
      usb-guest
      usbb1
      usbb2
      vm
  )

  mkdir -p "${dirs[@]}"
#+end_src
** =cleanhome=
#+begin_src shell :tangle ~/.local/bin/cleanhome
  # Clean home of directories like Downloads, Documents, regularly created by who
  # knows.

  rmdir ~/Desktop ~/Downloads ~/Documents ~/Pictures ~/Videos ~/Music \
        ~/Templates ~/Public ~/'VirtualBox VMs' ~/mpv_slicing.log
#+end_src
** =cleantex=
#+begin_src bash :tangle ~/.local/bin/cleantex
  # A script to clean tex build files

  shopt -s globstar

  rm **/*.aux **/*.log **/*.toc **/*.bbl **/*.fls **/*.idx **/*.ilg **/*.ind \
     ,**/*.nlo **/*.out **/*.synctex.gz **/*.fdb_latexmk 2>&1 | grep -v \
                                                                    'No such file or directory'
#+end_src
** =tangle=
#+NAME: tangle
#+begin_src shell :tangle ~/.local/bin/tangle
  ~/.haris/bootstrap/tangle.sh "$@"
#+end_src
Because this script is needed for bootstrapping my dotfiles on a new system, I
also tangle it to a standalone destination that I also keep under version control.
#+begin_src elisp :tangle ~/.haris/bootstrap/tangle.sh :tangle-mode (identity #o755)
  #!/usr/bin/env -S emacs --script

  (load-file (format "%s/tangle.el" (file-name-directory load-file-name)))

  (haris/tangle--file-non-interactively (file-truename (elt argv 0)))

  ; NOTE: Although this file is kept under version control, it is tangled from
  ; ~/.haris/scripts.org, so don't modify it directly
#+end_src
** =tangle-all=
#+NAME: tangle-all
#+begin_src shell :tangle ~/.local/bin/tangle-all
  ~/.haris/bootstrap/tangle-all.sh "$@"
#+end_src
Because this script is needed for bootstrapping my dotfiles on a new system, I
also tangle it to a standalone destination that I also keep under version control.
#+begin_src elisp :tangle ~/.haris/bootstrap/tangle-all.sh :tangle-mode (identity #o755)
  #!/usr/bin/env -S emacs --script

  ;; Tangle all my dotfiles.

  (setq this-script-dir (file-name-directory load-file-name))

  (load-file (format "%s/tangle.el" this-script-dir))
  (haris/tangle-all :dotfiles-dir (expand-file-name
                                   (format "%s/.." this-script-dir)))

  ;; vim: filetype=lisp
  ;; -*- mode: emacs-lisp -*-
  ;; NOTE: Although this file is kept under version control, it is tangled from
  ;; ~/.haris/scripts.org, so don't modify it directly
#+end_src
** =website-healthcheck=
Usage: website-healthcheck [--ignore-success]

Options:
  --notify-success  Show a notification even if the website status is 'alive'
#+begin_src shell :tangle ~/.local/bin/website-healthcheck
  notify_success="$([ "$1" = "--notify-success" ] && echo true)"

  prod_status="$(curl -L https://veracioux.me/status)"
  if [ "$?" != 0 ] || [ "$prod_status" != "alive" ]; then
      ~/.local/bin/notify-send --urgency=critical 'ERROR' 'Production website error'
  elif [ -n "$notify_success" ]; then
      ~/.local/bin/notify-send 'Production website' 'Status: alive'
  fi

  stg_status="$(curl -L https://stg.veracioux.me/status)"
  if [ "$?" != 0 ] || [ "$stg_status" != "alive" ]; then
      ~/.local/bin/notify-send --urgency-critical 'ERROR' 'Staging website error'
  elif [ -n "$notify_success" ]; then
      ~/.local/bin/notify-send 'Staging website' 'Status: alive'
  fi
#+end_src
** =vpn-toggle=                                                       :script:
#+begin_src shell :tangle ~/.local/bin/vpn-toggle
  restart_if_running() {
      if systemctl is-active --quiet "$1"; then
          sudo systemctl restart "$1"
      fi
  }

  if systemctl is-active --quiet protonvpn; then
    sudo systemctl stop protonvpn
  else
    sudo systemctl start protonvpn
  fi

  restart_if_running stubby
  restart_if_running dnsmasq

  # Make vpn-notifier perform an eager query
  systemctl kill --user vpn-notifier --signal=SIGUSR1
#+end_src
** =vpn-notifier=
#+begin_src bash :tangle ~/.local/bin/vpn-notifier
  # Interval at which queries to ipinfo.io are performed periodically
  default_requery_interval_sec=60
  requery_time_after_sigusr1=5s

  echo "PID: $$"

  signal_received=''

  trap 'signal_received=true' SIGUSR1

  old_ip=''

  while :; do
      echo
      echo "Querying ipinfo.io..."
      response="$(curl -fs ipinfo.io)"
      ip="$(jq -r .ip <<<"$response")"
      country="$(jq -r .location <<<"$response")"
      if [ "$ip" != "$old_ip" ]; then
          yaml="$(yq -y 'del(.readme)' <<<"$response")"
          echo
          echo -n "IP changed:"
          if [ -n "$old_ip" ]; then
              notify-send "🌐 IP changed " "$yaml"
          else
              echo -n " (initial state)"
          fi
          echo
          echo
          echo "$(sed 's/^/  /' <<<"$yaml")"
      else
          echo "IP unchanged."
          echo
      fi
      old_ip="$ip"
      for x in $(seq 1 "$default_requery_interval_sec"); do
          sleep 1s
          if [ -n "$signal_received" ]; then
              echo
              echo "Received SIGUSR1, querying ipinfo.io in $requery_time_after_sigusr1..."
              sleep "$requery_time_after_sigusr1"
              signal_received=''
              break
          fi
      done
  done
#+end_src
* Miscellaneous
** =term=
#+begin_src bash :tangle ~/.local/bin/term
  alacritty --working-directory "$PWD" "$@"
#+end_src
** =aurvote=
#+begin_src shell :tangle ~/.local/bin/aurvote
  ssh aur@aur.archlinux.org vote "$@"
#+end_src
** =handle-low-bat=
#+begin_src shell :tangle ~/.local/bin/handle-low-bat
  # Suspend when battery low

  notify() {
      timeout 0.4 notify-send "$@"
  }

  if acpi | grep -qP '\s1?[0-9]%' && acpi | grep -q 'Discharging'; then
      notify 'Low battery' 'Suspending in 5s'
      sleep 5s
      systemctl suspend -i || doas systemctl suspend -i || notify --urgency critical 'Low battery' 'Failed to suspend. See journal of cronie.service for details.'
  fi
#+end_src
*** Dependencies                                                     :deps:
#+begin_src text :tangle (haris/tangle-deps "handle-low-bat.pacman")
  acpi
  doas
#+end_src
** =cronupd=
#+begin_src shell :tangle ~/.local/bin/cronupd
  cat ~/.cron.d/* | crontab -
  crontab -l
#+end_src
** =fix-wifi=
#+begin_src shell :tangle ~/.local/bin/fix-wifi
  sudo rfkill block wifi && sudo rfkill unblock wifi
#+end_src
** =guirun=
Open a GUI window in the correct workspace.
#+begin_src bash :tangle ~/.local/bin/guirun
  # This roundabout way is because i3-msg exec can't handle commas in arguments

  script="$(mktemp)"
  chmod u+x "$script"
  printf "%q " "$@" > "$script"

  i3-msg exec "$script"
  rm -f "$script"
#+end_src
** =snip=
#+begin_src bash :tangle ~/.local/bin/snip
  nvim ~/.vim/snips/"$1".snippets
#+end_src
** =renice-emacs=
Modify niceness of emacs processes to give them higher priority.
#+begin_src shell :tangle ~/.local/bin/renice-emacs
  for pid in $(pgrep emacs); do
      /usr/bin/renice -n -15 "$pid"
  done
#+end_src
** sxhkd
TODO: move to main README

I have three sets of bindings for =sxhkd=:
- common; publicly available in my dotfiles repo
- private; kept in a private repo and not publicly available
- temporary; ad hoc bindings, not versioned at all

I want to be able to enable/disable each of those individually. That's why I
keep each in a separate config file. And, for each I run a separate process so I
can conveniently stop/restart each by name.
*** =sxhkd.private=
#+begin_src bash :tangle ~/.local/bin/sxhkd.private
  exec -a sxhkd.private sxhkd -c ~/.private.sxhkdrc "$@"
#+end_src
*** =sxhkd.tmp=
#+begin_src bash :tangle ~/.local/bin/sxhkd.tmp
  exec -a sxhkd.tmp sxhkd -c ~/.tmp.sxhkdrc "$@"
#+end_src
* Adapters
My main setup is Arch Linux. Sometimes I also use other setups like Ubuntu,
which sometimes have differently named packages and/or executables. I wrap the
executables here so they are available under the same executable names as on
Arch Linux.

By default, the adapters are archived. In order to enable them, simply unarchive
them if the current PC setup is the one they are intended for.
** Ubuntu                                                          :ARCHIVE:
*** =fd=
#+begin_src shell :tangle ~/.local/bin/fd
  fdfind "$@"
#+end_src
*** =passmenu=
#+begin_src shell :tangle ~/.local/bin/passmenu
  /usr/share/doc/pass/examples/dmenu/passmenu "$@"
#+end_src
*** =ipython=
#+begin_src shell :tangle ~/.local/bin/ipython
  # Some platforms don't provide ipython as a symlink/wrapper to ipython3
  ipython3 "$@"
#+end_src
*** =pycharm=
#+begin_src shell :tangle ~/.local/bin/pycharm
  pycharm-professional
#+end_src
*** =code-oss=
#+begin_src shell :tangle ~/.local/bin/code-oss
  code "$@"
#+end_src
* Helper code
These scripts are used as snippets or noweb references within this org file.
** =find-alt-cmd(name)=
Returns the second executable with the given name, looked up in execpath.
#+NAME: find-alt-cmd
#+begin_src emacs-lisp :var name="nil" :results silent
  (let ((counter 0) (executable))
    (locate-file name exec-path nil
                 (lambda (path)
                   (if (file-executable-p path)
                       (setq counter (+ counter 1)))
                   (> counter 1))))
#+end_src

# Quick test...
#+CALL: find-alt-cmd(name="emacs")
** OS-specific code
#+NAME: on-macos
#+begin_src emacs-lisp :var text="" :var else=""
  ;; Insert text only on macOS
  (if (eq system-type 'darwin) text else)
#+end_src
#+NAME: on-linux
#+begin_src emacs-lisp :var text="" :var else=""
  ;; Insert text only on Linux
  (if (eq system-type 'darwin) text else)
#+end_src
** =eval-real-uid=
#+NAME: eval-real-uid
#+begin_src emacs-lisp
  (user-real-uid)
#+end_src
** =add-create-frame-option-if-term-dumb=
#+NAME: add-create-frame-option-if-term-dumb
#+begin_src shell :tangle no
  set -- "$@" $([ "$TERM" = "dumb" ] && echo --create-frame || echo '')
#+end_src
** =eval-user-name=
#+NAME: eval-user-name
#+begin_src elisp
  (user-login-name)
#+end_src
** =eval-user-home=
#+NAME: eval-user-home
#+begin_src emacs-lisp :cache yes
  (getenv "HOME")
#+end_src
* Local variables                                                  :noexport:
# Local Variables:
# org-confirm-babel-evaluate: nil
# End:
