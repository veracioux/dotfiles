#+TITLE: AI Tools
#+SETUPFILE: .setup.org

* Prompts
** System prompt
#+NAME: prompts/system
#+begin_src text
  You are a helpful assistant that can perform various tasks using different
  tools. You are assisting me, a full-stack software engineer with a knack for
  experimentation, using esoteric tools and a commitment to productivity, good
  organization, documentation and overall code quality. I will use your help with
  various projects I am working on, most notably my dotfiles repo.

  «prompts/git-commit»

  «prompts/workarounds/deprioritize-filesystem»
#+end_src
** Git commits
#+NAME: prompts/git-commit
#+begin_src markdown :tangle (haris/tangle-home ".ai/prompts/git-commit.md")
  When making git commits, you will respect the following commit message format:
  ```
  [<TICKET-ID>:] <TYPE>: <SUBJECT>

  [<BODY>]
  ```

  The <TICKET-ID> is optional and should only be included if there is a related
  ticket in an issue tracker, e.g. Jira. You will determine if this is the case
  by looking at the branch name if available. The <TYPE> should be one of the keywords from the
  semantic commit message specification.
  An additional rule you should follow:
  - If there are user-facing changes, you MUST use either feat or fix
  - In other cases, use your best judgement for which one fits best

  The <SUBJECT> should be a short description of the change, ideally no more than
  50 characters. It should be written in the imperative mood, as if giving a
  command. The subject should describe the intent of the change, not a verbatim description
  of the change itself - that can be glanced from the diff.

  If a change is an intermediate step (i.e. the project is not yet in a
  working/testable state), preferably append [skip ci] to the commit message.

  Use <BODY> sparingly, only when you need to explain the change in more detail
  and the subject does not suffice.

  Examples:
  - Branch: feature/ABC-1234-add-login-endpoint
    Commit message:
    ```
    ABC-1234: feat: Add endpoint /v1/auth/login

    - Authenticate users using JWT token
    - Document in OpenAPI spec

    Payload:
      {
        "username": "string",
        "password": "string"
      }
    ```
  - Unspecified branch
    Commit message:
    ```
    refactor: Correct typo in code comment
    ```
    This is a simple commit, so no body is needed.
  - Branch: bugfix/DE-56-fix-unconfigured-integrations
    Commit message:
    ```
    DE-56: fix: Handle unconfigured integrations gracefully

    - Add mutex to prevent desynchronized access where config could be null
    - Add unit test to cover this case
    ```
  - Branch: docs/update-contributing-guidelines
    Commit message:
    ```
    docs: Update contributing guidelines
    ```
  - Unspecified branch
    Commit message:
    ```
    feat: Add prototype data collector [skip ci]

    - Use Kafka for ingress
    - Store data in-memory
    - Persistence is WIP
    ```
    This is an intermediate step that is not yet ready for testing, so it is marked with `[skip ci]`.

  - Unspecified branch
    Single function added
    Commit message:
    ```
    feat: Add function filterByActivity

    The function filters a list of devices by their last activity timestamp.
    ```
    If the name of the function is short and self-explanatory, prefer using the name
    instead of a natural language description of the function in the subject.

  Miscellaneous other examples
  ```
  feat: Add HARDCODED_REPORTING_INTERVALS_MILLIS with 'D5-00-01'
  ```

  Now write the commit message.
#+end_src
** Git commits for dotfiles repo
#+NAME: prompts/git-commit/dotfiles
#+begin_src text :tangle (haris/tangle-home ".ai/prompts/git-commit-dotfiles.md")
  «prompts/git-commit»

  One additional rule:

  - Make sure that before <TYPE>, you also include the <RESOURCE_NAME> that the
    change applies to. This is usually the name before suffix of the ORG file
    that was changed, e.g. for emacs.org you would use 'emacs: ' (without quotes).
    If multiple resources are affected, you can choose a common narrative for the change.

    Examples:
    ```
    refactor: shells: Surround meta section headings with brackets
    feat: shells: fish: Add abbreviation 'l1'
    fix: emacs: Fix dap-mode pet peeves
    feat: vcs: Add alias tra='commit --amend --no-edit --reset-author
    feat: emacs: Add haris/projectile-initialize-project bound to "SPC p ."
    fix: emacs: Load projects before adding fixed ones
    feat: shells: fish: Add api-key-related abbreviations
    ```
#+end_src
** Workarounds
#+NAME: prompts/workarounds/deprioritize-filesystem
#+begin_src text
  If you are asked to describe commands or shell functions, try
  custom-shell-interaction first. Only if that fails to yield results, you can
  inspect the filesystem.
#+end_src
* Host configurations
** mcphost
#+begin_src yaml :tangle (haris/tangle-home ".mcphost.yml")
  mcpServers:
    custom-shell-interaction:
      «mcpServers/custom-shell-interaction»
    git:
      «mcpServers/git»
    filesystem:
      «mcpServers/filesystem»
    playwright:
      «mcpServers/playwright»
  model: openai:gpt-5
  provider-api-key: «get-api-key(provider="openai")»
  system-prompt: |
    «prompts/system»
#+end_src
** Claude Code
#+begin_src json :tangle (haris/tangle-home ".claude/settings.json")
  {
    "apiKeyHelper": "pass show anthropic/api-key | trim"
  }
#+end_src
** Aider
Aider doesn't support MCP yet, so I use [[https://github.com/lutzleonhardt/mcpm-aider][mcpm-aider]].

To use it, when starting Aider, run the following command:
#+begin_src text
  /run mcpm-aider toolprompt
#+end_src

mcpm-aider uses Claude Desktop configuration, so I configure it here:

#+begin_src json :tangle (haris/tangle-home ".config/claude/claude_desktop_config.json")
  {
    "mcpServers": «compact-json(block-name="mcpServers/all/json")»
  }
#+end_src
* MCP Servers
** Git
#+NAME: mcpServers/git
#+begin_src yaml
  type: stdio
  command: uvx
  args:
    - mcp-server-git
  allowedTools:
    - git_status
    - git_diff_unstaged
    - git_diff_staged
    - git_diff
    - git_commit
    - git_add
    - git_log
    - git_create_branch
    - git_checkout
    - git_show
    - git_init
    - git_branch
#+end_src
** Filesystem
#+NAME: mcpServers/filesystem
#+begin_src yaml
  type: stdio
  command: docker
  args:
    - run
    - -i
    - --rm
    - --volume
    - «eval-user-home()»/.haris/:/allowed-directories/dotfiles
    - --user
    - «eval-uid:gid()»
    - mcp/filesystem
    - /allowed-directories
  allowedTools:
    - read_text_file
    - read_media_file
    - read_multiple_files
    - create_directory
    - list_directory
    - move_file
    - search_files
    - get_file_info
    - list_allowed_directories
#+end_src
** Playwright MCP
#+NAME: mcpServers/playwright
#+begin_src yaml
  type: stdio
  command: npx
  args:
    - '@playwright/mcp@latest'
    - --browser
    - firefox
#+end_src
** Custom
*** Custom shell interaction
**** Code
#+begin_src python :tangle (haris/tangle-home ".ai/custom-mcp/custom_shell_interaction.py")
  from typing import Literal
  from mcp.server.fastmcp import FastMCP
  import subprocess
  import shutil

  server = FastMCP()

  runnable_commands: list[str] = [
      "myemacs",
      "notify-send",
  ]


  @server.tool()
  def list_runnable_commands():
      return runnable_commands


  @server.tool()
  def list_all_fish_commands():
      return subprocess.run(["fish", "-c", "complete -C' '"], check=True, capture_output=True).stdout.decode("utf-8").splitlines()


  @server.tool("describe_command")
  def describe_command(
          name: str, is_shell_function: bool, shell: Literal["bash", "fish", None]
  ):
      run = lambda args: subprocess.run(
          (
              ,*((shell, "-c") if shell else ()),
              ,*args,
          ),
          check=False,
          stdout=subprocess.PIPE,
          stderr=subprocess.STDOUT,
      )

      output = ""

      # Print --help
      if name in runnable_commands:
          output += f"Output of `{name} --help`:\n"
          output += run([name, "--help"]).stdout.decode("utf-8")

      # Print manpage
      output += f"Output of `man {name}`:\n"
      output += run([f"man {name}"]).stdout.decode("utf-8")

      # Print output of `help {name}`
      if shell not in ("fish", None):
          output += run(["help", name]).stdout.decode("utf-8")

      # For fish functions, print the type (which includes the definition)
      if shell == "fish":
          output += run([f"type {name}"]).stdout.decode("utf-8")

      # If it is a small custom utility script, often I don't bother to write any
      # help. To heuristically determine if it is such a script, we check if the
      # size is small.
      if shutil.which(name) is not None and shutil.getsize(shutil.which(name)) < 15000:
          output += "The content of the script is:\n"
          output += subprocess.run(["catcmd", name], check=True, capture_output=True).stdout.decode("utf-8")

      return output

  @server.tool()
  def run_command(command: str, args: list[str]):
      if command not in runnable_commands:
          raise Exception("Command is not whitelisted")

      # sanitize arguments for some commands
      if command == "myemacs":
          args = args[:1]

      return subprocess.run([command, *args], check=True)


  # @server.tool(
  #     description="Run an arbitrary script in the given shell. Internally, the script will be opened in an editor where the user can accept/decline/edit it."
  # )
  # def run_arbitrary_script(script: str, shell: Literal["bash", "fish"]):
  #     if shell not in ["bash", "fish"]:
  #         raise Exception("Unsupported shell")

  #     # Open the script in an editor
  #     editor = subprocess.run(
  #         ["visual-editor"],
  #         input=script.encode(),
  #         capture_output=True,
  #         check=True,
  #         text=True,
  #     )

  #     if editor.returncode != 0:
  #         raise Exception("Script editing was cancelled or failed")

  #     # Run the edited script
  #     return subprocess.run([shell, "-c", editor.stdout], check=True)

  if __name__ == '__main__':
      server.run()
#+end_src
**** YAML configuration
#+NAME: mcpServers/custom-shell-interaction
#+begin_src yaml
  type: stdio
  command: python3
  args:
    - «eval-user-home()»/.ai/custom-mcp/custom_shell_interaction.py
  timeout: 2000
#+end_src
**** Test
Eval the following code block:
#+CALL: inspector(server="custom-shell-interaction")
* Appendix
*** Helper functions
**** =get-api-key=
#+NAME: get-api-key
#+begin_src shell :var provider="openai"
  pass show "$provider"/api-key | trim
#+end_src
**** =eval-user-home=
#+NAME: eval-user-home
#+begin_src elisp
  (expand-file-name "~")
#+end_src
**** =eval-uid:gid=
#+NAME: eval-uid:gid
#+begin_src elisp
  (format "%d:%d" (user-uid) (group-gid))
#+end_src
**** =inspector=
#+NAME: inspector
#+begin_src bash :var server=""
  npx @modelcontextprotocol/inspector \
      --config <(yq <~/.mcphost.yml)  \
      --transport stdio                \
      --server "$server"
#+end_src
**** =yaml-to-json=
Takes code block named =block-name=, expands all noweb references, and converts it from YAML to JSON.
#+NAME: yaml-to-json
#+begin_src elisp :var block-name="" :var pretty="no"
  (let ((expanded (haris/org-babel-expand-noweb-references block-name)))
    (let ((json-object-type 'hash-table)
          (json-array-type 'vector)
          (json-false nil)
          (json-true t))
      (with-temp-buffer
        (insert (json-encode (yaml-parse-string expanded)))
        (when (string= pretty "yes")
          (json-pretty-print (point-min) (point-max)))
        (buffer-string))))
#+end_src
**** =get-openai-api-key=
#+NAME: get-openai-api-key
#+begin_src elisp :tangle no
  (when (boundp 'openai-key) openai-key)
#+end_src
**** =compact-json=
#+NAME: compact-json
#+begin_src elisp :var block-name=""
  (json-encode (json-read-from-string (haris/org-babel-expand-noweb-references block-name)))
#+end_src
*** Reusable code blocks
**** All mcpServers (JSON)
JSON block that combines all MCP servers into a single =mcpServers= object.
#+NAME: mcpServers/all/json
#+begin_src json
  {
    "filesystem": «yaml-to-json(block-name="mcpServers/filesystem")»,
    "git": «yaml-to-json(block-name="mcpServers/git")»,
    "playwright": «yaml-to-json(block-name="mcpServers/playwright")»,
    "custom-shell-interaction": «yaml-to-json(block-name="mcpServers/custom-shell-interaction")»
  }
#+end_src
** Local variables
# Local Variables:
# eval: (setq org-confirm-babel-evaluate nil)
# End:
